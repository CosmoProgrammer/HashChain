(function () {
	'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getAugmentedNamespace(n) {
		if (n.__esModule) return n;
		var a = Object.defineProperty({}, '__esModule', {value: true});
		Object.keys(n).forEach(function (k) {
			var d = Object.getOwnPropertyDescriptor(n, k);
			Object.defineProperty(a, k, d.get ? d : {
				enumerable: true,
				get: function () {
					return n[k];
				}
			});
		});
		return a;
	}

	var BinaryBitmap$1 = {};

	var IllegalArgumentException$1 = {};

	var Exception$1 = {};

	function fixProto(target, prototype) {
	  var setPrototypeOf = Object.setPrototypeOf;
	  setPrototypeOf ? setPrototypeOf(target, prototype) : target.__proto__ = prototype;
	}
	function fixStack(target, fn) {
	  if (fn === void 0) {
	    fn = target.constructor;
	  }

	  var captureStackTrace = Error.captureStackTrace;
	  captureStackTrace && captureStackTrace(target, fn);
	}

	var __extends$k = function () {
	  var extendStatics = function (d, b) {
	    extendStatics = Object.setPrototypeOf || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) { if (b.hasOwnProperty(p)) { d[p] = b[p]; } }
	    };

	    return extendStatics(d, b);
	  };

	  return function (d, b) {
	    extendStatics(d, b);

	    function __() {
	      this.constructor = d;
	    }

	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	}();

	var CustomError = function (_super) {
	  __extends$k(CustomError, _super);

	  function CustomError(message) {
	    var _newTarget = this.constructor;

	    var _this = _super.call(this, message) || this;

	    Object.defineProperty(_this, 'name', {
	      value: _newTarget.name,
	      enumerable: false,
	      configurable: true
	    });
	    fixProto(_this, _newTarget.prototype);
	    fixStack(_this);
	    return _this;
	  }

	  return CustomError;
	}(Error);

	var __spreadArrays = function () {
	  var arguments$1 = arguments;

	  for (var s = 0, i = 0, il = arguments.length; i < il; i++) { s += arguments$1[i].length; }

	  for (var r = Array(s), k = 0, i = 0; i < il; i++) { for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) { r[k] = a[j]; } }

	  return r;
	};
	function customErrorFactory(fn, parent) {
	  if (parent === void 0) {
	    parent = Error;
	  }

	  function CustomError() {
	    var arguments$1 = arguments;

	    var args = [];

	    for (var _i = 0; _i < arguments.length; _i++) {
	      args[_i] = arguments$1[_i];
	    }

	    if (!(this instanceof CustomError)) { return new (CustomError.bind.apply(CustomError, __spreadArrays([void 0], args)))(); }
	    parent.apply(this, args);
	    Object.defineProperty(this, 'name', {
	      value: fn.name || parent.name,
	      enumerable: false,
	      configurable: true
	    });
	    fn.apply(this, args);
	    fixStack(this, CustomError);
	  }

	  return Object.defineProperties(CustomError, {
	    prototype: {
	      value: Object.create(parent.prototype, {
	        constructor: {
	          value: CustomError,
	          writable: true,
	          configurable: true
	        }
	      })
	    }
	  });
	}

	var customError = /*#__PURE__*/Object.freeze({
		__proto__: null,
		CustomError: CustomError,
		customErrorFactory: customErrorFactory
	});

	var require$$0 = /*@__PURE__*/getAugmentedNamespace(customError);

	var __extends$j = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(Exception$1, "__esModule", { value: true });
	var ts_custom_error_1 = require$$0;
	/**
	 * Custom Error class of type Exception.
	 */
	var Exception = /** @class */ (function (_super) {
	    __extends$j(Exception, _super);
	    /**
	     * Allows Exception to be constructed directly
	     * with some message and prototype definition.
	     */
	    function Exception(message) {
	        if (message === void 0) { message = undefined; }
	        var _this = _super.call(this, message) || this;
	        _this.message = message;
	        return _this;
	    }
	    Exception.prototype.getKind = function () {
	        var ex = this.constructor;
	        return ex.kind;
	    };
	    /**
	     * It's typed as string so it can be extended and overriden.
	     */
	    Exception.kind = 'Exception';
	    return Exception;
	}(ts_custom_error_1.CustomError));
	Exception$1.default = Exception;

	var __extends$i = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(IllegalArgumentException$1, "__esModule", { value: true });
	var Exception_1$9 = Exception$1;
	/**
	 * Custom Error class of type Exception.
	 */
	var IllegalArgumentException = /** @class */ (function (_super) {
	    __extends$i(IllegalArgumentException, _super);
	    function IllegalArgumentException() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    IllegalArgumentException.kind = 'IllegalArgumentException';
	    return IllegalArgumentException;
	}(Exception_1$9.default));
	IllegalArgumentException$1.default = IllegalArgumentException;

	/*
	 * Copyright 2009 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(BinaryBitmap$1, "__esModule", { value: true });
	var IllegalArgumentException_1$a = IllegalArgumentException$1;
	var BinaryBitmap = /** @class */ (function () {
	    function BinaryBitmap(binarizer) {
	        this.binarizer = binarizer;
	        if (binarizer === null) {
	            throw new IllegalArgumentException_1$a.default('Binarizer must be non-null.');
	        }
	    }
	    /**
	     * @return The width of the bitmap.
	     */
	    BinaryBitmap.prototype.getWidth = function () {
	        return this.binarizer.getWidth();
	    };
	    /**
	     * @return The height of the bitmap.
	     */
	    BinaryBitmap.prototype.getHeight = function () {
	        return this.binarizer.getHeight();
	    };
	    /**
	     * Converts one row of luminance data to 1 bit data. May actually do the conversion, or return
	     * cached data. Callers should assume this method is expensive and call it as seldom as possible.
	     * This method is intended for decoding 1D barcodes and may choose to apply sharpening.
	     *
	     * @param y The row to fetch, which must be in [0, bitmap height)
	     * @param row An optional preallocated array. If null or too small, it will be ignored.
	     *            If used, the Binarizer will call BitArray.clear(). Always use the returned object.
	     * @return The array of bits for this row (true means black).
	     * @throws NotFoundException if row can't be binarized
	     */
	    BinaryBitmap.prototype.getBlackRow = function (y /*int*/, row) {
	        return this.binarizer.getBlackRow(y, row);
	    };
	    /**
	     * Converts a 2D array of luminance data to 1 bit. As above, assume this method is expensive
	     * and do not call it repeatedly. This method is intended for decoding 2D barcodes and may or
	     * may not apply sharpening. Therefore, a row from this matrix may not be identical to one
	     * fetched using getBlackRow(), so don't mix and match between them.
	     *
	     * @return The 2D array of bits for the image (true means black).
	     * @throws NotFoundException if image can't be binarized to make a matrix
	     */
	    BinaryBitmap.prototype.getBlackMatrix = function () {
	        // The matrix is created on demand the first time it is requested, then cached. There are two
	        // reasons for this:
	        // 1. This work will never be done if the caller only installs 1D Reader objects, or if a
	        //    1D Reader finds a barcode before the 2D Readers run.
	        // 2. This work will only be done once even if the caller installs multiple 2D Readers.
	        if (this.matrix === null || this.matrix === undefined) {
	            this.matrix = this.binarizer.getBlackMatrix();
	        }
	        return this.matrix;
	    };
	    /**
	     * @return Whether this bitmap can be cropped.
	     */
	    BinaryBitmap.prototype.isCropSupported = function () {
	        return this.binarizer.getLuminanceSource().isCropSupported();
	    };
	    /**
	     * Returns a new object with cropped image data. Implementations may keep a reference to the
	     * original data rather than a copy. Only callable if isCropSupported() is true.
	     *
	     * @param left The left coordinate, which must be in [0,getWidth())
	     * @param top The top coordinate, which must be in [0,getHeight())
	     * @param width The width of the rectangle to crop.
	     * @param height The height of the rectangle to crop.
	     * @return A cropped version of this object.
	     */
	    BinaryBitmap.prototype.crop = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {
	        var newSource = this.binarizer.getLuminanceSource().crop(left, top, width, height);
	        return new BinaryBitmap(this.binarizer.createBinarizer(newSource));
	    };
	    /**
	     * @return Whether this bitmap supports counter-clockwise rotation.
	     */
	    BinaryBitmap.prototype.isRotateSupported = function () {
	        return this.binarizer.getLuminanceSource().isRotateSupported();
	    };
	    /**
	     * Returns a new object with rotated image data by 90 degrees counterclockwise.
	     * Only callable if {@link #isRotateSupported()} is true.
	     *
	     * @return A rotated version of this object.
	     */
	    BinaryBitmap.prototype.rotateCounterClockwise = function () {
	        var newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise();
	        return new BinaryBitmap(this.binarizer.createBinarizer(newSource));
	    };
	    /**
	     * Returns a new object with rotated image data by 45 degrees counterclockwise.
	     * Only callable if {@link #isRotateSupported()} is true.
	     *
	     * @return A rotated version of this object.
	     */
	    BinaryBitmap.prototype.rotateCounterClockwise45 = function () {
	        var newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise45();
	        return new BinaryBitmap(this.binarizer.createBinarizer(newSource));
	    };
	    /*@Override*/
	    BinaryBitmap.prototype.toString = function () {
	        try {
	            return this.getBlackMatrix().toString();
	        }
	        catch (e /*: NotFoundException*/) {
	            return '';
	        }
	    };
	    return BinaryBitmap;
	}());
	var _default$3 = BinaryBitmap$1.default = BinaryBitmap;

	var HybridBinarizer$1 = {};

	var GlobalHistogramBinarizer$1 = {};

	var Binarizer$1 = {};

	/*
	 * Copyright 2009 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(Binarizer$1, "__esModule", { value: true });
	/**
	 * This class hierarchy provides a set of methods to convert luminance data to 1 bit data.
	 * It allows the algorithm to vary polymorphically, for example allowing a very expensive
	 * thresholding technique for servers and a fast one for mobile. It also permits the implementation
	 * to vary, e.g. a JNI version for Android and a Java fallback version for other platforms.
	 *
	 * @author dswitkin@google.com (Daniel Switkin)
	 */
	var Binarizer = /** @class */ (function () {
	    function Binarizer(source) {
	        this.source = source;
	    }
	    Binarizer.prototype.getLuminanceSource = function () {
	        return this.source;
	    };
	    Binarizer.prototype.getWidth = function () {
	        return this.source.getWidth();
	    };
	    Binarizer.prototype.getHeight = function () {
	        return this.source.getHeight();
	    };
	    return Binarizer;
	}());
	Binarizer$1.default = Binarizer;

	var BitArray$1 = {};

	var Arrays$1 = {};

	var System$1 = {};

	Object.defineProperty(System$1, "__esModule", { value: true });
	var System = /** @class */ (function () {
	    function System() {
	    }
	    // public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)
	    /**
	     * Makes a copy of a array.
	     */
	    System.arraycopy = function (src, srcPos, dest, destPos, length) {
	        // TODO: better use split or set?
	        while (length--) {
	            dest[destPos++] = src[srcPos++];
	        }
	    };
	    /**
	     * Returns the current time in milliseconds.
	     */
	    System.currentTimeMillis = function () {
	        return Date.now();
	    };
	    return System;
	}());
	System$1.default = System;

	var ArrayIndexOutOfBoundsException$1 = {};

	var IndexOutOfBoundsException$1 = {};

	var __extends$h = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(IndexOutOfBoundsException$1, "__esModule", { value: true });
	var Exception_1$8 = Exception$1;
	/**
	 * Custom Error class of type Exception.
	 */
	var IndexOutOfBoundsException = /** @class */ (function (_super) {
	    __extends$h(IndexOutOfBoundsException, _super);
	    function IndexOutOfBoundsException() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    IndexOutOfBoundsException.kind = 'IndexOutOfBoundsException';
	    return IndexOutOfBoundsException;
	}(Exception_1$8.default));
	IndexOutOfBoundsException$1.default = IndexOutOfBoundsException;

	var __extends$g = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(ArrayIndexOutOfBoundsException$1, "__esModule", { value: true });
	var IndexOutOfBoundsException_1 = IndexOutOfBoundsException$1;
	/**
	 * Custom Error class of type Exception.
	 */
	var ArrayIndexOutOfBoundsException = /** @class */ (function (_super) {
	    __extends$g(ArrayIndexOutOfBoundsException, _super);
	    function ArrayIndexOutOfBoundsException(index, message) {
	        if (index === void 0) { index = undefined; }
	        if (message === void 0) { message = undefined; }
	        var _this = _super.call(this, message) || this;
	        _this.index = index;
	        _this.message = message;
	        return _this;
	    }
	    ArrayIndexOutOfBoundsException.kind = 'ArrayIndexOutOfBoundsException';
	    return ArrayIndexOutOfBoundsException;
	}(IndexOutOfBoundsException_1.default));
	ArrayIndexOutOfBoundsException$1.default = ArrayIndexOutOfBoundsException;

	var __values$7 = (commonjsGlobal && commonjsGlobal.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(Arrays$1, "__esModule", { value: true });
	var System_1$5 = System$1;
	var IllegalArgumentException_1$9 = IllegalArgumentException$1;
	var ArrayIndexOutOfBoundsException_1 = ArrayIndexOutOfBoundsException$1;
	var Arrays = /** @class */ (function () {
	    function Arrays() {
	    }
	    /**
	     * Assigns the specified int value to each element of the specified array
	     * of ints.
	     *
	     * @param a the array to be filled
	     * @param val the value to be stored in all elements of the array
	     */
	    Arrays.fill = function (a, val) {
	        for (var i = 0, len = a.length; i < len; i++)
	            a[i] = val;
	    };
	    /**
	     * Assigns the specified int value to each element of the specified
	     * range of the specified array of ints.  The range to be filled
	     * extends from index {@code fromIndex}, inclusive, to index
	     * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the
	     * range to be filled is empty.)
	     *
	     * @param a the array to be filled
	     * @param fromIndex the index of the first element (inclusive) to be
	     *        filled with the specified value
	     * @param toIndex the index of the last element (exclusive) to be
	     *        filled with the specified value
	     * @param val the value to be stored in all elements of the array
	     * @throws IllegalArgumentException if {@code fromIndex > toIndex}
	     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex < 0} or
	     *         {@code toIndex > a.length}
	     */
	    Arrays.fillWithin = function (a, fromIndex, toIndex, val) {
	        Arrays.rangeCheck(a.length, fromIndex, toIndex);
	        for (var i = fromIndex; i < toIndex; i++)
	            a[i] = val;
	    };
	    /**
	     * Checks that {@code fromIndex} and {@code toIndex} are in
	     * the range and throws an exception if they aren't.
	     */
	    Arrays.rangeCheck = function (arrayLength, fromIndex, toIndex) {
	        if (fromIndex > toIndex) {
	            throw new IllegalArgumentException_1$9.default('fromIndex(' + fromIndex + ') > toIndex(' + toIndex + ')');
	        }
	        if (fromIndex < 0) {
	            throw new ArrayIndexOutOfBoundsException_1.default(fromIndex);
	        }
	        if (toIndex > arrayLength) {
	            throw new ArrayIndexOutOfBoundsException_1.default(toIndex);
	        }
	    };
	    Arrays.asList = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        return args;
	    };
	    Arrays.create = function (rows, cols, value) {
	        var arr = Array.from({ length: rows });
	        return arr.map(function (x) { return Array.from({ length: cols }).fill(value); });
	    };
	    Arrays.createInt32Array = function (rows, cols, value) {
	        var arr = Array.from({ length: rows });
	        return arr.map(function (x) { return Int32Array.from({ length: cols }).fill(value); });
	    };
	    Arrays.equals = function (first, second) {
	        if (!first) {
	            return false;
	        }
	        if (!second) {
	            return false;
	        }
	        if (!first.length) {
	            return false;
	        }
	        if (!second.length) {
	            return false;
	        }
	        if (first.length !== second.length) {
	            return false;
	        }
	        for (var i = 0, length_1 = first.length; i < length_1; i++) {
	            if (first[i] !== second[i]) {
	                return false;
	            }
	        }
	        return true;
	    };
	    Arrays.hashCode = function (a) {
	        var e_1, _a;
	        if (a === null) {
	            return 0;
	        }
	        var result = 1;
	        try {
	            for (var a_1 = __values$7(a), a_1_1 = a_1.next(); !a_1_1.done; a_1_1 = a_1.next()) {
	                var element = a_1_1.value;
	                result = 31 * result + element;
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (a_1_1 && !a_1_1.done && (_a = a_1.return)) _a.call(a_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        return result;
	    };
	    Arrays.fillUint8Array = function (a, value) {
	        for (var i = 0; i !== a.length; i++) {
	            a[i] = value;
	        }
	    };
	    Arrays.copyOf = function (original, newLength) {
	        return original.slice(0, newLength);
	    };
	    Arrays.copyOfUint8Array = function (original, newLength) {
	        if (original.length <= newLength) {
	            var newArray = new Uint8Array(newLength);
	            newArray.set(original);
	            return newArray;
	        }
	        return original.slice(0, newLength);
	    };
	    Arrays.copyOfRange = function (original, from, to) {
	        var newLength = to - from;
	        var copy = new Int32Array(newLength);
	        System_1$5.default.arraycopy(original, from, copy, 0, newLength);
	        return copy;
	    };
	    /*
	    * Returns the index of of the element in a sorted array or (-n-1) where n is the insertion point
	    * for the new element.
	    * Parameters:
	    *     ar - A sorted array
	    *     el - An element to search for
	    *     comparator - A comparator function. The function takes two arguments: (a, b) and returns:
	    *        a negative number  if a is less than b;
	    *        0 if a is equal to b;
	    *        a positive number of a is greater than b.
	    * The array may contain duplicate elements. If there are more than one equal elements in the array,
	    * the returned value can be the index of any one of the equal elements.
	    *
	    * http://jsfiddle.net/aryzhov/pkfst550/
	    */
	    Arrays.binarySearch = function (ar, el, comparator) {
	        if (undefined === comparator) {
	            comparator = Arrays.numberComparator;
	        }
	        var m = 0;
	        var n = ar.length - 1;
	        while (m <= n) {
	            var k = (n + m) >> 1;
	            var cmp = comparator(el, ar[k]);
	            if (cmp > 0) {
	                m = k + 1;
	            }
	            else if (cmp < 0) {
	                n = k - 1;
	            }
	            else {
	                return k;
	            }
	        }
	        return -m - 1;
	    };
	    Arrays.numberComparator = function (a, b) {
	        return a - b;
	    };
	    return Arrays;
	}());
	Arrays$1.default = Arrays;

	var Integer$1 = {};

	Object.defineProperty(Integer$1, "__esModule", { value: true });
	/**
	 * Ponyfill for Java's Integer class.
	 */
	var Integer = /** @class */ (function () {
	    function Integer() {
	    }
	    Integer.numberOfTrailingZeros = function (i) {
	        var y;
	        if (i === 0)
	            return 32;
	        var n = 31;
	        y = i << 16;
	        if (y !== 0) {
	            n -= 16;
	            i = y;
	        }
	        y = i << 8;
	        if (y !== 0) {
	            n -= 8;
	            i = y;
	        }
	        y = i << 4;
	        if (y !== 0) {
	            n -= 4;
	            i = y;
	        }
	        y = i << 2;
	        if (y !== 0) {
	            n -= 2;
	            i = y;
	        }
	        return n - ((i << 1) >>> 31);
	    };
	    Integer.numberOfLeadingZeros = function (i) {
	        // HD, Figure 5-6
	        if (i === 0) {
	            return 32;
	        }
	        var n = 1;
	        if (i >>> 16 === 0) {
	            n += 16;
	            i <<= 16;
	        }
	        if (i >>> 24 === 0) {
	            n += 8;
	            i <<= 8;
	        }
	        if (i >>> 28 === 0) {
	            n += 4;
	            i <<= 4;
	        }
	        if (i >>> 30 === 0) {
	            n += 2;
	            i <<= 2;
	        }
	        n -= i >>> 31;
	        return n;
	    };
	    Integer.toHexString = function (i) {
	        return i.toString(16);
	    };
	    Integer.toBinaryString = function (intNumber) {
	        return String(parseInt(String(intNumber), 2));
	    };
	    // Returns the number of one-bits in the two's complement binary representation of the specified int value. This function is sometimes referred to as the population count.
	    // Returns:
	    // the number of one-bits in the two's complement binary representation of the specified int value.
	    Integer.bitCount = function (i) {
	        // HD, Figure 5-2
	        i = i - ((i >>> 1) & 0x55555555);
	        i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
	        i = (i + (i >>> 4)) & 0x0f0f0f0f;
	        i = i + (i >>> 8);
	        i = i + (i >>> 16);
	        return i & 0x3f;
	    };
	    Integer.truncDivision = function (dividend, divisor) {
	        return Math.trunc(dividend / divisor);
	    };
	    /**
	     * Converts A string to an integer.
	     * @param s A string to convert into a number.
	     * @param radix A value between 2 and 36 that specifies the base of the number in numString. If this argument is not supplied, strings with a prefix of '0x' are considered hexadecimal. All other strings are considered decimal.
	     */
	    Integer.parseInt = function (num, radix) {
	        if (radix === void 0) { radix = undefined; }
	        return parseInt(num, radix);
	    };
	    Integer.MIN_VALUE_32_BITS = -2147483648;
	    Integer.MAX_VALUE = Number.MAX_SAFE_INTEGER;
	    return Integer;
	}());
	Integer$1.default = Integer;

	/*
	 * Copyright 2007 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(BitArray$1, "__esModule", { value: true });
	/*namespace com.google.zxing.common {*/
	/*import java.util.Arrays;*/
	var IllegalArgumentException_1$8 = IllegalArgumentException$1;
	var Arrays_1$1 = Arrays$1;
	var Integer_1$2 = Integer$1;
	var System_1$4 = System$1;
	/**
	 * <p>A simple, fast array of bits, represented compactly by an array of ints internally.</p>
	 *
	 * @author Sean Owen
	 */
	var BitArray /*implements Cloneable*/ = /** @class */ (function () {
	    // public constructor() {
	    //   this.size = 0
	    //   this.bits = new Int32Array(1)
	    // }
	    // public constructor(size?: number /*int*/) {
	    //   if (undefined === size) {
	    //     this.size = 0
	    //   } else {
	    //     this.size = size
	    //   }
	    //   this.bits = this.makeArray(size)
	    // }
	    // For testing only
	    function BitArray(size /*int*/, bits) {
	        if (undefined === size) {
	            this.size = 0;
	            this.bits = new Int32Array(1);
	        }
	        else {
	            this.size = size;
	            if (undefined === bits || null === bits) {
	                this.bits = BitArray.makeArray(size);
	            }
	            else {
	                this.bits = bits;
	            }
	        }
	    }
	    BitArray.prototype.getSize = function () {
	        return this.size;
	    };
	    BitArray.prototype.getSizeInBytes = function () {
	        return Math.floor((this.size + 7) / 8);
	    };
	    BitArray.prototype.ensureCapacity = function (size /*int*/) {
	        if (size > this.bits.length * 32) {
	            var newBits = BitArray.makeArray(size);
	            System_1$4.default.arraycopy(this.bits, 0, newBits, 0, this.bits.length);
	            this.bits = newBits;
	        }
	    };
	    /**
	     * @param i bit to get
	     * @return true iff bit i is set
	     */
	    BitArray.prototype.get = function (i /*int*/) {
	        return (this.bits[Math.floor(i / 32)] & (1 << (i & 0x1F))) !== 0;
	    };
	    /**
	     * Sets bit i.
	     *
	     * @param i bit to set
	     */
	    BitArray.prototype.set = function (i /*int*/) {
	        this.bits[Math.floor(i / 32)] |= 1 << (i & 0x1F);
	    };
	    /**
	     * Flips bit i.
	     *
	     * @param i bit to set
	     */
	    BitArray.prototype.flip = function (i /*int*/) {
	        this.bits[Math.floor(i / 32)] ^= 1 << (i & 0x1F);
	    };
	    /**
	     * @param from first bit to check
	     * @return index of first bit that is set, starting from the given index, or size if none are set
	     *  at or beyond this given index
	     * @see #getNextUnset(int)
	     */
	    BitArray.prototype.getNextSet = function (from /*int*/) {
	        var size = this.size;
	        if (from >= size) {
	            return size;
	        }
	        var bits = this.bits;
	        var bitsOffset = Math.floor(from / 32);
	        var currentBits = bits[bitsOffset];
	        // mask off lesser bits first
	        currentBits &= ~((1 << (from & 0x1F)) - 1);
	        var length = bits.length;
	        while (currentBits === 0) {
	            if (++bitsOffset === length) {
	                return size;
	            }
	            currentBits = bits[bitsOffset];
	        }
	        var result = (bitsOffset * 32) + Integer_1$2.default.numberOfTrailingZeros(currentBits);
	        return result > size ? size : result;
	    };
	    /**
	     * @param from index to start looking for unset bit
	     * @return index of next unset bit, or {@code size} if none are unset until the end
	     * @see #getNextSet(int)
	     */
	    BitArray.prototype.getNextUnset = function (from /*int*/) {
	        var size = this.size;
	        if (from >= size) {
	            return size;
	        }
	        var bits = this.bits;
	        var bitsOffset = Math.floor(from / 32);
	        var currentBits = ~bits[bitsOffset];
	        // mask off lesser bits first
	        currentBits &= ~((1 << (from & 0x1F)) - 1);
	        var length = bits.length;
	        while (currentBits === 0) {
	            if (++bitsOffset === length) {
	                return size;
	            }
	            currentBits = ~bits[bitsOffset];
	        }
	        var result = (bitsOffset * 32) + Integer_1$2.default.numberOfTrailingZeros(currentBits);
	        return result > size ? size : result;
	    };
	    /**
	     * Sets a block of 32 bits, starting at bit i.
	     *
	     * @param i first bit to set
	     * @param newBits the new value of the next 32 bits. Note again that the least-significant bit
	     * corresponds to bit i, the next-least-significant to i+1, and so on.
	     */
	    BitArray.prototype.setBulk = function (i /*int*/, newBits /*int*/) {
	        this.bits[Math.floor(i / 32)] = newBits;
	    };
	    /**
	     * Sets a range of bits.
	     *
	     * @param start start of range, inclusive.
	     * @param end end of range, exclusive
	     */
	    BitArray.prototype.setRange = function (start /*int*/, end /*int*/) {
	        if (end < start || start < 0 || end > this.size) {
	            throw new IllegalArgumentException_1$8.default();
	        }
	        if (end === start) {
	            return;
	        }
	        end--; // will be easier to treat this as the last actually set bit -- inclusive
	        var firstInt = Math.floor(start / 32);
	        var lastInt = Math.floor(end / 32);
	        var bits = this.bits;
	        for (var i = firstInt; i <= lastInt; i++) {
	            var firstBit = i > firstInt ? 0 : start & 0x1F;
	            var lastBit = i < lastInt ? 31 : end & 0x1F;
	            // Ones from firstBit to lastBit, inclusive
	            var mask = (2 << lastBit) - (1 << firstBit);
	            bits[i] |= mask;
	        }
	    };
	    /**
	     * Clears all bits (sets to false).
	     */
	    BitArray.prototype.clear = function () {
	        var max = this.bits.length;
	        var bits = this.bits;
	        for (var i = 0; i < max; i++) {
	            bits[i] = 0;
	        }
	    };
	    /**
	     * Efficient method to check if a range of bits is set, or not set.
	     *
	     * @param start start of range, inclusive.
	     * @param end end of range, exclusive
	     * @param value if true, checks that bits in range are set, otherwise checks that they are not set
	     * @return true iff all bits are set or not set in range, according to value argument
	     * @throws IllegalArgumentException if end is less than start or the range is not contained in the array
	     */
	    BitArray.prototype.isRange = function (start /*int*/, end /*int*/, value) {
	        if (end < start || start < 0 || end > this.size) {
	            throw new IllegalArgumentException_1$8.default();
	        }
	        if (end === start) {
	            return true; // empty range matches
	        }
	        end--; // will be easier to treat this as the last actually set bit -- inclusive
	        var firstInt = Math.floor(start / 32);
	        var lastInt = Math.floor(end / 32);
	        var bits = this.bits;
	        for (var i = firstInt; i <= lastInt; i++) {
	            var firstBit = i > firstInt ? 0 : start & 0x1F;
	            var lastBit = i < lastInt ? 31 : end & 0x1F;
	            // Ones from firstBit to lastBit, inclusive
	            var mask = (2 << lastBit) - (1 << firstBit) & 0xFFFFFFFF;
	            // TYPESCRIPTPORT: & 0xFFFFFFFF added to discard anything after 32 bits, as ES has 53 bits
	            // Return false if we're looking for 1s and the masked bits[i] isn't all 1s (is: that,
	            // equals the mask, or we're looking for 0s and the masked portion is not all 0s
	            if ((bits[i] & mask) !== (value ? mask : 0)) {
	                return false;
	            }
	        }
	        return true;
	    };
	    BitArray.prototype.appendBit = function (bit) {
	        this.ensureCapacity(this.size + 1);
	        if (bit) {
	            this.bits[Math.floor(this.size / 32)] |= 1 << (this.size & 0x1F);
	        }
	        this.size++;
	    };
	    /**
	     * Appends the least-significant bits, from value, in order from most-significant to
	     * least-significant. For example, appending 6 bits from 0x000001E will append the bits
	     * 0, 1, 1, 1, 1, 0 in that order.
	     *
	     * @param value {@code int} containing bits to append
	     * @param numBits bits from value to append
	     */
	    BitArray.prototype.appendBits = function (value /*int*/, numBits /*int*/) {
	        if (numBits < 0 || numBits > 32) {
	            throw new IllegalArgumentException_1$8.default('Num bits must be between 0 and 32');
	        }
	        this.ensureCapacity(this.size + numBits);
	        // const appendBit = this.appendBit;
	        for (var numBitsLeft = numBits; numBitsLeft > 0; numBitsLeft--) {
	            this.appendBit(((value >> (numBitsLeft - 1)) & 0x01) === 1);
	        }
	    };
	    BitArray.prototype.appendBitArray = function (other) {
	        var otherSize = other.size;
	        this.ensureCapacity(this.size + otherSize);
	        // const appendBit = this.appendBit;
	        for (var i = 0; i < otherSize; i++) {
	            this.appendBit(other.get(i));
	        }
	    };
	    BitArray.prototype.xor = function (other) {
	        if (this.size !== other.size) {
	            throw new IllegalArgumentException_1$8.default('Sizes don\'t match');
	        }
	        var bits = this.bits;
	        for (var i = 0, length_1 = bits.length; i < length_1; i++) {
	            // The last int could be incomplete (i.e. not have 32 bits in
	            // it) but there is no problem since 0 XOR 0 == 0.
	            bits[i] ^= other.bits[i];
	        }
	    };
	    /**
	     *
	     * @param bitOffset first bit to start writing
	     * @param array array to write into. Bytes are written most-significant byte first. This is the opposite
	     *  of the internal representation, which is exposed by {@link #getBitArray()}
	     * @param offset position in array to start writing
	     * @param numBytes how many bytes to write
	     */
	    BitArray.prototype.toBytes = function (bitOffset /*int*/, array, offset /*int*/, numBytes /*int*/) {
	        for (var i = 0; i < numBytes; i++) {
	            var theByte = 0;
	            for (var j = 0; j < 8; j++) {
	                if (this.get(bitOffset)) {
	                    theByte |= 1 << (7 - j);
	                }
	                bitOffset++;
	            }
	            array[offset + i] = /*(byte)*/ theByte;
	        }
	    };
	    /**
	     * @return underlying array of ints. The first element holds the first 32 bits, and the least
	     *         significant bit is bit 0.
	     */
	    BitArray.prototype.getBitArray = function () {
	        return this.bits;
	    };
	    /**
	     * Reverses all bits in the array.
	     */
	    BitArray.prototype.reverse = function () {
	        var newBits = new Int32Array(this.bits.length);
	        // reverse all int's first
	        var len = Math.floor((this.size - 1) / 32);
	        var oldBitsLen = len + 1;
	        var bits = this.bits;
	        for (var i = 0; i < oldBitsLen; i++) {
	            var x = bits[i];
	            x = ((x >> 1) & 0x55555555) | ((x & 0x55555555) << 1);
	            x = ((x >> 2) & 0x33333333) | ((x & 0x33333333) << 2);
	            x = ((x >> 4) & 0x0f0f0f0f) | ((x & 0x0f0f0f0f) << 4);
	            x = ((x >> 8) & 0x00ff00ff) | ((x & 0x00ff00ff) << 8);
	            x = ((x >> 16) & 0x0000ffff) | ((x & 0x0000ffff) << 16);
	            newBits[len - i] = /*(int)*/ x;
	        }
	        // now correct the int's if the bit size isn't a multiple of 32
	        if (this.size !== oldBitsLen * 32) {
	            var leftOffset = oldBitsLen * 32 - this.size;
	            var currentInt = newBits[0] >>> leftOffset;
	            for (var i = 1; i < oldBitsLen; i++) {
	                var nextInt = newBits[i];
	                currentInt |= nextInt << (32 - leftOffset);
	                newBits[i - 1] = currentInt;
	                currentInt = nextInt >>> leftOffset;
	            }
	            newBits[oldBitsLen - 1] = currentInt;
	        }
	        this.bits = newBits;
	    };
	    BitArray.makeArray = function (size /*int*/) {
	        return new Int32Array(Math.floor((size + 31) / 32));
	    };
	    /*@Override*/
	    BitArray.prototype.equals = function (o) {
	        if (!(o instanceof BitArray)) {
	            return false;
	        }
	        var other = o;
	        return this.size === other.size && Arrays_1$1.default.equals(this.bits, other.bits);
	    };
	    /*@Override*/
	    BitArray.prototype.hashCode = function () {
	        return 31 * this.size + Arrays_1$1.default.hashCode(this.bits);
	    };
	    /*@Override*/
	    BitArray.prototype.toString = function () {
	        var result = '';
	        for (var i = 0, size = this.size; i < size; i++) {
	            if ((i & 0x07) === 0) {
	                result += ' ';
	            }
	            result += this.get(i) ? 'X' : '.';
	        }
	        return result;
	    };
	    /*@Override*/
	    BitArray.prototype.clone = function () {
	        return new BitArray(this.size, this.bits.slice());
	    };
	    return BitArray;
	}());
	BitArray$1.default = BitArray;

	var BitMatrix$1 = {};

	var StringBuilder$1 = {};

	var StringUtils$1 = {};

	var DecodeHintType$1 = {};

	/*
	 * Copyright 2009 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(DecodeHintType$1, "__esModule", { value: true });
	/*namespace com.google.zxing {*/
	/**
	 * Encapsulates a type of hint that a caller may pass to a barcode reader to help it
	 * more quickly or accurately decode it. It is up to implementations to decide what,
	 * if anything, to do with the information that is supplied.
	 *
	 * @author Sean Owen
	 * @author dswitkin@google.com (Daniel Switkin)
	 * @see Reader#decode(BinaryBitmap,java.util.Map)
	 */
	var DecodeHintType;
	(function (DecodeHintType) {
	    /**
	     * Unspecified, application-specific hint. Maps to an unspecified {@link Object}.
	     */
	    DecodeHintType[DecodeHintType["OTHER"] = 0] = "OTHER"; /*(Object.class)*/
	    /**
	     * Image is a pure monochrome image of a barcode. Doesn't matter what it maps to;
	     * use {@link Boolean#TRUE}.
	     */
	    DecodeHintType[DecodeHintType["PURE_BARCODE"] = 1] = "PURE_BARCODE"; /*(Void.class)*/
	    /**
	     * Image is known to be of one of a few possible formats.
	     * Maps to a {@link List} of {@link BarcodeFormat}s.
	     */
	    DecodeHintType[DecodeHintType["POSSIBLE_FORMATS"] = 2] = "POSSIBLE_FORMATS"; /*(List.class)*/
	    /**
	     * Spend more time to try to find a barcode; optimize for accuracy, not speed.
	     * Doesn't matter what it maps to; use {@link Boolean#TRUE}.
	     */
	    DecodeHintType[DecodeHintType["TRY_HARDER"] = 3] = "TRY_HARDER"; /*(Void.class)*/
	    /**
	     * Specifies what character encoding to use when decoding, where applicable (type String)
	     */
	    DecodeHintType[DecodeHintType["CHARACTER_SET"] = 4] = "CHARACTER_SET"; /*(String.class)*/
	    /**
	     * Allowed lengths of encoded data -- reject anything else. Maps to an {@code Int32Array}.
	     */
	    DecodeHintType[DecodeHintType["ALLOWED_LENGTHS"] = 5] = "ALLOWED_LENGTHS"; /*(Int32Array.class)*/
	    /**
	     * Assume Code 39 codes employ a check digit. Doesn't matter what it maps to;
	     * use {@link Boolean#TRUE}.
	     */
	    DecodeHintType[DecodeHintType["ASSUME_CODE_39_CHECK_DIGIT"] = 6] = "ASSUME_CODE_39_CHECK_DIGIT"; /*(Void.class)*/
	    /**
	     * Assume the barcode is being processed as a GS1 barcode, and modify behavior as needed.
	     * For example this affects FNC1 handling for Code 128 (aka GS1-128). Doesn't matter what it maps to;
	     * use {@link Boolean#TRUE}.
	     */
	    DecodeHintType[DecodeHintType["ASSUME_GS1"] = 7] = "ASSUME_GS1"; /*(Void.class)*/
	    /**
	     * If true, return the start and end digits in a Codabar barcode instead of stripping them. They
	     * are alpha, whereas the rest are numeric. By default, they are stripped, but this causes them
	     * to not be. Doesn't matter what it maps to; use {@link Boolean#TRUE}.
	     */
	    DecodeHintType[DecodeHintType["RETURN_CODABAR_START_END"] = 8] = "RETURN_CODABAR_START_END"; /*(Void.class)*/
	    /**
	     * The caller needs to be notified via callback when a possible {@link ResultPoint}
	     * is found. Maps to a {@link ResultPointCallback}.
	     */
	    DecodeHintType[DecodeHintType["NEED_RESULT_POINT_CALLBACK"] = 9] = "NEED_RESULT_POINT_CALLBACK"; /*(ResultPointCallback.class)*/
	    /**
	     * Allowed extension lengths for EAN or UPC barcodes. Other formats will ignore this.
	     * Maps to an {@code Int32Array} of the allowed extension lengths, for example [2], [5], or [2, 5].
	     * If it is optional to have an extension, do not set this hint. If this is set,
	     * and a UPC or EAN barcode is found but an extension is not, then no result will be returned
	     * at all.
	     */
	    DecodeHintType[DecodeHintType["ALLOWED_EAN_EXTENSIONS"] = 10] = "ALLOWED_EAN_EXTENSIONS"; /*(Int32Array.class)*/
	    // End of enumeration values.
	    /**
	     * Data type the hint is expecting.
	     * Among the possible values the {@link Void} stands out as being used for
	     * hints that do not expect a value to be supplied (flag hints). Such hints
	     * will possibly have their value ignored, or replaced by a
	     * {@link Boolean#TRUE}. Hint suppliers should probably use
	     * {@link Boolean#TRUE} as directed by the actual hint documentation.
	     */
	    // private valueType: Class<?>
	    // DecodeHintType(valueType: Class<?>) {
	    //   this.valueType = valueType
	    // }
	    // public getValueType(): Class<?> {
	    //   return valueType
	    // }
	})(DecodeHintType || (DecodeHintType = {}));
	DecodeHintType$1.default = DecodeHintType;

	var CharacterSetECI = {};

	var FormatException$1 = {};

	var __extends$f = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(FormatException$1, "__esModule", { value: true });
	var Exception_1$7 = Exception$1;
	/**
	 * Custom Error class of type Exception.
	 */
	var FormatException = /** @class */ (function (_super) {
	    __extends$f(FormatException, _super);
	    function FormatException() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    FormatException.getFormatInstance = function () {
	        return new FormatException();
	    };
	    FormatException.kind = 'FormatException';
	    return FormatException;
	}(Exception_1$7.default));
	FormatException$1.default = FormatException;

	(function (exports) {
	/*
	 * Copyright 2008 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __values = (commonjsGlobal && commonjsGlobal.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.CharacterSetValueIdentifiers = void 0;
	/*namespace com.google.zxing.common {*/
	var FormatException_1 = FormatException$1;
	/*import java.util.HashMap;*/
	/*import java.util.Map;*/
	var CharacterSetValueIdentifiers;
	(function (CharacterSetValueIdentifiers) {
	    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["Cp437"] = 0] = "Cp437";
	    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_1"] = 1] = "ISO8859_1";
	    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_2"] = 2] = "ISO8859_2";
	    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_3"] = 3] = "ISO8859_3";
	    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_4"] = 4] = "ISO8859_4";
	    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_5"] = 5] = "ISO8859_5";
	    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_6"] = 6] = "ISO8859_6";
	    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_7"] = 7] = "ISO8859_7";
	    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_8"] = 8] = "ISO8859_8";
	    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_9"] = 9] = "ISO8859_9";
	    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_10"] = 10] = "ISO8859_10";
	    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_11"] = 11] = "ISO8859_11";
	    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_13"] = 12] = "ISO8859_13";
	    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_14"] = 13] = "ISO8859_14";
	    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_15"] = 14] = "ISO8859_15";
	    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_16"] = 15] = "ISO8859_16";
	    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["SJIS"] = 16] = "SJIS";
	    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["Cp1250"] = 17] = "Cp1250";
	    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["Cp1251"] = 18] = "Cp1251";
	    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["Cp1252"] = 19] = "Cp1252";
	    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["Cp1256"] = 20] = "Cp1256";
	    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["UnicodeBigUnmarked"] = 21] = "UnicodeBigUnmarked";
	    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["UTF8"] = 22] = "UTF8";
	    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ASCII"] = 23] = "ASCII";
	    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["Big5"] = 24] = "Big5";
	    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["GB18030"] = 25] = "GB18030";
	    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["EUC_KR"] = 26] = "EUC_KR";
	})(CharacterSetValueIdentifiers = exports.CharacterSetValueIdentifiers || (exports.CharacterSetValueIdentifiers = {}));
	/**
	 * Encapsulates a Character Set ECI, according to "Extended Channel Interpretations" 5.3.1.1
	 * of ISO 18004.
	 *
	 * @author Sean Owen
	 */
	var CharacterSetECI = /** @class */ (function () {
	    function CharacterSetECI(valueIdentifier, valuesParam, name) {
	        var e_1, _a;
	        var otherEncodingNames = [];
	        for (var _i = 3; _i < arguments.length; _i++) {
	            otherEncodingNames[_i - 3] = arguments[_i];
	        }
	        this.valueIdentifier = valueIdentifier;
	        this.name = name;
	        if (typeof valuesParam === 'number') {
	            this.values = Int32Array.from([valuesParam]);
	        }
	        else {
	            this.values = valuesParam;
	        }
	        this.otherEncodingNames = otherEncodingNames;
	        CharacterSetECI.VALUE_IDENTIFIER_TO_ECI.set(valueIdentifier, this);
	        CharacterSetECI.NAME_TO_ECI.set(name, this);
	        var values = this.values;
	        for (var i = 0, length_1 = values.length; i !== length_1; i++) {
	            var v = values[i];
	            CharacterSetECI.VALUES_TO_ECI.set(v, this);
	        }
	        try {
	            for (var otherEncodingNames_1 = __values(otherEncodingNames), otherEncodingNames_1_1 = otherEncodingNames_1.next(); !otherEncodingNames_1_1.done; otherEncodingNames_1_1 = otherEncodingNames_1.next()) {
	                var otherName = otherEncodingNames_1_1.value;
	                CharacterSetECI.NAME_TO_ECI.set(otherName, this);
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (otherEncodingNames_1_1 && !otherEncodingNames_1_1.done && (_a = otherEncodingNames_1.return)) _a.call(otherEncodingNames_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	    }
	    // CharacterSetECI(value: number /*int*/) {
	    //   this(new Int32Array {value})
	    // }
	    // CharacterSetECI(value: number /*int*/, String... otherEncodingNames) {
	    //   this.values = new Int32Array {value}
	    //   this.otherEncodingNames = otherEncodingNames
	    // }
	    // CharacterSetECI(values: Int32Array, String... otherEncodingNames) {
	    //   this.values = values
	    //   this.otherEncodingNames = otherEncodingNames
	    // }
	    CharacterSetECI.prototype.getValueIdentifier = function () {
	        return this.valueIdentifier;
	    };
	    CharacterSetECI.prototype.getName = function () {
	        return this.name;
	    };
	    CharacterSetECI.prototype.getValue = function () {
	        return this.values[0];
	    };
	    /**
	     * @param value character set ECI value
	     * @return {@code CharacterSetECI} representing ECI of given value, or null if it is legal but
	     *   unsupported
	     * @throws FormatException if ECI value is invalid
	     */
	    CharacterSetECI.getCharacterSetECIByValue = function (value /*int*/) {
	        if (value < 0 || value >= 900) {
	            throw new FormatException_1.default('incorect value');
	        }
	        var characterSet = CharacterSetECI.VALUES_TO_ECI.get(value);
	        if (undefined === characterSet) {
	            throw new FormatException_1.default('incorect value');
	        }
	        return characterSet;
	    };
	    /**
	     * @param name character set ECI encoding name
	     * @return CharacterSetECI representing ECI for character encoding, or null if it is legal
	     *   but unsupported
	     */
	    CharacterSetECI.getCharacterSetECIByName = function (name) {
	        var characterSet = CharacterSetECI.NAME_TO_ECI.get(name);
	        if (undefined === characterSet) {
	            throw new FormatException_1.default('incorect value');
	        }
	        return characterSet;
	    };
	    CharacterSetECI.prototype.equals = function (o) {
	        if (!(o instanceof CharacterSetECI)) {
	            return false;
	        }
	        var other = o;
	        return this.getName() === other.getName();
	    };
	    CharacterSetECI.VALUE_IDENTIFIER_TO_ECI = new Map();
	    CharacterSetECI.VALUES_TO_ECI = new Map();
	    CharacterSetECI.NAME_TO_ECI = new Map();
	    // Enum name is a Java encoding valid for java.lang and java.io
	    // TYPESCRIPTPORT: changed the main label for ISO as the TextEncoder did not recognized them in the form from java
	    // (eg ISO8859_1 must be ISO88591 or ISO8859-1 or ISO-8859-1)
	    // later on: well, except 16 wich does not work with ISO885916 so used ISO-8859-1 form for default
	    CharacterSetECI.Cp437 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp437, Int32Array.from([0, 2]), 'Cp437');
	    CharacterSetECI.ISO8859_1 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_1, Int32Array.from([1, 3]), 'ISO-8859-1', 'ISO88591', 'ISO8859_1');
	    CharacterSetECI.ISO8859_2 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_2, 4, 'ISO-8859-2', 'ISO88592', 'ISO8859_2');
	    CharacterSetECI.ISO8859_3 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_3, 5, 'ISO-8859-3', 'ISO88593', 'ISO8859_3');
	    CharacterSetECI.ISO8859_4 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_4, 6, 'ISO-8859-4', 'ISO88594', 'ISO8859_4');
	    CharacterSetECI.ISO8859_5 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_5, 7, 'ISO-8859-5', 'ISO88595', 'ISO8859_5');
	    CharacterSetECI.ISO8859_6 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_6, 8, 'ISO-8859-6', 'ISO88596', 'ISO8859_6');
	    CharacterSetECI.ISO8859_7 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_7, 9, 'ISO-8859-7', 'ISO88597', 'ISO8859_7');
	    CharacterSetECI.ISO8859_8 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_8, 10, 'ISO-8859-8', 'ISO88598', 'ISO8859_8');
	    CharacterSetECI.ISO8859_9 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_9, 11, 'ISO-8859-9', 'ISO88599', 'ISO8859_9');
	    CharacterSetECI.ISO8859_10 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_10, 12, 'ISO-8859-10', 'ISO885910', 'ISO8859_10');
	    CharacterSetECI.ISO8859_11 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_11, 13, 'ISO-8859-11', 'ISO885911', 'ISO8859_11');
	    CharacterSetECI.ISO8859_13 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_13, 15, 'ISO-8859-13', 'ISO885913', 'ISO8859_13');
	    CharacterSetECI.ISO8859_14 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_14, 16, 'ISO-8859-14', 'ISO885914', 'ISO8859_14');
	    CharacterSetECI.ISO8859_15 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_15, 17, 'ISO-8859-15', 'ISO885915', 'ISO8859_15');
	    CharacterSetECI.ISO8859_16 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_16, 18, 'ISO-8859-16', 'ISO885916', 'ISO8859_16');
	    CharacterSetECI.SJIS = new CharacterSetECI(CharacterSetValueIdentifiers.SJIS, 20, 'SJIS', 'Shift_JIS');
	    CharacterSetECI.Cp1250 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1250, 21, 'Cp1250', 'windows-1250');
	    CharacterSetECI.Cp1251 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1251, 22, 'Cp1251', 'windows-1251');
	    CharacterSetECI.Cp1252 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1252, 23, 'Cp1252', 'windows-1252');
	    CharacterSetECI.Cp1256 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1256, 24, 'Cp1256', 'windows-1256');
	    CharacterSetECI.UnicodeBigUnmarked = new CharacterSetECI(CharacterSetValueIdentifiers.UnicodeBigUnmarked, 25, 'UnicodeBigUnmarked', 'UTF-16BE', 'UnicodeBig');
	    CharacterSetECI.UTF8 = new CharacterSetECI(CharacterSetValueIdentifiers.UTF8, 26, 'UTF8', 'UTF-8');
	    CharacterSetECI.ASCII = new CharacterSetECI(CharacterSetValueIdentifiers.ASCII, Int32Array.from([27, 170]), 'ASCII', 'US-ASCII');
	    CharacterSetECI.Big5 = new CharacterSetECI(CharacterSetValueIdentifiers.Big5, 28, 'Big5');
	    CharacterSetECI.GB18030 = new CharacterSetECI(CharacterSetValueIdentifiers.GB18030, 29, 'GB18030', 'GB2312', 'EUC_CN', 'GBK');
	    CharacterSetECI.EUC_KR = new CharacterSetECI(CharacterSetValueIdentifiers.EUC_KR, 30, 'EUC_KR', 'EUC-KR');
	    return CharacterSetECI;
	}());
	exports.default = CharacterSetECI;

	}(CharacterSetECI));

	var StringEncoding$1 = {};

	var UnsupportedOperationException$1 = {};

	var __extends$e = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(UnsupportedOperationException$1, "__esModule", { value: true });
	var Exception_1$6 = Exception$1;
	/**
	 * Custom Error class of type Exception.
	 */
	var UnsupportedOperationException = /** @class */ (function (_super) {
	    __extends$e(UnsupportedOperationException, _super);
	    function UnsupportedOperationException() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    UnsupportedOperationException.kind = 'UnsupportedOperationException';
	    return UnsupportedOperationException;
	}(Exception_1$6.default));
	UnsupportedOperationException$1.default = UnsupportedOperationException;

	Object.defineProperty(StringEncoding$1, "__esModule", { value: true });
	var UnsupportedOperationException_1$1 = UnsupportedOperationException$1;
	var CharacterSetECI_1$2 = CharacterSetECI;
	/**
	 * Responsible for en/decoding strings.
	 */
	var StringEncoding = /** @class */ (function () {
	    function StringEncoding() {
	    }
	    /**
	     * Decodes some Uint8Array to a string format.
	     */
	    StringEncoding.decode = function (bytes, encoding) {
	        var encodingName = this.encodingName(encoding);
	        if (this.customDecoder) {
	            return this.customDecoder(bytes, encodingName);
	        }
	        // Increases browser support.
	        if (typeof TextDecoder === 'undefined' || this.shouldDecodeOnFallback(encodingName)) {
	            return this.decodeFallback(bytes, encodingName);
	        }
	        return new TextDecoder(encodingName).decode(bytes);
	    };
	    /**
	     * Checks if the decoding method should use the fallback for decoding
	     * once Node TextDecoder doesn't support all encoding formats.
	     *
	     * @param encodingName
	     */
	    StringEncoding.shouldDecodeOnFallback = function (encodingName) {
	        return !StringEncoding.isBrowser() && encodingName === 'ISO-8859-1';
	    };
	    /**
	     * Encodes some string into a Uint8Array.
	     */
	    StringEncoding.encode = function (s, encoding) {
	        var encodingName = this.encodingName(encoding);
	        if (this.customEncoder) {
	            return this.customEncoder(s, encodingName);
	        }
	        // Increases browser support.
	        if (typeof TextEncoder === 'undefined') {
	            return this.encodeFallback(s);
	        }
	        // TextEncoder only encodes to UTF8 by default as specified by encoding.spec.whatwg.org
	        return new TextEncoder().encode(s);
	    };
	    StringEncoding.isBrowser = function () {
	        return (typeof window !== 'undefined' && {}.toString.call(window) === '[object Window]');
	    };
	    /**
	     * Returns the string value from some encoding character set.
	     */
	    StringEncoding.encodingName = function (encoding) {
	        return typeof encoding === 'string'
	            ? encoding
	            : encoding.getName();
	    };
	    /**
	     * Returns character set from some encoding character set.
	     */
	    StringEncoding.encodingCharacterSet = function (encoding) {
	        if (encoding instanceof CharacterSetECI_1$2.default) {
	            return encoding;
	        }
	        return CharacterSetECI_1$2.default.getCharacterSetECIByName(encoding);
	    };
	    /**
	     * Runs a fallback for the native decoding funcion.
	     */
	    StringEncoding.decodeFallback = function (bytes, encoding) {
	        var characterSet = this.encodingCharacterSet(encoding);
	        if (StringEncoding.isDecodeFallbackSupported(characterSet)) {
	            var s = '';
	            for (var i = 0, length_1 = bytes.length; i < length_1; i++) {
	                var h = bytes[i].toString(16);
	                if (h.length < 2) {
	                    h = '0' + h;
	                }
	                s += '%' + h;
	            }
	            return decodeURIComponent(s);
	        }
	        if (characterSet.equals(CharacterSetECI_1$2.default.UnicodeBigUnmarked)) {
	            return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
	        }
	        throw new UnsupportedOperationException_1$1.default("Encoding " + this.encodingName(encoding) + " not supported by fallback.");
	    };
	    StringEncoding.isDecodeFallbackSupported = function (characterSet) {
	        return characterSet.equals(CharacterSetECI_1$2.default.UTF8) ||
	            characterSet.equals(CharacterSetECI_1$2.default.ISO8859_1) ||
	            characterSet.equals(CharacterSetECI_1$2.default.ASCII);
	    };
	    /**
	     * Runs a fallback for the native encoding funcion.
	     *
	     * @see https://stackoverflow.com/a/17192845/4367683
	     */
	    StringEncoding.encodeFallback = function (s) {
	        var encodedURIstring = btoa(unescape(encodeURIComponent(s)));
	        var charList = encodedURIstring.split('');
	        var uintArray = [];
	        for (var i = 0; i < charList.length; i++) {
	            uintArray.push(charList[i].charCodeAt(0));
	        }
	        return new Uint8Array(uintArray);
	    };
	    return StringEncoding;
	}());
	StringEncoding$1.default = StringEncoding;

	/*
	 * Copyright (C) 2010 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(StringUtils$1, "__esModule", { value: true });
	/*namespace com.google.zxing.common {*/
	/*import java.nio.charset.Charset;*/
	/*import java.util.Map;*/
	var DecodeHintType_1$3 = DecodeHintType$1;
	var CharacterSetECI_1$1 = CharacterSetECI;
	var StringEncoding_1$1 = StringEncoding$1;
	/**
	 * Common string-related functions.
	 *
	 * @author Sean Owen
	 * @author Alex Dupre
	 */
	var StringUtils = /** @class */ (function () {
	    function StringUtils() {
	    }
	    // SHIFT_JIS.equalsIgnoreCase(PLATFORM_DEFAULT_ENCODING) ||
	    // EUC_JP.equalsIgnoreCase(PLATFORM_DEFAULT_ENCODING);
	    StringUtils.castAsNonUtf8Char = function (code, encoding) {
	        if (encoding === void 0) { encoding = null; }
	        // ISO 8859-1 is the Java default as UTF-8 is JavaScripts
	        // you can see this method as a Java version of String.fromCharCode
	        var e = encoding ? encoding.getName() : this.ISO88591;
	        // use passed format (fromCharCode will return UTF8 encoding)
	        return StringEncoding_1$1.default.decode(new Uint8Array([code]), e);
	    };
	    /**
	     * @param bytes bytes encoding a string, whose encoding should be guessed
	     * @param hints decode hints if applicable
	     * @return name of guessed encoding; at the moment will only guess one of:
	     *  {@link #SHIFT_JIS}, {@link #UTF8}, {@link #ISO88591}, or the platform
	     *  default encoding if none of these can possibly be correct
	     */
	    StringUtils.guessEncoding = function (bytes, hints) {
	        if (hints !== null && hints !== undefined && undefined !== hints.get(DecodeHintType_1$3.default.CHARACTER_SET)) {
	            return hints.get(DecodeHintType_1$3.default.CHARACTER_SET).toString();
	        }
	        // For now, merely tries to distinguish ISO-8859-1, UTF-8 and Shift_JIS,
	        // which should be by far the most common encodings.
	        var length = bytes.length;
	        var canBeISO88591 = true;
	        var canBeShiftJIS = true;
	        var canBeUTF8 = true;
	        var utf8BytesLeft = 0;
	        // int utf8LowChars = 0
	        var utf2BytesChars = 0;
	        var utf3BytesChars = 0;
	        var utf4BytesChars = 0;
	        var sjisBytesLeft = 0;
	        // int sjisLowChars = 0
	        var sjisKatakanaChars = 0;
	        // int sjisDoubleBytesChars = 0
	        var sjisCurKatakanaWordLength = 0;
	        var sjisCurDoubleBytesWordLength = 0;
	        var sjisMaxKatakanaWordLength = 0;
	        var sjisMaxDoubleBytesWordLength = 0;
	        // int isoLowChars = 0
	        // int isoHighChars = 0
	        var isoHighOther = 0;
	        var utf8bom = bytes.length > 3 &&
	            bytes[0] === /*(byte) */ 0xEF &&
	            bytes[1] === /*(byte) */ 0xBB &&
	            bytes[2] === /*(byte) */ 0xBF;
	        for (var i = 0; i < length && (canBeISO88591 || canBeShiftJIS || canBeUTF8); i++) {
	            var value = bytes[i] & 0xFF;
	            // UTF-8 stuff
	            if (canBeUTF8) {
	                if (utf8BytesLeft > 0) {
	                    if ((value & 0x80) === 0) {
	                        canBeUTF8 = false;
	                    }
	                    else {
	                        utf8BytesLeft--;
	                    }
	                }
	                else if ((value & 0x80) !== 0) {
	                    if ((value & 0x40) === 0) {
	                        canBeUTF8 = false;
	                    }
	                    else {
	                        utf8BytesLeft++;
	                        if ((value & 0x20) === 0) {
	                            utf2BytesChars++;
	                        }
	                        else {
	                            utf8BytesLeft++;
	                            if ((value & 0x10) === 0) {
	                                utf3BytesChars++;
	                            }
	                            else {
	                                utf8BytesLeft++;
	                                if ((value & 0x08) === 0) {
	                                    utf4BytesChars++;
	                                }
	                                else {
	                                    canBeUTF8 = false;
	                                }
	                            }
	                        }
	                    }
	                } // else {
	                // utf8LowChars++
	                // }
	            }
	            // ISO-8859-1 stuff
	            if (canBeISO88591) {
	                if (value > 0x7F && value < 0xA0) {
	                    canBeISO88591 = false;
	                }
	                else if (value > 0x9F) {
	                    if (value < 0xC0 || value === 0xD7 || value === 0xF7) {
	                        isoHighOther++;
	                    } // else {
	                    // isoHighChars++
	                    // }
	                } // else {
	                // isoLowChars++
	                // }
	            }
	            // Shift_JIS stuff
	            if (canBeShiftJIS) {
	                if (sjisBytesLeft > 0) {
	                    if (value < 0x40 || value === 0x7F || value > 0xFC) {
	                        canBeShiftJIS = false;
	                    }
	                    else {
	                        sjisBytesLeft--;
	                    }
	                }
	                else if (value === 0x80 || value === 0xA0 || value > 0xEF) {
	                    canBeShiftJIS = false;
	                }
	                else if (value > 0xA0 && value < 0xE0) {
	                    sjisKatakanaChars++;
	                    sjisCurDoubleBytesWordLength = 0;
	                    sjisCurKatakanaWordLength++;
	                    if (sjisCurKatakanaWordLength > sjisMaxKatakanaWordLength) {
	                        sjisMaxKatakanaWordLength = sjisCurKatakanaWordLength;
	                    }
	                }
	                else if (value > 0x7F) {
	                    sjisBytesLeft++;
	                    // sjisDoubleBytesChars++
	                    sjisCurKatakanaWordLength = 0;
	                    sjisCurDoubleBytesWordLength++;
	                    if (sjisCurDoubleBytesWordLength > sjisMaxDoubleBytesWordLength) {
	                        sjisMaxDoubleBytesWordLength = sjisCurDoubleBytesWordLength;
	                    }
	                }
	                else {
	                    // sjisLowChars++
	                    sjisCurKatakanaWordLength = 0;
	                    sjisCurDoubleBytesWordLength = 0;
	                }
	            }
	        }
	        if (canBeUTF8 && utf8BytesLeft > 0) {
	            canBeUTF8 = false;
	        }
	        if (canBeShiftJIS && sjisBytesLeft > 0) {
	            canBeShiftJIS = false;
	        }
	        // Easy -- if there is BOM or at least 1 valid not-single byte character (and no evidence it can't be UTF-8), done
	        if (canBeUTF8 && (utf8bom || utf2BytesChars + utf3BytesChars + utf4BytesChars > 0)) {
	            return StringUtils.UTF8;
	        }
	        // Easy -- if assuming Shift_JIS or at least 3 valid consecutive not-ascii characters (and no evidence it can't be), done
	        if (canBeShiftJIS && (StringUtils.ASSUME_SHIFT_JIS || sjisMaxKatakanaWordLength >= 3 || sjisMaxDoubleBytesWordLength >= 3)) {
	            return StringUtils.SHIFT_JIS;
	        }
	        // Distinguishing Shift_JIS and ISO-8859-1 can be a little tough for short words. The crude heuristic is:
	        // - If we saw
	        //   - only two consecutive katakana chars in the whole text, or
	        //   - at least 10% of bytes that could be "upper" not-alphanumeric Latin1,
	        // - then we conclude Shift_JIS, else ISO-8859-1
	        if (canBeISO88591 && canBeShiftJIS) {
	            return (sjisMaxKatakanaWordLength === 2 && sjisKatakanaChars === 2) || isoHighOther * 10 >= length
	                ? StringUtils.SHIFT_JIS : StringUtils.ISO88591;
	        }
	        // Otherwise, try in order ISO-8859-1, Shift JIS, UTF-8 and fall back to default platform encoding
	        if (canBeISO88591) {
	            return StringUtils.ISO88591;
	        }
	        if (canBeShiftJIS) {
	            return StringUtils.SHIFT_JIS;
	        }
	        if (canBeUTF8) {
	            return StringUtils.UTF8;
	        }
	        // Otherwise, we take a wild guess with platform encoding
	        return StringUtils.PLATFORM_DEFAULT_ENCODING;
	    };
	    /**
	     *
	     * @see https://stackoverflow.com/a/13439711/4367683
	     *
	     * @param append The new string to append.
	     * @param args Argumets values to be formated.
	     */
	    StringUtils.format = function (append) {
	        var args = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            args[_i - 1] = arguments[_i];
	        }
	        var i = -1;
	        function callback(exp, p0, p1, p2, p3, p4) {
	            if (exp === '%%')
	                return '%';
	            if (args[++i] === undefined)
	                return undefined;
	            exp = p2 ? parseInt(p2.substr(1)) : undefined;
	            var base = p3 ? parseInt(p3.substr(1)) : undefined;
	            var val;
	            switch (p4) {
	                case 's':
	                    val = args[i];
	                    break;
	                case 'c':
	                    val = args[i][0];
	                    break;
	                case 'f':
	                    val = parseFloat(args[i]).toFixed(exp);
	                    break;
	                case 'p':
	                    val = parseFloat(args[i]).toPrecision(exp);
	                    break;
	                case 'e':
	                    val = parseFloat(args[i]).toExponential(exp);
	                    break;
	                case 'x':
	                    val = parseInt(args[i]).toString(base ? base : 16);
	                    break;
	                case 'd':
	                    val = parseFloat(parseInt(args[i], base ? base : 10).toPrecision(exp)).toFixed(0);
	                    break;
	            }
	            val = typeof val === 'object' ? JSON.stringify(val) : (+val).toString(base);
	            var size = parseInt(p1); /* padding size */
	            var ch = p1 && (p1[0] + '') === '0' ? '0' : ' '; /* isnull? */
	            while (val.length < size)
	                val = p0 !== undefined ? val + ch : ch + val; /* isminus? */
	            return val;
	        }
	        var regex = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;
	        return append.replace(regex, callback);
	    };
	    /**
	     *
	     */
	    StringUtils.getBytes = function (str, encoding) {
	        return StringEncoding_1$1.default.encode(str, encoding);
	    };
	    /**
	     * Returns the charcode at the specified index or at index zero.
	     */
	    StringUtils.getCharCode = function (str, index) {
	        if (index === void 0) { index = 0; }
	        return str.charCodeAt(index);
	    };
	    /**
	     * Returns char for given charcode
	     */
	    StringUtils.getCharAt = function (charCode) {
	        return String.fromCharCode(charCode);
	    };
	    StringUtils.SHIFT_JIS = CharacterSetECI_1$1.default.SJIS.getName(); // "SJIS"
	    StringUtils.GB2312 = 'GB2312';
	    StringUtils.ISO88591 = CharacterSetECI_1$1.default.ISO8859_1.getName(); // "ISO8859_1"
	    StringUtils.EUC_JP = 'EUC_JP';
	    StringUtils.UTF8 = CharacterSetECI_1$1.default.UTF8.getName(); // "UTF8"
	    StringUtils.PLATFORM_DEFAULT_ENCODING = StringUtils.UTF8; // "UTF8"//Charset.defaultCharset().name()
	    StringUtils.ASSUME_SHIFT_JIS = false;
	    return StringUtils;
	}());
	StringUtils$1.default = StringUtils;

	Object.defineProperty(StringBuilder$1, "__esModule", { value: true });
	var StringUtils_1$1 = StringUtils$1;
	var StringBuilder = /** @class */ (function () {
	    function StringBuilder(value) {
	        if (value === void 0) { value = ''; }
	        this.value = value;
	    }
	    StringBuilder.prototype.enableDecoding = function (encoding) {
	        this.encoding = encoding;
	        return this;
	    };
	    StringBuilder.prototype.append = function (s) {
	        if (typeof s === 'string') {
	            this.value += s.toString();
	        }
	        else if (this.encoding) {
	            // use passed format (fromCharCode will return UTF8 encoding)
	            this.value += StringUtils_1$1.default.castAsNonUtf8Char(s, this.encoding);
	        }
	        else {
	            // correctly converts from UTF-8, but not other encodings
	            this.value += String.fromCharCode(s);
	        }
	        return this;
	    };
	    StringBuilder.prototype.appendChars = function (str, offset, len) {
	        for (var i = offset; offset < offset + len; i++) {
	            this.append(str[i]);
	        }
	        return this;
	    };
	    StringBuilder.prototype.length = function () {
	        return this.value.length;
	    };
	    StringBuilder.prototype.charAt = function (n) {
	        return this.value.charAt(n);
	    };
	    StringBuilder.prototype.deleteCharAt = function (n) {
	        this.value = this.value.substr(0, n) + this.value.substring(n + 1);
	    };
	    StringBuilder.prototype.setCharAt = function (n, c) {
	        this.value = this.value.substr(0, n) + c + this.value.substr(n + 1);
	    };
	    StringBuilder.prototype.substring = function (start, end) {
	        return this.value.substring(start, end);
	    };
	    /**
	     * @note helper method for RSS Expanded
	     */
	    StringBuilder.prototype.setLengthToZero = function () {
	        this.value = '';
	    };
	    StringBuilder.prototype.toString = function () {
	        return this.value;
	    };
	    StringBuilder.prototype.insert = function (n, c) {
	        this.value = this.value.substr(0, n) + c + this.value.substr(n + c.length);
	    };
	    return StringBuilder;
	}());
	StringBuilder$1.default = StringBuilder;

	/*
	 * Copyright 2007 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(BitMatrix$1, "__esModule", { value: true });
	/*namespace com.google.zxing.common {*/
	/*import java.util.Arrays;*/
	var BitArray_1$1 = BitArray$1;
	var System_1$3 = System$1;
	var Arrays_1 = Arrays$1;
	var StringBuilder_1$2 = StringBuilder$1;
	var IllegalArgumentException_1$7 = IllegalArgumentException$1;
	/**
	 * <p>Represents a 2D matrix of bits. In function arguments below, and throughout the common
	 * module, x is the column position, and y is the row position. The ordering is always x, y.
	 * The origin is at the top-left.</p>
	 *
	 * <p>Internally the bits are represented in a 1-D array of 32-bit ints. However, each row begins
	 * with a new int. This is done intentionally so that we can copy out a row into a BitArray very
	 * efficiently.</p>
	 *
	 * <p>The ordering of bits is row-major. Within each int, the least significant bits are used first,
	 * meaning they represent lower x values. This is compatible with BitArray's implementation.</p>
	 *
	 * @author Sean Owen
	 * @author dswitkin@google.com (Daniel Switkin)
	 */
	var BitMatrix /*implements Cloneable*/ = /** @class */ (function () {
	    /**
	     * Creates an empty square {@link BitMatrix}.
	     *
	     * @param dimension height and width
	     */
	    // public constructor(dimension: number /*int*/) {
	    //   this(dimension, dimension)
	    // }
	    /**
	     * Creates an empty {@link BitMatrix}.
	     *
	     * @param width bit matrix width
	     * @param height bit matrix height
	     */
	    // public constructor(width: number /*int*/, height: number /*int*/) {
	    //   if (width < 1 || height < 1) {
	    //     throw new IllegalArgumentException("Both dimensions must be greater than 0")
	    //   }
	    //   this.width = width
	    //   this.height = height
	    //   this.rowSize = (width + 31) / 32
	    //   bits = new int[rowSize * height];
	    // }
	    function BitMatrix(width /*int*/, height /*int*/, rowSize /*int*/, bits) {
	        this.width = width;
	        this.height = height;
	        this.rowSize = rowSize;
	        this.bits = bits;
	        if (undefined === height || null === height) {
	            height = width;
	        }
	        this.height = height;
	        if (width < 1 || height < 1) {
	            throw new IllegalArgumentException_1$7.default('Both dimensions must be greater than 0');
	        }
	        if (undefined === rowSize || null === rowSize) {
	            rowSize = Math.floor((width + 31) / 32);
	        }
	        this.rowSize = rowSize;
	        if (undefined === bits || null === bits) {
	            this.bits = new Int32Array(this.rowSize * this.height);
	        }
	    }
	    /**
	     * Interprets a 2D array of booleans as a {@link BitMatrix}, where "true" means an "on" bit.
	     *
	     * @function parse
	     * @param image bits of the image, as a row-major 2D array. Elements are arrays representing rows
	     * @return {@link BitMatrix} representation of image
	     */
	    BitMatrix.parseFromBooleanArray = function (image) {
	        var height = image.length;
	        var width = image[0].length;
	        var bits = new BitMatrix(width, height);
	        for (var i = 0; i < height; i++) {
	            var imageI = image[i];
	            for (var j = 0; j < width; j++) {
	                if (imageI[j]) {
	                    bits.set(j, i);
	                }
	            }
	        }
	        return bits;
	    };
	    /**
	     *
	     * @function parse
	     * @param stringRepresentation
	     * @param setString
	     * @param unsetString
	     */
	    BitMatrix.parseFromString = function (stringRepresentation, setString, unsetString) {
	        if (stringRepresentation === null) {
	            throw new IllegalArgumentException_1$7.default('stringRepresentation cannot be null');
	        }
	        var bits = new Array(stringRepresentation.length);
	        var bitsPos = 0;
	        var rowStartPos = 0;
	        var rowLength = -1;
	        var nRows = 0;
	        var pos = 0;
	        while (pos < stringRepresentation.length) {
	            if (stringRepresentation.charAt(pos) === '\n' ||
	                stringRepresentation.charAt(pos) === '\r') {
	                if (bitsPos > rowStartPos) {
	                    if (rowLength === -1) {
	                        rowLength = bitsPos - rowStartPos;
	                    }
	                    else if (bitsPos - rowStartPos !== rowLength) {
	                        throw new IllegalArgumentException_1$7.default('row lengths do not match');
	                    }
	                    rowStartPos = bitsPos;
	                    nRows++;
	                }
	                pos++;
	            }
	            else if (stringRepresentation.substring(pos, pos + setString.length) === setString) {
	                pos += setString.length;
	                bits[bitsPos] = true;
	                bitsPos++;
	            }
	            else if (stringRepresentation.substring(pos, pos + unsetString.length) === unsetString) {
	                pos += unsetString.length;
	                bits[bitsPos] = false;
	                bitsPos++;
	            }
	            else {
	                throw new IllegalArgumentException_1$7.default('illegal character encountered: ' + stringRepresentation.substring(pos));
	            }
	        }
	        // no EOL at end?
	        if (bitsPos > rowStartPos) {
	            if (rowLength === -1) {
	                rowLength = bitsPos - rowStartPos;
	            }
	            else if (bitsPos - rowStartPos !== rowLength) {
	                throw new IllegalArgumentException_1$7.default('row lengths do not match');
	            }
	            nRows++;
	        }
	        var matrix = new BitMatrix(rowLength, nRows);
	        for (var i = 0; i < bitsPos; i++) {
	            if (bits[i]) {
	                matrix.set(Math.floor(i % rowLength), Math.floor(i / rowLength));
	            }
	        }
	        return matrix;
	    };
	    /**
	     * <p>Gets the requested bit, where true means black.</p>
	     *
	     * @param x The horizontal component (i.e. which column)
	     * @param y The vertical component (i.e. which row)
	     * @return value of given bit in matrix
	     */
	    BitMatrix.prototype.get = function (x /*int*/, y /*int*/) {
	        var offset = y * this.rowSize + Math.floor(x / 32);
	        return ((this.bits[offset] >>> (x & 0x1f)) & 1) !== 0;
	    };
	    /**
	     * <p>Sets the given bit to true.</p>
	     *
	     * @param x The horizontal component (i.e. which column)
	     * @param y The vertical component (i.e. which row)
	     */
	    BitMatrix.prototype.set = function (x /*int*/, y /*int*/) {
	        var offset = y * this.rowSize + Math.floor(x / 32);
	        this.bits[offset] |= (1 << (x & 0x1f)) & 0xFFFFFFFF;
	    };
	    BitMatrix.prototype.unset = function (x /*int*/, y /*int*/) {
	        var offset = y * this.rowSize + Math.floor(x / 32);
	        this.bits[offset] &= ~((1 << (x & 0x1f)) & 0xFFFFFFFF);
	    };
	    /**
	     * <p>Flips the given bit.</p>
	     *
	     * @param x The horizontal component (i.e. which column)
	     * @param y The vertical component (i.e. which row)
	     */
	    BitMatrix.prototype.flip = function (x /*int*/, y /*int*/) {
	        var offset = y * this.rowSize + Math.floor(x / 32);
	        this.bits[offset] ^= ((1 << (x & 0x1f)) & 0xFFFFFFFF);
	    };
	    /**
	     * Exclusive-or (XOR): Flip the bit in this {@code BitMatrix} if the corresponding
	     * mask bit is set.
	     *
	     * @param mask XOR mask
	     */
	    BitMatrix.prototype.xor = function (mask) {
	        if (this.width !== mask.getWidth() || this.height !== mask.getHeight()
	            || this.rowSize !== mask.getRowSize()) {
	            throw new IllegalArgumentException_1$7.default('input matrix dimensions do not match');
	        }
	        var rowArray = new BitArray_1$1.default(Math.floor(this.width / 32) + 1);
	        var rowSize = this.rowSize;
	        var bits = this.bits;
	        for (var y = 0, height = this.height; y < height; y++) {
	            var offset = y * rowSize;
	            var row = mask.getRow(y, rowArray).getBitArray();
	            for (var x = 0; x < rowSize; x++) {
	                bits[offset + x] ^= row[x];
	            }
	        }
	    };
	    /**
	     * Clears all bits (sets to false).
	     */
	    BitMatrix.prototype.clear = function () {
	        var bits = this.bits;
	        var max = bits.length;
	        for (var i = 0; i < max; i++) {
	            bits[i] = 0;
	        }
	    };
	    /**
	     * <p>Sets a square region of the bit matrix to true.</p>
	     *
	     * @param left The horizontal position to begin at (inclusive)
	     * @param top The vertical position to begin at (inclusive)
	     * @param width The width of the region
	     * @param height The height of the region
	     */
	    BitMatrix.prototype.setRegion = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {
	        if (top < 0 || left < 0) {
	            throw new IllegalArgumentException_1$7.default('Left and top must be nonnegative');
	        }
	        if (height < 1 || width < 1) {
	            throw new IllegalArgumentException_1$7.default('Height and width must be at least 1');
	        }
	        var right = left + width;
	        var bottom = top + height;
	        if (bottom > this.height || right > this.width) {
	            throw new IllegalArgumentException_1$7.default('The region must fit inside the matrix');
	        }
	        var rowSize = this.rowSize;
	        var bits = this.bits;
	        for (var y = top; y < bottom; y++) {
	            var offset = y * rowSize;
	            for (var x = left; x < right; x++) {
	                bits[offset + Math.floor(x / 32)] |= ((1 << (x & 0x1f)) & 0xFFFFFFFF);
	            }
	        }
	    };
	    /**
	     * A fast method to retrieve one row of data from the matrix as a BitArray.
	     *
	     * @param y The row to retrieve
	     * @param row An optional caller-allocated BitArray, will be allocated if null or too small
	     * @return The resulting BitArray - this reference should always be used even when passing
	     *         your own row
	     */
	    BitMatrix.prototype.getRow = function (y /*int*/, row) {
	        if (row === null || row === undefined || row.getSize() < this.width) {
	            row = new BitArray_1$1.default(this.width);
	        }
	        else {
	            row.clear();
	        }
	        var rowSize = this.rowSize;
	        var bits = this.bits;
	        var offset = y * rowSize;
	        for (var x = 0; x < rowSize; x++) {
	            row.setBulk(x * 32, bits[offset + x]);
	        }
	        return row;
	    };
	    /**
	     * @param y row to set
	     * @param row {@link BitArray} to copy from
	     */
	    BitMatrix.prototype.setRow = function (y /*int*/, row) {
	        System_1$3.default.arraycopy(row.getBitArray(), 0, this.bits, y * this.rowSize, this.rowSize);
	    };
	    /**
	     * Modifies this {@code BitMatrix} to represent the same but rotated 180 degrees
	     */
	    BitMatrix.prototype.rotate180 = function () {
	        var width = this.getWidth();
	        var height = this.getHeight();
	        var topRow = new BitArray_1$1.default(width);
	        var bottomRow = new BitArray_1$1.default(width);
	        for (var i = 0, length_1 = Math.floor((height + 1) / 2); i < length_1; i++) {
	            topRow = this.getRow(i, topRow);
	            bottomRow = this.getRow(height - 1 - i, bottomRow);
	            topRow.reverse();
	            bottomRow.reverse();
	            this.setRow(i, bottomRow);
	            this.setRow(height - 1 - i, topRow);
	        }
	    };
	    /**
	     * This is useful in detecting the enclosing rectangle of a 'pure' barcode.
	     *
	     * @return {@code left,top,width,height} enclosing rectangle of all 1 bits, or null if it is all white
	     */
	    BitMatrix.prototype.getEnclosingRectangle = function () {
	        var width = this.width;
	        var height = this.height;
	        var rowSize = this.rowSize;
	        var bits = this.bits;
	        var left = width;
	        var top = height;
	        var right = -1;
	        var bottom = -1;
	        for (var y = 0; y < height; y++) {
	            for (var x32 = 0; x32 < rowSize; x32++) {
	                var theBits = bits[y * rowSize + x32];
	                if (theBits !== 0) {
	                    if (y < top) {
	                        top = y;
	                    }
	                    if (y > bottom) {
	                        bottom = y;
	                    }
	                    if (x32 * 32 < left) {
	                        var bit = 0;
	                        while (((theBits << (31 - bit)) & 0xFFFFFFFF) === 0) {
	                            bit++;
	                        }
	                        if ((x32 * 32 + bit) < left) {
	                            left = x32 * 32 + bit;
	                        }
	                    }
	                    if (x32 * 32 + 31 > right) {
	                        var bit = 31;
	                        while ((theBits >>> bit) === 0) {
	                            bit--;
	                        }
	                        if ((x32 * 32 + bit) > right) {
	                            right = x32 * 32 + bit;
	                        }
	                    }
	                }
	            }
	        }
	        if (right < left || bottom < top) {
	            return null;
	        }
	        return Int32Array.from([left, top, right - left + 1, bottom - top + 1]);
	    };
	    /**
	     * This is useful in detecting a corner of a 'pure' barcode.
	     *
	     * @return {@code x,y} coordinate of top-left-most 1 bit, or null if it is all white
	     */
	    BitMatrix.prototype.getTopLeftOnBit = function () {
	        var rowSize = this.rowSize;
	        var bits = this.bits;
	        var bitsOffset = 0;
	        while (bitsOffset < bits.length && bits[bitsOffset] === 0) {
	            bitsOffset++;
	        }
	        if (bitsOffset === bits.length) {
	            return null;
	        }
	        var y = bitsOffset / rowSize;
	        var x = (bitsOffset % rowSize) * 32;
	        var theBits = bits[bitsOffset];
	        var bit = 0;
	        while (((theBits << (31 - bit)) & 0xFFFFFFFF) === 0) {
	            bit++;
	        }
	        x += bit;
	        return Int32Array.from([x, y]);
	    };
	    BitMatrix.prototype.getBottomRightOnBit = function () {
	        var rowSize = this.rowSize;
	        var bits = this.bits;
	        var bitsOffset = bits.length - 1;
	        while (bitsOffset >= 0 && bits[bitsOffset] === 0) {
	            bitsOffset--;
	        }
	        if (bitsOffset < 0) {
	            return null;
	        }
	        var y = Math.floor(bitsOffset / rowSize);
	        var x = Math.floor(bitsOffset % rowSize) * 32;
	        var theBits = bits[bitsOffset];
	        var bit = 31;
	        while ((theBits >>> bit) === 0) {
	            bit--;
	        }
	        x += bit;
	        return Int32Array.from([x, y]);
	    };
	    /**
	     * @return The width of the matrix
	     */
	    BitMatrix.prototype.getWidth = function () {
	        return this.width;
	    };
	    /**
	     * @return The height of the matrix
	     */
	    BitMatrix.prototype.getHeight = function () {
	        return this.height;
	    };
	    /**
	     * @return The row size of the matrix
	     */
	    BitMatrix.prototype.getRowSize = function () {
	        return this.rowSize;
	    };
	    /*@Override*/
	    BitMatrix.prototype.equals = function (o) {
	        if (!(o instanceof BitMatrix)) {
	            return false;
	        }
	        var other = o;
	        return this.width === other.width && this.height === other.height && this.rowSize === other.rowSize &&
	            Arrays_1.default.equals(this.bits, other.bits);
	    };
	    /*@Override*/
	    BitMatrix.prototype.hashCode = function () {
	        var hash = this.width;
	        hash = 31 * hash + this.width;
	        hash = 31 * hash + this.height;
	        hash = 31 * hash + this.rowSize;
	        hash = 31 * hash + Arrays_1.default.hashCode(this.bits);
	        return hash;
	    };
	    /**
	     * @return string representation using "X" for set and " " for unset bits
	     */
	    /*@Override*/
	    // public toString(): string {
	    //   return toString(": "X, "  ")
	    // }
	    /**
	     * @param setString representation of a set bit
	     * @param unsetString representation of an unset bit
	     * @return string representation of entire matrix utilizing given strings
	     */
	    // public toString(setString: string = "X ", unsetString: string = "  "): string {
	    //   return this.buildToString(setString, unsetString, "\n")
	    // }
	    /**
	     * @param setString representation of a set bit
	     * @param unsetString representation of an unset bit
	     * @param lineSeparator newline character in string representation
	     * @return string representation of entire matrix utilizing given strings and line separator
	     * @deprecated call {@link #toString(String,String)} only, which uses \n line separator always
	     */
	    // @Deprecated
	    BitMatrix.prototype.toString = function (setString, unsetString, lineSeparator) {
	        if (setString === void 0) { setString = 'X '; }
	        if (unsetString === void 0) { unsetString = '  '; }
	        if (lineSeparator === void 0) { lineSeparator = '\n'; }
	        return this.buildToString(setString, unsetString, lineSeparator);
	    };
	    BitMatrix.prototype.buildToString = function (setString, unsetString, lineSeparator) {
	        var result = new StringBuilder_1$2.default();
	        // result.append(lineSeparator);
	        for (var y = 0, height = this.height; y < height; y++) {
	            for (var x = 0, width = this.width; x < width; x++) {
	                result.append(this.get(x, y) ? setString : unsetString);
	            }
	            result.append(lineSeparator);
	        }
	        return result.toString();
	    };
	    /*@Override*/
	    BitMatrix.prototype.clone = function () {
	        return new BitMatrix(this.width, this.height, this.rowSize, this.bits.slice());
	    };
	    return BitMatrix;
	}());
	BitMatrix$1.default = BitMatrix;

	var NotFoundException$1 = {};

	var __extends$d = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(NotFoundException$1, "__esModule", { value: true });
	var Exception_1$5 = Exception$1;
	/**
	 * Custom Error class of type Exception.
	 */
	var NotFoundException = /** @class */ (function (_super) {
	    __extends$d(NotFoundException, _super);
	    function NotFoundException() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    NotFoundException.getNotFoundInstance = function () {
	        return new NotFoundException();
	    };
	    NotFoundException.kind = 'NotFoundException';
	    return NotFoundException;
	}(Exception_1$5.default));
	NotFoundException$1.default = NotFoundException;

	/*
	 * Copyright 2009 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __extends$c = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(GlobalHistogramBinarizer$1, "__esModule", { value: true });
	/*namespace com.google.zxing.common {*/
	var Binarizer_1 = Binarizer$1;
	var BitArray_1 = BitArray$1;
	var BitMatrix_1$5 = BitMatrix$1;
	var NotFoundException_1$6 = NotFoundException$1;
	/**
	 * This Binarizer implementation uses the old ZXing global histogram approach. It is suitable
	 * for low-end mobile devices which don't have enough CPU or memory to use a local thresholding
	 * algorithm. However, because it picks a global black point, it cannot handle difficult shadows
	 * and gradients.
	 *
	 * Faster mobile devices and all desktop applications should probably use HybridBinarizer instead.
	 *
	 * @author dswitkin@google.com (Daniel Switkin)
	 * @author Sean Owen
	 */
	var GlobalHistogramBinarizer = /** @class */ (function (_super) {
	    __extends$c(GlobalHistogramBinarizer, _super);
	    function GlobalHistogramBinarizer(source) {
	        var _this = _super.call(this, source) || this;
	        _this.luminances = GlobalHistogramBinarizer.EMPTY;
	        _this.buckets = new Int32Array(GlobalHistogramBinarizer.LUMINANCE_BUCKETS);
	        return _this;
	    }
	    // Applies simple sharpening to the row data to improve performance of the 1D Readers.
	    /*@Override*/
	    GlobalHistogramBinarizer.prototype.getBlackRow = function (y /*int*/, row) {
	        var source = this.getLuminanceSource();
	        var width = source.getWidth();
	        if (row === undefined || row === null || row.getSize() < width) {
	            row = new BitArray_1.default(width);
	        }
	        else {
	            row.clear();
	        }
	        this.initArrays(width);
	        var localLuminances = source.getRow(y, this.luminances);
	        var localBuckets = this.buckets;
	        for (var x = 0; x < width; x++) {
	            localBuckets[(localLuminances[x] & 0xff) >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;
	        }
	        var blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);
	        if (width < 3) {
	            // Special case for very small images
	            for (var x = 0; x < width; x++) {
	                if ((localLuminances[x] & 0xff) < blackPoint) {
	                    row.set(x);
	                }
	            }
	        }
	        else {
	            var left = localLuminances[0] & 0xff;
	            var center = localLuminances[1] & 0xff;
	            for (var x = 1; x < width - 1; x++) {
	                var right = localLuminances[x + 1] & 0xff;
	                // A simple -1 4 -1 box filter with a weight of 2.
	                if (((center * 4) - left - right) / 2 < blackPoint) {
	                    row.set(x);
	                }
	                left = center;
	                center = right;
	            }
	        }
	        return row;
	    };
	    // Does not sharpen the data, as this call is intended to only be used by 2D Readers.
	    /*@Override*/
	    GlobalHistogramBinarizer.prototype.getBlackMatrix = function () {
	        var source = this.getLuminanceSource();
	        var width = source.getWidth();
	        var height = source.getHeight();
	        var matrix = new BitMatrix_1$5.default(width, height);
	        // Quickly calculates the histogram by sampling four rows from the image. This proved to be
	        // more robust on the blackbox tests than sampling a diagonal as we used to do.
	        this.initArrays(width);
	        var localBuckets = this.buckets;
	        for (var y = 1; y < 5; y++) {
	            var row = Math.floor((height * y) / 5);
	            var localLuminances_1 = source.getRow(row, this.luminances);
	            var right = Math.floor((width * 4) / 5);
	            for (var x = Math.floor(width / 5); x < right; x++) {
	                var pixel = localLuminances_1[x] & 0xff;
	                localBuckets[pixel >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;
	            }
	        }
	        var blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);
	        // We delay reading the entire image luminance until the black point estimation succeeds.
	        // Although we end up reading four rows twice, it is consistent with our motto of
	        // "fail quickly" which is necessary for continuous scanning.
	        var localLuminances = source.getMatrix();
	        for (var y = 0; y < height; y++) {
	            var offset = y * width;
	            for (var x = 0; x < width; x++) {
	                var pixel = localLuminances[offset + x] & 0xff;
	                if (pixel < blackPoint) {
	                    matrix.set(x, y);
	                }
	            }
	        }
	        return matrix;
	    };
	    /*@Override*/
	    GlobalHistogramBinarizer.prototype.createBinarizer = function (source) {
	        return new GlobalHistogramBinarizer(source);
	    };
	    GlobalHistogramBinarizer.prototype.initArrays = function (luminanceSize /*int*/) {
	        if (this.luminances.length < luminanceSize) {
	            this.luminances = new Uint8ClampedArray(luminanceSize);
	        }
	        var buckets = this.buckets;
	        for (var x = 0; x < GlobalHistogramBinarizer.LUMINANCE_BUCKETS; x++) {
	            buckets[x] = 0;
	        }
	    };
	    GlobalHistogramBinarizer.estimateBlackPoint = function (buckets) {
	        // Find the tallest peak in the histogram.
	        var numBuckets = buckets.length;
	        var maxBucketCount = 0;
	        var firstPeak = 0;
	        var firstPeakSize = 0;
	        for (var x = 0; x < numBuckets; x++) {
	            if (buckets[x] > firstPeakSize) {
	                firstPeak = x;
	                firstPeakSize = buckets[x];
	            }
	            if (buckets[x] > maxBucketCount) {
	                maxBucketCount = buckets[x];
	            }
	        }
	        // Find the second-tallest peak which is somewhat far from the tallest peak.
	        var secondPeak = 0;
	        var secondPeakScore = 0;
	        for (var x = 0; x < numBuckets; x++) {
	            var distanceToBiggest = x - firstPeak;
	            // Encourage more distant second peaks by multiplying by square of distance.
	            var score = buckets[x] * distanceToBiggest * distanceToBiggest;
	            if (score > secondPeakScore) {
	                secondPeak = x;
	                secondPeakScore = score;
	            }
	        }
	        // Make sure firstPeak corresponds to the black peak.
	        if (firstPeak > secondPeak) {
	            var temp = firstPeak;
	            firstPeak = secondPeak;
	            secondPeak = temp;
	        }
	        // If there is too little contrast in the image to pick a meaningful black point, throw rather
	        // than waste time trying to decode the image, and risk false positives.
	        if (secondPeak - firstPeak <= numBuckets / 16) {
	            throw new NotFoundException_1$6.default();
	        }
	        // Find a valley between them that is low and closer to the white peak.
	        var bestValley = secondPeak - 1;
	        var bestValleyScore = -1;
	        for (var x = secondPeak - 1; x > firstPeak; x--) {
	            var fromFirst = x - firstPeak;
	            var score = fromFirst * fromFirst * (secondPeak - x) * (maxBucketCount - buckets[x]);
	            if (score > bestValleyScore) {
	                bestValley = x;
	                bestValleyScore = score;
	            }
	        }
	        return bestValley << GlobalHistogramBinarizer.LUMINANCE_SHIFT;
	    };
	    GlobalHistogramBinarizer.LUMINANCE_BITS = 5;
	    GlobalHistogramBinarizer.LUMINANCE_SHIFT = 8 - GlobalHistogramBinarizer.LUMINANCE_BITS;
	    GlobalHistogramBinarizer.LUMINANCE_BUCKETS = 1 << GlobalHistogramBinarizer.LUMINANCE_BITS;
	    GlobalHistogramBinarizer.EMPTY = Uint8ClampedArray.from([0]);
	    return GlobalHistogramBinarizer;
	}(Binarizer_1.default));
	GlobalHistogramBinarizer$1.default = GlobalHistogramBinarizer;

	/*
	 * Copyright 2009 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __extends$b = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(HybridBinarizer$1, "__esModule", { value: true });
	var GlobalHistogramBinarizer_1 = GlobalHistogramBinarizer$1;
	var BitMatrix_1$4 = BitMatrix$1;
	/**
	 * This class implements a local thresholding algorithm, which while slower than the
	 * GlobalHistogramBinarizer, is fairly efficient for what it does. It is designed for
	 * high frequency images of barcodes with black data on white backgrounds. For this application,
	 * it does a much better job than a global blackpoint with severe shadows and gradients.
	 * However it tends to produce artifacts on lower frequency images and is therefore not
	 * a good general purpose binarizer for uses outside ZXing.
	 *
	 * This class extends GlobalHistogramBinarizer, using the older histogram approach for 1D readers,
	 * and the newer local approach for 2D readers. 1D decoding using a per-row histogram is already
	 * inherently local, and only fails for horizontal gradients. We can revisit that problem later,
	 * but for now it was not a win to use local blocks for 1D.
	 *
	 * This Binarizer is the default for the unit tests and the recommended class for library users.
	 *
	 * @author dswitkin@google.com (Daniel Switkin)
	 */
	var HybridBinarizer = /** @class */ (function (_super) {
	    __extends$b(HybridBinarizer, _super);
	    function HybridBinarizer(source) {
	        var _this = _super.call(this, source) || this;
	        _this.matrix = null;
	        return _this;
	    }
	    /**
	     * Calculates the final BitMatrix once for all requests. This could be called once from the
	     * constructor instead, but there are some advantages to doing it lazily, such as making
	     * profiling easier, and not doing heavy lifting when callers don't expect it.
	     */
	    /*@Override*/
	    HybridBinarizer.prototype.getBlackMatrix = function () {
	        if (this.matrix !== null) {
	            return this.matrix;
	        }
	        var source = this.getLuminanceSource();
	        var width = source.getWidth();
	        var height = source.getHeight();
	        if (width >= HybridBinarizer.MINIMUM_DIMENSION && height >= HybridBinarizer.MINIMUM_DIMENSION) {
	            var luminances = source.getMatrix();
	            var subWidth = width >> HybridBinarizer.BLOCK_SIZE_POWER;
	            if ((width & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {
	                subWidth++;
	            }
	            var subHeight = height >> HybridBinarizer.BLOCK_SIZE_POWER;
	            if ((height & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {
	                subHeight++;
	            }
	            var blackPoints = HybridBinarizer.calculateBlackPoints(luminances, subWidth, subHeight, width, height);
	            var newMatrix = new BitMatrix_1$4.default(width, height);
	            HybridBinarizer.calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, newMatrix);
	            this.matrix = newMatrix;
	        }
	        else {
	            // If the image is too small, fall back to the global histogram approach.
	            this.matrix = _super.prototype.getBlackMatrix.call(this);
	        }
	        return this.matrix;
	    };
	    /*@Override*/
	    HybridBinarizer.prototype.createBinarizer = function (source) {
	        return new HybridBinarizer(source);
	    };
	    /**
	     * For each block in the image, calculate the average black point using a 5x5 grid
	     * of the blocks around it. Also handles the corner cases (fractional blocks are computed based
	     * on the last pixels in the row/column which are also used in the previous block).
	     */
	    HybridBinarizer.calculateThresholdForBlock = function (luminances, subWidth /*int*/, subHeight /*int*/, width /*int*/, height /*int*/, blackPoints, matrix) {
	        var maxYOffset = height - HybridBinarizer.BLOCK_SIZE;
	        var maxXOffset = width - HybridBinarizer.BLOCK_SIZE;
	        for (var y = 0; y < subHeight; y++) {
	            var yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;
	            if (yoffset > maxYOffset) {
	                yoffset = maxYOffset;
	            }
	            var top_1 = HybridBinarizer.cap(y, 2, subHeight - 3);
	            for (var x = 0; x < subWidth; x++) {
	                var xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;
	                if (xoffset > maxXOffset) {
	                    xoffset = maxXOffset;
	                }
	                var left = HybridBinarizer.cap(x, 2, subWidth - 3);
	                var sum = 0;
	                for (var z = -2; z <= 2; z++) {
	                    var blackRow = blackPoints[top_1 + z];
	                    sum += blackRow[left - 2] + blackRow[left - 1] + blackRow[left] + blackRow[left + 1] + blackRow[left + 2];
	                }
	                var average = sum / 25;
	                HybridBinarizer.thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);
	            }
	        }
	    };
	    HybridBinarizer.cap = function (value /*int*/, min /*int*/, max /*int*/) {
	        return value < min ? min : value > max ? max : value;
	    };
	    /**
	     * Applies a single threshold to a block of pixels.
	     */
	    HybridBinarizer.thresholdBlock = function (luminances, xoffset /*int*/, yoffset /*int*/, threshold /*int*/, stride /*int*/, matrix) {
	        for (var y = 0, offset = yoffset * stride + xoffset; y < HybridBinarizer.BLOCK_SIZE; y++, offset += stride) {
	            for (var x = 0; x < HybridBinarizer.BLOCK_SIZE; x++) {
	                // Comparison needs to be <= so that black == 0 pixels are black even if the threshold is 0.
	                if ((luminances[offset + x] & 0xFF) <= threshold) {
	                    matrix.set(xoffset + x, yoffset + y);
	                }
	            }
	        }
	    };
	    /**
	     * Calculates a single black point for each block of pixels and saves it away.
	     * See the following thread for a discussion of this algorithm:
	     *  http://groups.google.com/group/zxing/browse_thread/thread/d06efa2c35a7ddc0
	     */
	    HybridBinarizer.calculateBlackPoints = function (luminances, subWidth /*int*/, subHeight /*int*/, width /*int*/, height /*int*/) {
	        var maxYOffset = height - HybridBinarizer.BLOCK_SIZE;
	        var maxXOffset = width - HybridBinarizer.BLOCK_SIZE;
	        // tslint:disable-next-line:whitespace
	        var blackPoints = new Array(subHeight); // subWidth
	        for (var y = 0; y < subHeight; y++) {
	            blackPoints[y] = new Int32Array(subWidth);
	            var yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;
	            if (yoffset > maxYOffset) {
	                yoffset = maxYOffset;
	            }
	            for (var x = 0; x < subWidth; x++) {
	                var xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;
	                if (xoffset > maxXOffset) {
	                    xoffset = maxXOffset;
	                }
	                var sum = 0;
	                var min = 0xFF;
	                var max = 0;
	                for (var yy = 0, offset = yoffset * width + xoffset; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {
	                    for (var xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {
	                        var pixel = luminances[offset + xx] & 0xFF;
	                        sum += pixel;
	                        // still looking for good contrast
	                        if (pixel < min) {
	                            min = pixel;
	                        }
	                        if (pixel > max) {
	                            max = pixel;
	                        }
	                    }
	                    // short-circuit min/max tests once dynamic range is met
	                    if (max - min > HybridBinarizer.MIN_DYNAMIC_RANGE) {
	                        // finish the rest of the rows quickly
	                        for (yy++, offset += width; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {
	                            for (var xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {
	                                sum += luminances[offset + xx] & 0xFF;
	                            }
	                        }
	                    }
	                }
	                // The default estimate is the average of the values in the block.
	                var average = sum >> (HybridBinarizer.BLOCK_SIZE_POWER * 2);
	                if (max - min <= HybridBinarizer.MIN_DYNAMIC_RANGE) {
	                    // If variation within the block is low, assume this is a block with only light or only
	                    // dark pixels. In that case we do not want to use the average, as it would divide this
	                    // low contrast area into black and white pixels, essentially creating data out of noise.
	                    //
	                    // The default assumption is that the block is light/background. Since no estimate for
	                    // the level of dark pixels exists locally, use half the min for the block.
	                    average = min / 2;
	                    if (y > 0 && x > 0) {
	                        // Correct the "white background" assumption for blocks that have neighbors by comparing
	                        // the pixels in this block to the previously calculated black points. This is based on
	                        // the fact that dark barcode symbology is always surrounded by some amount of light
	                        // background for which reasonable black point estimates were made. The bp estimated at
	                        // the boundaries is used for the interior.
	                        // The (min < bp) is arbitrary but works better than other heuristics that were tried.
	                        var averageNeighborBlackPoint = (blackPoints[y - 1][x] + (2 * blackPoints[y][x - 1]) + blackPoints[y - 1][x - 1]) / 4;
	                        if (min < averageNeighborBlackPoint) {
	                            average = averageNeighborBlackPoint;
	                        }
	                    }
	                }
	                blackPoints[y][x] = average;
	            }
	        }
	        return blackPoints;
	    };
	    // This class uses 5x5 blocks to compute local luminance, where each block is 8x8 pixels.
	    // So this is the smallest dimension in each axis we can accept.
	    HybridBinarizer.BLOCK_SIZE_POWER = 3;
	    HybridBinarizer.BLOCK_SIZE = 1 << HybridBinarizer.BLOCK_SIZE_POWER; // ...0100...00
	    HybridBinarizer.BLOCK_SIZE_MASK = HybridBinarizer.BLOCK_SIZE - 1; // ...0011...11
	    HybridBinarizer.MINIMUM_DIMENSION = HybridBinarizer.BLOCK_SIZE * 5;
	    HybridBinarizer.MIN_DYNAMIC_RANGE = 24;
	    return HybridBinarizer;
	}(GlobalHistogramBinarizer_1.default));
	var _default$2 = HybridBinarizer$1.default = HybridBinarizer;

	var RGBLuminanceSource$1 = {};

	var InvertedLuminanceSource$1 = {};

	var LuminanceSource$1 = {};

	/*
	 * Copyright 2009 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(LuminanceSource$1, "__esModule", { value: true });
	var StringBuilder_1$1 = StringBuilder$1;
	var UnsupportedOperationException_1 = UnsupportedOperationException$1;
	/*namespace com.google.zxing {*/
	/**
	 * The purpose of this class hierarchy is to abstract different bitmap implementations across
	 * platforms into a standard interface for requesting greyscale luminance values. The interface
	 * only provides immutable methods; therefore crop and rotation create copies. This is to ensure
	 * that one Reader does not modify the original luminance source and leave it in an unknown state
	 * for other Readers in the chain.
	 *
	 * @author dswitkin@google.com (Daniel Switkin)
	 */
	var LuminanceSource = /** @class */ (function () {
	    function LuminanceSource(width /*int*/, height /*int*/) {
	        this.width = width;
	        this.height = height;
	    }
	    /**
	     * @return The width of the bitmap.
	     */
	    LuminanceSource.prototype.getWidth = function () {
	        return this.width;
	    };
	    /**
	     * @return The height of the bitmap.
	     */
	    LuminanceSource.prototype.getHeight = function () {
	        return this.height;
	    };
	    /**
	     * @return Whether this subclass supports cropping.
	     */
	    LuminanceSource.prototype.isCropSupported = function () {
	        return false;
	    };
	    /**
	     * Returns a new object with cropped image data. Implementations may keep a reference to the
	     * original data rather than a copy. Only callable if isCropSupported() is true.
	     *
	     * @param left The left coordinate, which must be in [0,getWidth())
	     * @param top The top coordinate, which must be in [0,getHeight())
	     * @param width The width of the rectangle to crop.
	     * @param height The height of the rectangle to crop.
	     * @return A cropped version of this object.
	     */
	    LuminanceSource.prototype.crop = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {
	        throw new UnsupportedOperationException_1.default('This luminance source does not support cropping.');
	    };
	    /**
	     * @return Whether this subclass supports counter-clockwise rotation.
	     */
	    LuminanceSource.prototype.isRotateSupported = function () {
	        return false;
	    };
	    /**
	     * Returns a new object with rotated image data by 90 degrees counterclockwise.
	     * Only callable if {@link #isRotateSupported()} is true.
	     *
	     * @return A rotated version of this object.
	     */
	    LuminanceSource.prototype.rotateCounterClockwise = function () {
	        throw new UnsupportedOperationException_1.default('This luminance source does not support rotation by 90 degrees.');
	    };
	    /**
	     * Returns a new object with rotated image data by 45 degrees counterclockwise.
	     * Only callable if {@link #isRotateSupported()} is true.
	     *
	     * @return A rotated version of this object.
	     */
	    LuminanceSource.prototype.rotateCounterClockwise45 = function () {
	        throw new UnsupportedOperationException_1.default('This luminance source does not support rotation by 45 degrees.');
	    };
	    /*@Override*/
	    LuminanceSource.prototype.toString = function () {
	        var row = new Uint8ClampedArray(this.width);
	        var result = new StringBuilder_1$1.default();
	        for (var y = 0; y < this.height; y++) {
	            var sourceRow = this.getRow(y, row);
	            for (var x = 0; x < this.width; x++) {
	                var luminance = sourceRow[x] & 0xFF;
	                var c = void 0;
	                if (luminance < 0x40) {
	                    c = '#';
	                }
	                else if (luminance < 0x80) {
	                    c = '+';
	                }
	                else if (luminance < 0xC0) {
	                    c = '.';
	                }
	                else {
	                    c = ' ';
	                }
	                result.append(c);
	            }
	            result.append('\n');
	        }
	        return result.toString();
	    };
	    return LuminanceSource;
	}());
	LuminanceSource$1.default = LuminanceSource;

	/*
	 * Copyright 2009 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __extends$a = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(InvertedLuminanceSource$1, "__esModule", { value: true });
	var LuminanceSource_1$1 = LuminanceSource$1;
	/*namespace com.google.zxing {*/
	/**
	 * A wrapper implementation of {@link LuminanceSource} which inverts the luminances it returns -- black becomes
	 * white and vice versa, and each value becomes (255-value).
	 *
	 * @author Sean Owen
	 */
	var InvertedLuminanceSource = /** @class */ (function (_super) {
	    __extends$a(InvertedLuminanceSource, _super);
	    function InvertedLuminanceSource(delegate) {
	        var _this = _super.call(this, delegate.getWidth(), delegate.getHeight()) || this;
	        _this.delegate = delegate;
	        return _this;
	    }
	    /*@Override*/
	    InvertedLuminanceSource.prototype.getRow = function (y /*int*/, row) {
	        var sourceRow = this.delegate.getRow(y, row);
	        var width = this.getWidth();
	        for (var i = 0; i < width; i++) {
	            sourceRow[i] = /*(byte)*/ (255 - (sourceRow[i] & 0xFF));
	        }
	        return sourceRow;
	    };
	    /*@Override*/
	    InvertedLuminanceSource.prototype.getMatrix = function () {
	        var matrix = this.delegate.getMatrix();
	        var length = this.getWidth() * this.getHeight();
	        var invertedMatrix = new Uint8ClampedArray(length);
	        for (var i = 0; i < length; i++) {
	            invertedMatrix[i] = /*(byte)*/ (255 - (matrix[i] & 0xFF));
	        }
	        return invertedMatrix;
	    };
	    /*@Override*/
	    InvertedLuminanceSource.prototype.isCropSupported = function () {
	        return this.delegate.isCropSupported();
	    };
	    /*@Override*/
	    InvertedLuminanceSource.prototype.crop = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {
	        return new InvertedLuminanceSource(this.delegate.crop(left, top, width, height));
	    };
	    /*@Override*/
	    InvertedLuminanceSource.prototype.isRotateSupported = function () {
	        return this.delegate.isRotateSupported();
	    };
	    /**
	     * @return original delegate {@link LuminanceSource} since invert undoes itself
	     */
	    /*@Override*/
	    InvertedLuminanceSource.prototype.invert = function () {
	        return this.delegate;
	    };
	    /*@Override*/
	    InvertedLuminanceSource.prototype.rotateCounterClockwise = function () {
	        return new InvertedLuminanceSource(this.delegate.rotateCounterClockwise());
	    };
	    /*@Override*/
	    InvertedLuminanceSource.prototype.rotateCounterClockwise45 = function () {
	        return new InvertedLuminanceSource(this.delegate.rotateCounterClockwise45());
	    };
	    return InvertedLuminanceSource;
	}(LuminanceSource_1$1.default));
	InvertedLuminanceSource$1.default = InvertedLuminanceSource;

	/*
	 * Copyright 2009 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __extends$9 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(RGBLuminanceSource$1, "__esModule", { value: true });
	/*namespace com.google.zxing {*/
	 // required because of circular dependencies between LuminanceSource and InvertedLuminanceSource
	var InvertedLuminanceSource_1 = InvertedLuminanceSource$1;
	var LuminanceSource_1 = LuminanceSource$1;
	var System_1$2 = System$1;
	var IllegalArgumentException_1$6 = IllegalArgumentException$1;
	/**
	 * This class is used to help decode images from files which arrive as RGB data from
	 * an ARGB pixel array. It does not support rotation.
	 *
	 * @author dswitkin@google.com (Daniel Switkin)
	 * @author Betaminos
	 */
	var RGBLuminanceSource = /** @class */ (function (_super) {
	    __extends$9(RGBLuminanceSource, _super);
	    function RGBLuminanceSource(luminances, width /*int*/, height /*int*/, dataWidth /*int*/, dataHeight /*int*/, left /*int*/, top /*int*/) {
	        var _this = _super.call(this, width, height) || this;
	        _this.dataWidth = dataWidth;
	        _this.dataHeight = dataHeight;
	        _this.left = left;
	        _this.top = top;
	        if (luminances.BYTES_PER_ELEMENT === 4) { // Int32Array
	            var size = width * height;
	            var luminancesUint8Array = new Uint8ClampedArray(size);
	            for (var offset = 0; offset < size; offset++) {
	                var pixel = luminances[offset];
	                var r = (pixel >> 16) & 0xff; // red
	                var g2 = (pixel >> 7) & 0x1fe; // 2 * green
	                var b = pixel & 0xff; // blue
	                // Calculate green-favouring average cheaply
	                luminancesUint8Array[offset] = /*(byte) */ ((r + g2 + b) / 4) & 0xFF;
	            }
	            _this.luminances = luminancesUint8Array;
	        }
	        else {
	            _this.luminances = luminances;
	        }
	        if (undefined === dataWidth) {
	            _this.dataWidth = width;
	        }
	        if (undefined === dataHeight) {
	            _this.dataHeight = height;
	        }
	        if (undefined === left) {
	            _this.left = 0;
	        }
	        if (undefined === top) {
	            _this.top = 0;
	        }
	        if (_this.left + width > _this.dataWidth || _this.top + height > _this.dataHeight) {
	            throw new IllegalArgumentException_1$6.default('Crop rectangle does not fit within image data.');
	        }
	        return _this;
	    }
	    /*@Override*/
	    RGBLuminanceSource.prototype.getRow = function (y /*int*/, row) {
	        if (y < 0 || y >= this.getHeight()) {
	            throw new IllegalArgumentException_1$6.default('Requested row is outside the image: ' + y);
	        }
	        var width = this.getWidth();
	        if (row === null || row === undefined || row.length < width) {
	            row = new Uint8ClampedArray(width);
	        }
	        var offset = (y + this.top) * this.dataWidth + this.left;
	        System_1$2.default.arraycopy(this.luminances, offset, row, 0, width);
	        return row;
	    };
	    /*@Override*/
	    RGBLuminanceSource.prototype.getMatrix = function () {
	        var width = this.getWidth();
	        var height = this.getHeight();
	        // If the caller asks for the entire underlying image, save the copy and give them the
	        // original data. The docs specifically warn that result.length must be ignored.
	        if (width === this.dataWidth && height === this.dataHeight) {
	            return this.luminances;
	        }
	        var area = width * height;
	        var matrix = new Uint8ClampedArray(area);
	        var inputOffset = this.top * this.dataWidth + this.left;
	        // If the width matches the full width of the underlying data, perform a single copy.
	        if (width === this.dataWidth) {
	            System_1$2.default.arraycopy(this.luminances, inputOffset, matrix, 0, area);
	            return matrix;
	        }
	        // Otherwise copy one cropped row at a time.
	        for (var y = 0; y < height; y++) {
	            var outputOffset = y * width;
	            System_1$2.default.arraycopy(this.luminances, inputOffset, matrix, outputOffset, width);
	            inputOffset += this.dataWidth;
	        }
	        return matrix;
	    };
	    /*@Override*/
	    RGBLuminanceSource.prototype.isCropSupported = function () {
	        return true;
	    };
	    /*@Override*/
	    RGBLuminanceSource.prototype.crop = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {
	        return new RGBLuminanceSource(this.luminances, width, height, this.dataWidth, this.dataHeight, this.left + left, this.top + top);
	    };
	    RGBLuminanceSource.prototype.invert = function () {
	        return new InvertedLuminanceSource_1.default(this);
	    };
	    return RGBLuminanceSource;
	}(LuminanceSource_1.default));
	var _default$1 = RGBLuminanceSource$1.default = RGBLuminanceSource;

	var QRCodeReader$1 = {};

	var BarcodeFormat$1 = {};

	/*
	 * Direct port to TypeScript of ZXing by Adrian Toc
	 */
	Object.defineProperty(BarcodeFormat$1, "__esModule", { value: true });
	/*
	 * Copyright 2009 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/*namespace com.google.zxing {*/
	/**
	 * Enumerates barcode formats known to this package. Please keep alphabetized.
	 *
	 * @author Sean Owen
	 */
	var BarcodeFormat;
	(function (BarcodeFormat) {
	    /** Aztec 2D barcode format. */
	    BarcodeFormat[BarcodeFormat["AZTEC"] = 0] = "AZTEC";
	    /** CODABAR 1D format. */
	    BarcodeFormat[BarcodeFormat["CODABAR"] = 1] = "CODABAR";
	    /** Code 39 1D format. */
	    BarcodeFormat[BarcodeFormat["CODE_39"] = 2] = "CODE_39";
	    /** Code 93 1D format. */
	    BarcodeFormat[BarcodeFormat["CODE_93"] = 3] = "CODE_93";
	    /** Code 128 1D format. */
	    BarcodeFormat[BarcodeFormat["CODE_128"] = 4] = "CODE_128";
	    /** Data Matrix 2D barcode format. */
	    BarcodeFormat[BarcodeFormat["DATA_MATRIX"] = 5] = "DATA_MATRIX";
	    /** EAN-8 1D format. */
	    BarcodeFormat[BarcodeFormat["EAN_8"] = 6] = "EAN_8";
	    /** EAN-13 1D format. */
	    BarcodeFormat[BarcodeFormat["EAN_13"] = 7] = "EAN_13";
	    /** ITF (Interleaved Two of Five) 1D format. */
	    BarcodeFormat[BarcodeFormat["ITF"] = 8] = "ITF";
	    /** MaxiCode 2D barcode format. */
	    BarcodeFormat[BarcodeFormat["MAXICODE"] = 9] = "MAXICODE";
	    /** PDF417 format. */
	    BarcodeFormat[BarcodeFormat["PDF_417"] = 10] = "PDF_417";
	    /** QR Code 2D barcode format. */
	    BarcodeFormat[BarcodeFormat["QR_CODE"] = 11] = "QR_CODE";
	    /** RSS 14 */
	    BarcodeFormat[BarcodeFormat["RSS_14"] = 12] = "RSS_14";
	    /** RSS EXPANDED */
	    BarcodeFormat[BarcodeFormat["RSS_EXPANDED"] = 13] = "RSS_EXPANDED";
	    /** UPC-A 1D format. */
	    BarcodeFormat[BarcodeFormat["UPC_A"] = 14] = "UPC_A";
	    /** UPC-E 1D format. */
	    BarcodeFormat[BarcodeFormat["UPC_E"] = 15] = "UPC_E";
	    /** UPC/EAN extension format. Not a stand-alone format. */
	    BarcodeFormat[BarcodeFormat["UPC_EAN_EXTENSION"] = 16] = "UPC_EAN_EXTENSION";
	})(BarcodeFormat || (BarcodeFormat = {}));
	BarcodeFormat$1.default = BarcodeFormat;

	var Result$1 = {};

	/*
	 * Copyright 2007 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(Result$1, "__esModule", { value: true });
	var System_1$1 = System$1;
	/**
	 * <p>Encapsulates the result of decoding a barcode within an image.</p>
	 *
	 * @author Sean Owen
	 */
	var Result = /** @class */ (function () {
	    // public constructor(private text: string,
	    //               Uint8Array rawBytes,
	    //               ResultPoconst resultPoints: Int32Array,
	    //               BarcodeFormat format) {
	    //   this(text, rawBytes, resultPoints, format, System.currentTimeMillis())
	    // }
	    // public constructor(text: string,
	    //               Uint8Array rawBytes,
	    //               ResultPoconst resultPoints: Int32Array,
	    //               BarcodeFormat format,
	    //               long timestamp) {
	    //   this(text, rawBytes, rawBytes == null ? 0 : 8 * rawBytes.length,
	    //        resultPoints, format, timestamp)
	    // }
	    function Result(text, rawBytes, numBits, resultPoints, format, timestamp) {
	        if (numBits === void 0) { numBits = rawBytes == null ? 0 : 8 * rawBytes.length; }
	        if (timestamp === void 0) { timestamp = System_1$1.default.currentTimeMillis(); }
	        this.text = text;
	        this.rawBytes = rawBytes;
	        this.numBits = numBits;
	        this.resultPoints = resultPoints;
	        this.format = format;
	        this.timestamp = timestamp;
	        this.text = text;
	        this.rawBytes = rawBytes;
	        if (undefined === numBits || null === numBits) {
	            this.numBits = (rawBytes === null || rawBytes === undefined) ? 0 : 8 * rawBytes.length;
	        }
	        else {
	            this.numBits = numBits;
	        }
	        this.resultPoints = resultPoints;
	        this.format = format;
	        this.resultMetadata = null;
	        if (undefined === timestamp || null === timestamp) {
	            this.timestamp = System_1$1.default.currentTimeMillis();
	        }
	        else {
	            this.timestamp = timestamp;
	        }
	    }
	    /**
	     * @return raw text encoded by the barcode
	     */
	    Result.prototype.getText = function () {
	        return this.text;
	    };
	    /**
	     * @return raw bytes encoded by the barcode, if applicable, otherwise {@code null}
	     */
	    Result.prototype.getRawBytes = function () {
	        return this.rawBytes;
	    };
	    /**
	     * @return how many bits of {@link #getRawBytes()} are valid; typically 8 times its length
	     * @since 3.3.0
	     */
	    Result.prototype.getNumBits = function () {
	        return this.numBits;
	    };
	    /**
	     * @return points related to the barcode in the image. These are typically points
	     *         identifying finder patterns or the corners of the barcode. The exact meaning is
	     *         specific to the type of barcode that was decoded.
	     */
	    Result.prototype.getResultPoints = function () {
	        return this.resultPoints;
	    };
	    /**
	     * @return {@link BarcodeFormat} representing the format of the barcode that was decoded
	     */
	    Result.prototype.getBarcodeFormat = function () {
	        return this.format;
	    };
	    /**
	     * @return {@link Map} mapping {@link ResultMetadataType} keys to values. May be
	     *   {@code null}. This contains optional metadata about what was detected about the barcode,
	     *   like orientation.
	     */
	    Result.prototype.getResultMetadata = function () {
	        return this.resultMetadata;
	    };
	    Result.prototype.putMetadata = function (type, value) {
	        if (this.resultMetadata === null) {
	            this.resultMetadata = new Map();
	        }
	        this.resultMetadata.set(type, value);
	    };
	    Result.prototype.putAllMetadata = function (metadata) {
	        if (metadata !== null) {
	            if (this.resultMetadata === null) {
	                this.resultMetadata = metadata;
	            }
	            else {
	                this.resultMetadata = new Map(metadata);
	            }
	        }
	    };
	    Result.prototype.addResultPoints = function (newPoints) {
	        var oldPoints = this.resultPoints;
	        if (oldPoints === null) {
	            this.resultPoints = newPoints;
	        }
	        else if (newPoints !== null && newPoints.length > 0) {
	            var allPoints = new Array(oldPoints.length + newPoints.length);
	            System_1$1.default.arraycopy(oldPoints, 0, allPoints, 0, oldPoints.length);
	            System_1$1.default.arraycopy(newPoints, 0, allPoints, oldPoints.length, newPoints.length);
	            this.resultPoints = allPoints;
	        }
	    };
	    Result.prototype.getTimestamp = function () {
	        return this.timestamp;
	    };
	    /*@Override*/
	    Result.prototype.toString = function () {
	        return this.text;
	    };
	    return Result;
	}());
	Result$1.default = Result;

	var ResultMetadataType$1 = {};

	/*
	 * Copyright 2008 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(ResultMetadataType$1, "__esModule", { value: true });
	/*namespace com.google.zxing {*/
	/**
	 * Represents some type of metadata about the result of the decoding that the decoder
	 * wishes to communicate back to the caller.
	 *
	 * @author Sean Owen
	 */
	var ResultMetadataType;
	(function (ResultMetadataType) {
	    /**
	     * Unspecified, application-specific metadata. Maps to an unspecified {@link Object}.
	     */
	    ResultMetadataType[ResultMetadataType["OTHER"] = 0] = "OTHER";
	    /**
	     * Denotes the likely approximate orientation of the barcode in the image. This value
	     * is given as degrees rotated clockwise from the normal, upright orientation.
	     * For example a 1D barcode which was found by reading top-to-bottom would be
	     * said to have orientation "90". This key maps to an {@link Integer} whose
	     * value is in the range [0,360).
	     */
	    ResultMetadataType[ResultMetadataType["ORIENTATION"] = 1] = "ORIENTATION";
	    /**
	     * <p>2D barcode formats typically encode text, but allow for a sort of 'byte mode'
	     * which is sometimes used to encode binary data. While {@link Result} makes available
	     * the complete raw bytes in the barcode for these formats, it does not offer the bytes
	     * from the byte segments alone.</p>
	     *
	     * <p>This maps to a {@link java.util.List} of byte arrays corresponding to the
	     * raw bytes in the byte segments in the barcode, in order.</p>
	     */
	    ResultMetadataType[ResultMetadataType["BYTE_SEGMENTS"] = 2] = "BYTE_SEGMENTS";
	    /**
	     * Error correction level used, if applicable. The value type depends on the
	     * format, but is typically a String.
	     */
	    ResultMetadataType[ResultMetadataType["ERROR_CORRECTION_LEVEL"] = 3] = "ERROR_CORRECTION_LEVEL";
	    /**
	     * For some periodicals, indicates the issue number as an {@link Integer}.
	     */
	    ResultMetadataType[ResultMetadataType["ISSUE_NUMBER"] = 4] = "ISSUE_NUMBER";
	    /**
	     * For some products, indicates the suggested retail price in the barcode as a
	     * formatted {@link String}.
	     */
	    ResultMetadataType[ResultMetadataType["SUGGESTED_PRICE"] = 5] = "SUGGESTED_PRICE";
	    /**
	     * For some products, the possible country of manufacture as a {@link String} denoting the
	     * ISO country code. Some map to multiple possible countries, like "US/CA".
	     */
	    ResultMetadataType[ResultMetadataType["POSSIBLE_COUNTRY"] = 6] = "POSSIBLE_COUNTRY";
	    /**
	     * For some products, the extension text
	     */
	    ResultMetadataType[ResultMetadataType["UPC_EAN_EXTENSION"] = 7] = "UPC_EAN_EXTENSION";
	    /**
	     * PDF417-specific metadata
	     */
	    ResultMetadataType[ResultMetadataType["PDF417_EXTRA_METADATA"] = 8] = "PDF417_EXTRA_METADATA";
	    /**
	     * If the code format supports structured append and the current scanned code is part of one then the
	     * sequence number is given with it.
	     */
	    ResultMetadataType[ResultMetadataType["STRUCTURED_APPEND_SEQUENCE"] = 9] = "STRUCTURED_APPEND_SEQUENCE";
	    /**
	     * If the code format supports structured append and the current scanned code is part of one then the
	     * parity is given with it.
	     */
	    ResultMetadataType[ResultMetadataType["STRUCTURED_APPEND_PARITY"] = 10] = "STRUCTURED_APPEND_PARITY";
	})(ResultMetadataType || (ResultMetadataType = {}));
	ResultMetadataType$1.default = ResultMetadataType;

	var Decoder$1 = {};

	var ChecksumException$1 = {};

	var __extends$8 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(ChecksumException$1, "__esModule", { value: true });
	var Exception_1$4 = Exception$1;
	/**
	 * Custom Error class of type Exception.
	 */
	var ChecksumException = /** @class */ (function (_super) {
	    __extends$8(ChecksumException, _super);
	    function ChecksumException() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    ChecksumException.getChecksumInstance = function () {
	        return new ChecksumException();
	    };
	    ChecksumException.kind = 'ChecksumException';
	    return ChecksumException;
	}(Exception_1$4.default));
	ChecksumException$1.default = ChecksumException;

	var GenericGF$1 = {};

	var GenericGFPoly$1 = {};

	var AbstractGenericGF$1 = {};

	/*
	 * Copyright 2007 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(AbstractGenericGF$1, "__esModule", { value: true });
	var IllegalArgumentException_1$5 = IllegalArgumentException$1;
	/**
	 * <p>This class contains utility methods for performing mathematical operations over
	 * the Galois Fields. Operations use a given primitive polynomial in calculations.</p>
	 *
	 * <p>Throughout this package, elements of the GF are represented as an {@code int}
	 * for convenience and speed (but at the cost of memory).
	 * </p>
	 *
	 * @author Sean Owen
	 * @author David Olivier
	 */
	var AbstractGenericGF = /** @class */ (function () {
	    function AbstractGenericGF() {
	    }
	    /**
	     * @return 2 to the power of a in GF(size)
	     */
	    AbstractGenericGF.prototype.exp = function (a) {
	        return this.expTable[a];
	    };
	    /**
	     * @return base 2 log of a in GF(size)
	     */
	    AbstractGenericGF.prototype.log = function (a /*int*/) {
	        if (a === 0) {
	            throw new IllegalArgumentException_1$5.default();
	        }
	        return this.logTable[a];
	    };
	    /**
	     * Implements both addition and subtraction -- they are the same in GF(size).
	     *
	     * @return sum/difference of a and b
	     */
	    AbstractGenericGF.addOrSubtract = function (a /*int*/, b /*int*/) {
	        return a ^ b;
	    };
	    return AbstractGenericGF;
	}());
	AbstractGenericGF$1.default = AbstractGenericGF;

	/*
	 * Copyright 2007 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(GenericGFPoly$1, "__esModule", { value: true });
	/*namespace com.google.zxing.common.reedsolomon {*/
	var AbstractGenericGF_1$1 = AbstractGenericGF$1;
	var System_1 = System$1;
	var IllegalArgumentException_1$4 = IllegalArgumentException$1;
	/**
	 * <p>Represents a polynomial whose coefficients are elements of a GF.
	 * Instances of this class are immutable.</p>
	 *
	 * <p>Much credit is due to William Rucklidge since portions of this code are an indirect
	 * port of his C++ Reed-Solomon implementation.</p>
	 *
	 * @author Sean Owen
	 */
	var GenericGFPoly = /** @class */ (function () {
	    /**
	     * @param field the {@link GenericGF} instance representing the field to use
	     * to perform computations
	     * @param coefficients coefficients as ints representing elements of GF(size), arranged
	     * from most significant (highest-power term) coefficient to least significant
	     * @throws IllegalArgumentException if argument is null or empty,
	     * or if leading coefficient is 0 and this is not a
	     * constant polynomial (that is, it is not the monomial "0")
	     */
	    function GenericGFPoly(field, coefficients) {
	        if (coefficients.length === 0) {
	            throw new IllegalArgumentException_1$4.default();
	        }
	        this.field = field;
	        var coefficientsLength = coefficients.length;
	        if (coefficientsLength > 1 && coefficients[0] === 0) {
	            // Leading term must be non-zero for anything except the constant polynomial "0"
	            var firstNonZero = 1;
	            while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {
	                firstNonZero++;
	            }
	            if (firstNonZero === coefficientsLength) {
	                this.coefficients = Int32Array.from([0]);
	            }
	            else {
	                this.coefficients = new Int32Array(coefficientsLength - firstNonZero);
	                System_1.default.arraycopy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);
	            }
	        }
	        else {
	            this.coefficients = coefficients;
	        }
	    }
	    GenericGFPoly.prototype.getCoefficients = function () {
	        return this.coefficients;
	    };
	    /**
	     * @return degree of this polynomial
	     */
	    GenericGFPoly.prototype.getDegree = function () {
	        return this.coefficients.length - 1;
	    };
	    /**
	     * @return true iff this polynomial is the monomial "0"
	     */
	    GenericGFPoly.prototype.isZero = function () {
	        return this.coefficients[0] === 0;
	    };
	    /**
	     * @return coefficient of x^degree term in this polynomial
	     */
	    GenericGFPoly.prototype.getCoefficient = function (degree /*int*/) {
	        return this.coefficients[this.coefficients.length - 1 - degree];
	    };
	    /**
	     * @return evaluation of this polynomial at a given point
	     */
	    GenericGFPoly.prototype.evaluateAt = function (a /*int*/) {
	        if (a === 0) {
	            // Just return the x^0 coefficient
	            return this.getCoefficient(0);
	        }
	        var coefficients = this.coefficients;
	        var result;
	        if (a === 1) {
	            // Just the sum of the coefficients
	            result = 0;
	            for (var i = 0, length_1 = coefficients.length; i !== length_1; i++) {
	                var coefficient = coefficients[i];
	                result = AbstractGenericGF_1$1.default.addOrSubtract(result, coefficient);
	            }
	            return result;
	        }
	        result = coefficients[0];
	        var size = coefficients.length;
	        var field = this.field;
	        for (var i = 1; i < size; i++) {
	            result = AbstractGenericGF_1$1.default.addOrSubtract(field.multiply(a, result), coefficients[i]);
	        }
	        return result;
	    };
	    GenericGFPoly.prototype.addOrSubtract = function (other) {
	        if (!this.field.equals(other.field)) {
	            throw new IllegalArgumentException_1$4.default('GenericGFPolys do not have same GenericGF field');
	        }
	        if (this.isZero()) {
	            return other;
	        }
	        if (other.isZero()) {
	            return this;
	        }
	        var smallerCoefficients = this.coefficients;
	        var largerCoefficients = other.coefficients;
	        if (smallerCoefficients.length > largerCoefficients.length) {
	            var temp = smallerCoefficients;
	            smallerCoefficients = largerCoefficients;
	            largerCoefficients = temp;
	        }
	        var sumDiff = new Int32Array(largerCoefficients.length);
	        var lengthDiff = largerCoefficients.length - smallerCoefficients.length;
	        // Copy high-order terms only found in higher-degree polynomial's coefficients
	        System_1.default.arraycopy(largerCoefficients, 0, sumDiff, 0, lengthDiff);
	        for (var i = lengthDiff; i < largerCoefficients.length; i++) {
	            sumDiff[i] = AbstractGenericGF_1$1.default.addOrSubtract(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);
	        }
	        return new GenericGFPoly(this.field, sumDiff);
	    };
	    GenericGFPoly.prototype.multiply = function (other) {
	        if (!this.field.equals(other.field)) {
	            throw new IllegalArgumentException_1$4.default('GenericGFPolys do not have same GenericGF field');
	        }
	        if (this.isZero() || other.isZero()) {
	            return this.field.getZero();
	        }
	        var aCoefficients = this.coefficients;
	        var aLength = aCoefficients.length;
	        var bCoefficients = other.coefficients;
	        var bLength = bCoefficients.length;
	        var product = new Int32Array(aLength + bLength - 1);
	        var field = this.field;
	        for (var i = 0; i < aLength; i++) {
	            var aCoeff = aCoefficients[i];
	            for (var j = 0; j < bLength; j++) {
	                product[i + j] = AbstractGenericGF_1$1.default.addOrSubtract(product[i + j], field.multiply(aCoeff, bCoefficients[j]));
	            }
	        }
	        return new GenericGFPoly(field, product);
	    };
	    GenericGFPoly.prototype.multiplyScalar = function (scalar /*int*/) {
	        if (scalar === 0) {
	            return this.field.getZero();
	        }
	        if (scalar === 1) {
	            return this;
	        }
	        var size = this.coefficients.length;
	        var field = this.field;
	        var product = new Int32Array(size);
	        var coefficients = this.coefficients;
	        for (var i = 0; i < size; i++) {
	            product[i] = field.multiply(coefficients[i], scalar);
	        }
	        return new GenericGFPoly(field, product);
	    };
	    GenericGFPoly.prototype.multiplyByMonomial = function (degree /*int*/, coefficient /*int*/) {
	        if (degree < 0) {
	            throw new IllegalArgumentException_1$4.default();
	        }
	        if (coefficient === 0) {
	            return this.field.getZero();
	        }
	        var coefficients = this.coefficients;
	        var size = coefficients.length;
	        var product = new Int32Array(size + degree);
	        var field = this.field;
	        for (var i = 0; i < size; i++) {
	            product[i] = field.multiply(coefficients[i], coefficient);
	        }
	        return new GenericGFPoly(field, product);
	    };
	    GenericGFPoly.prototype.divide = function (other) {
	        if (!this.field.equals(other.field)) {
	            throw new IllegalArgumentException_1$4.default('GenericGFPolys do not have same GenericGF field');
	        }
	        if (other.isZero()) {
	            throw new IllegalArgumentException_1$4.default('Divide by 0');
	        }
	        var field = this.field;
	        var quotient = field.getZero();
	        var remainder = this;
	        var denominatorLeadingTerm = other.getCoefficient(other.getDegree());
	        var inverseDenominatorLeadingTerm = field.inverse(denominatorLeadingTerm);
	        while (remainder.getDegree() >= other.getDegree() && !remainder.isZero()) {
	            var degreeDifference = remainder.getDegree() - other.getDegree();
	            var scale = field.multiply(remainder.getCoefficient(remainder.getDegree()), inverseDenominatorLeadingTerm);
	            var term = other.multiplyByMonomial(degreeDifference, scale);
	            var iterationQuotient = field.buildMonomial(degreeDifference, scale);
	            quotient = quotient.addOrSubtract(iterationQuotient);
	            remainder = remainder.addOrSubtract(term);
	        }
	        return [quotient, remainder];
	    };
	    /*@Override*/
	    GenericGFPoly.prototype.toString = function () {
	        var result = '';
	        for (var degree = this.getDegree(); degree >= 0; degree--) {
	            var coefficient = this.getCoefficient(degree);
	            if (coefficient !== 0) {
	                if (coefficient < 0) {
	                    result += ' - ';
	                    coefficient = -coefficient;
	                }
	                else {
	                    if (result.length > 0) {
	                        result += ' + ';
	                    }
	                }
	                if (degree === 0 || coefficient !== 1) {
	                    var alphaPower = this.field.log(coefficient);
	                    if (alphaPower === 0) {
	                        result += '1';
	                    }
	                    else if (alphaPower === 1) {
	                        result += 'a';
	                    }
	                    else {
	                        result += 'a^';
	                        result += alphaPower;
	                    }
	                }
	                if (degree !== 0) {
	                    if (degree === 1) {
	                        result += 'x';
	                    }
	                    else {
	                        result += 'x^';
	                        result += degree;
	                    }
	                }
	            }
	        }
	        return result;
	    };
	    return GenericGFPoly;
	}());
	GenericGFPoly$1.default = GenericGFPoly;

	var ArithmeticException$1 = {};

	var __extends$7 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(ArithmeticException$1, "__esModule", { value: true });
	var Exception_1$3 = Exception$1;
	/**
	 * Custom Error class of type Exception.
	 */
	var ArithmeticException = /** @class */ (function (_super) {
	    __extends$7(ArithmeticException, _super);
	    function ArithmeticException() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    ArithmeticException.kind = 'ArithmeticException';
	    return ArithmeticException;
	}(Exception_1$3.default));
	ArithmeticException$1.default = ArithmeticException;

	/*
	 * Copyright 2007 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __extends$6 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(GenericGF$1, "__esModule", { value: true });
	/*namespace com.google.zxing.common.reedsolomon {*/
	var GenericGFPoly_1$1 = GenericGFPoly$1;
	var AbstractGenericGF_1 = AbstractGenericGF$1;
	var Integer_1$1 = Integer$1;
	var IllegalArgumentException_1$3 = IllegalArgumentException$1;
	var ArithmeticException_1 = ArithmeticException$1;
	/**
	 * <p>This class contains utility methods for performing mathematical operations over
	 * the Galois Fields. Operations use a given primitive polynomial in calculations.</p>
	 *
	 * <p>Throughout this package, elements of the GF are represented as an {@code int}
	 * for convenience and speed (but at the cost of memory).
	 * </p>
	 *
	 * @author Sean Owen
	 * @author David Olivier
	 */
	var GenericGF = /** @class */ (function (_super) {
	    __extends$6(GenericGF, _super);
	    /**
	     * Create a representation of GF(size) using the given primitive polynomial.
	     *
	     * @param primitive irreducible polynomial whose coefficients are represented by
	     *  the bits of an int, where the least-significant bit represents the constant
	     *  coefficient
	     * @param size the size of the field
	     * @param b the factor b in the generator polynomial can be 0- or 1-based
	     *  (g(x) = (x+a^b)(x+a^(b+1))...(x+a^(b+2t-1))).
	     *  In most cases it should be 1, but for QR code it is 0.
	     */
	    function GenericGF(primitive /*int*/, size /*int*/, generatorBase /*int*/) {
	        var _this = _super.call(this) || this;
	        _this.primitive = primitive;
	        _this.size = size;
	        _this.generatorBase = generatorBase;
	        var expTable = new Int32Array(size);
	        var x = 1;
	        for (var i = 0; i < size; i++) {
	            expTable[i] = x;
	            x *= 2; // we're assuming the generator alpha is 2
	            if (x >= size) {
	                x ^= primitive;
	                x &= size - 1;
	            }
	        }
	        _this.expTable = expTable;
	        var logTable = new Int32Array(size);
	        for (var i = 0; i < size - 1; i++) {
	            logTable[expTable[i]] = i;
	        }
	        _this.logTable = logTable;
	        // logTable[0] == 0 but this should never be used
	        _this.zero = new GenericGFPoly_1$1.default(_this, Int32Array.from([0]));
	        _this.one = new GenericGFPoly_1$1.default(_this, Int32Array.from([1]));
	        return _this;
	    }
	    GenericGF.prototype.getZero = function () {
	        return this.zero;
	    };
	    GenericGF.prototype.getOne = function () {
	        return this.one;
	    };
	    /**
	     * @return the monomial representing coefficient * x^degree
	     */
	    GenericGF.prototype.buildMonomial = function (degree /*int*/, coefficient /*int*/) {
	        if (degree < 0) {
	            throw new IllegalArgumentException_1$3.default();
	        }
	        if (coefficient === 0) {
	            return this.zero;
	        }
	        var coefficients = new Int32Array(degree + 1);
	        coefficients[0] = coefficient;
	        return new GenericGFPoly_1$1.default(this, coefficients);
	    };
	    /**
	     * @return multiplicative inverse of a
	     */
	    GenericGF.prototype.inverse = function (a /*int*/) {
	        if (a === 0) {
	            throw new ArithmeticException_1.default();
	        }
	        return this.expTable[this.size - this.logTable[a] - 1];
	    };
	    /**
	     * @return product of a and b in GF(size)
	     */
	    GenericGF.prototype.multiply = function (a /*int*/, b /*int*/) {
	        if (a === 0 || b === 0) {
	            return 0;
	        }
	        return this.expTable[(this.logTable[a] + this.logTable[b]) % (this.size - 1)];
	    };
	    GenericGF.prototype.getSize = function () {
	        return this.size;
	    };
	    GenericGF.prototype.getGeneratorBase = function () {
	        return this.generatorBase;
	    };
	    /*@Override*/
	    GenericGF.prototype.toString = function () {
	        return ('GF(0x' + Integer_1$1.default.toHexString(this.primitive) + ',' + this.size + ')');
	    };
	    GenericGF.prototype.equals = function (o) {
	        return o === this;
	    };
	    GenericGF.AZTEC_DATA_12 = new GenericGF(0x1069, 4096, 1); // x^12 + x^6 + x^5 + x^3 + 1
	    GenericGF.AZTEC_DATA_10 = new GenericGF(0x409, 1024, 1); // x^10 + x^3 + 1
	    GenericGF.AZTEC_DATA_6 = new GenericGF(0x43, 64, 1); // x^6 + x + 1
	    GenericGF.AZTEC_PARAM = new GenericGF(0x13, 16, 1); // x^4 + x + 1
	    GenericGF.QR_CODE_FIELD_256 = new GenericGF(0x011d, 256, 0); // x^8 + x^4 + x^3 + x^2 + 1
	    GenericGF.DATA_MATRIX_FIELD_256 = new GenericGF(0x012d, 256, 1); // x^8 + x^5 + x^3 + x^2 + 1
	    GenericGF.AZTEC_DATA_8 = GenericGF.DATA_MATRIX_FIELD_256;
	    GenericGF.MAXICODE_FIELD_64 = GenericGF.AZTEC_DATA_6;
	    return GenericGF;
	}(AbstractGenericGF_1.default));
	GenericGF$1.default = GenericGF;

	var ReedSolomonDecoder$1 = {};

	var ReedSolomonException$1 = {};

	var __extends$5 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(ReedSolomonException$1, "__esModule", { value: true });
	var Exception_1$2 = Exception$1;
	/**
	 * Custom Error class of type Exception.
	 */
	var ReedSolomonException = /** @class */ (function (_super) {
	    __extends$5(ReedSolomonException, _super);
	    function ReedSolomonException() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    ReedSolomonException.kind = 'ReedSolomonException';
	    return ReedSolomonException;
	}(Exception_1$2.default));
	ReedSolomonException$1.default = ReedSolomonException;

	var IllegalStateException$1 = {};

	var __extends$4 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(IllegalStateException$1, "__esModule", { value: true });
	var Exception_1$1 = Exception$1;
	/**
	 * Custom Error class of type Exception.
	 */
	var IllegalStateException = /** @class */ (function (_super) {
	    __extends$4(IllegalStateException, _super);
	    function IllegalStateException() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    IllegalStateException.kind = 'IllegalStateException';
	    return IllegalStateException;
	}(Exception_1$1.default));
	IllegalStateException$1.default = IllegalStateException;

	/*
	 * Copyright 2007 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(ReedSolomonDecoder$1, "__esModule", { value: true });
	/*namespace com.google.zxing.common.reedsolomon {*/
	var GenericGF_1$1 = GenericGF$1;
	var GenericGFPoly_1 = GenericGFPoly$1;
	var ReedSolomonException_1 = ReedSolomonException$1;
	var IllegalStateException_1 = IllegalStateException$1;
	/**
	 * <p>Implements Reed-Solomon decoding, as the name implies.</p>
	 *
	 * <p>The algorithm will not be explained here, but the following references were helpful
	 * in creating this implementation:</p>
	 *
	 * <ul>
	 * <li>Bruce Maggs.
	 * <a href="http://www.cs.cmu.edu/afs/cs.cmu.edu/project/pscico-guyb/realworld/www/rs_decode.ps">
	 * "Decoding Reed-Solomon Codes"</a> (see discussion of Forney's Formula)</li>
	 * <li>J.I. Hall. <a href="www.mth.msu.edu/~jhall/classes/codenotes/GRS.pdf">
	 * "Chapter 5. Generalized Reed-Solomon Codes"</a>
	 * (see discussion of Euclidean algorithm)</li>
	 * </ul>
	 *
	 * <p>Much credit is due to William Rucklidge since portions of this code are an indirect
	 * port of his C++ Reed-Solomon implementation.</p>
	 *
	 * @author Sean Owen
	 * @author William Rucklidge
	 * @author sanfordsquires
	 */
	var ReedSolomonDecoder = /** @class */ (function () {
	    function ReedSolomonDecoder(field) {
	        this.field = field;
	    }
	    /**
	     * <p>Decodes given set of received codewords, which include both data and error-correction
	     * codewords. Really, this means it uses Reed-Solomon to detect and correct errors, in-place,
	     * in the input.</p>
	     *
	     * @param received data and error-correction codewords
	     * @param twoS number of error-correction codewords available
	     * @throws ReedSolomonException if decoding fails for any reason
	     */
	    ReedSolomonDecoder.prototype.decode = function (received, twoS /*int*/) {
	        var field = this.field;
	        var poly = new GenericGFPoly_1.default(field, received);
	        var syndromeCoefficients = new Int32Array(twoS);
	        var noError = true;
	        for (var i = 0; i < twoS; i++) {
	            var evalResult = poly.evaluateAt(field.exp(i + field.getGeneratorBase()));
	            syndromeCoefficients[syndromeCoefficients.length - 1 - i] = evalResult;
	            if (evalResult !== 0) {
	                noError = false;
	            }
	        }
	        if (noError) {
	            return;
	        }
	        var syndrome = new GenericGFPoly_1.default(field, syndromeCoefficients);
	        var sigmaOmega = this.runEuclideanAlgorithm(field.buildMonomial(twoS, 1), syndrome, twoS);
	        var sigma = sigmaOmega[0];
	        var omega = sigmaOmega[1];
	        var errorLocations = this.findErrorLocations(sigma);
	        var errorMagnitudes = this.findErrorMagnitudes(omega, errorLocations);
	        for (var i = 0; i < errorLocations.length; i++) {
	            var position = received.length - 1 - field.log(errorLocations[i]);
	            if (position < 0) {
	                throw new ReedSolomonException_1.default('Bad error location');
	            }
	            received[position] = GenericGF_1$1.default.addOrSubtract(received[position], errorMagnitudes[i]);
	        }
	    };
	    ReedSolomonDecoder.prototype.runEuclideanAlgorithm = function (a, b, R /*int*/) {
	        // Assume a's degree is >= b's
	        if (a.getDegree() < b.getDegree()) {
	            var temp = a;
	            a = b;
	            b = temp;
	        }
	        var field = this.field;
	        var rLast = a;
	        var r = b;
	        var tLast = field.getZero();
	        var t = field.getOne();
	        // Run Euclidean algorithm until r's degree is less than R/2
	        while (r.getDegree() >= (R / 2 | 0)) {
	            var rLastLast = rLast;
	            var tLastLast = tLast;
	            rLast = r;
	            tLast = t;
	            // Divide rLastLast by rLast, with quotient in q and remainder in r
	            if (rLast.isZero()) {
	                // Oops, Euclidean algorithm already terminated?
	                throw new ReedSolomonException_1.default('r_{i-1} was zero');
	            }
	            r = rLastLast;
	            var q = field.getZero();
	            var denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());
	            var dltInverse = field.inverse(denominatorLeadingTerm);
	            while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {
	                var degreeDiff = r.getDegree() - rLast.getDegree();
	                var scale = field.multiply(r.getCoefficient(r.getDegree()), dltInverse);
	                q = q.addOrSubtract(field.buildMonomial(degreeDiff, scale));
	                r = r.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale));
	            }
	            t = q.multiply(tLast).addOrSubtract(tLastLast);
	            if (r.getDegree() >= rLast.getDegree()) {
	                throw new IllegalStateException_1.default('Division algorithm failed to reduce polynomial?');
	            }
	        }
	        var sigmaTildeAtZero = t.getCoefficient(0);
	        if (sigmaTildeAtZero === 0) {
	            throw new ReedSolomonException_1.default('sigmaTilde(0) was zero');
	        }
	        var inverse = field.inverse(sigmaTildeAtZero);
	        var sigma = t.multiplyScalar(inverse);
	        var omega = r.multiplyScalar(inverse);
	        return [sigma, omega];
	    };
	    ReedSolomonDecoder.prototype.findErrorLocations = function (errorLocator) {
	        // This is a direct application of Chien's search
	        var numErrors = errorLocator.getDegree();
	        if (numErrors === 1) { // shortcut
	            return Int32Array.from([errorLocator.getCoefficient(1)]);
	        }
	        var result = new Int32Array(numErrors);
	        var e = 0;
	        var field = this.field;
	        for (var i = 1; i < field.getSize() && e < numErrors; i++) {
	            if (errorLocator.evaluateAt(i) === 0) {
	                result[e] = field.inverse(i);
	                e++;
	            }
	        }
	        if (e !== numErrors) {
	            throw new ReedSolomonException_1.default('Error locator degree does not match number of roots');
	        }
	        return result;
	    };
	    ReedSolomonDecoder.prototype.findErrorMagnitudes = function (errorEvaluator, errorLocations) {
	        // This is directly applying Forney's Formula
	        var s = errorLocations.length;
	        var result = new Int32Array(s);
	        var field = this.field;
	        for (var i = 0; i < s; i++) {
	            var xiInverse = field.inverse(errorLocations[i]);
	            var denominator = 1;
	            for (var j = 0; j < s; j++) {
	                if (i !== j) {
	                    // denominator = field.multiply(denominator,
	                    //    GenericGF.addOrSubtract(1, field.multiply(errorLocations[j], xiInverse)))
	                    // Above should work but fails on some Apple and Linux JDKs due to a Hotspot bug.
	                    // Below is a funny-looking workaround from Steven Parkes
	                    var term = field.multiply(errorLocations[j], xiInverse);
	                    var termPlus1 = (term & 0x1) === 0 ? term | 1 : term & ~1;
	                    denominator = field.multiply(denominator, termPlus1);
	                }
	            }
	            result[i] = field.multiply(errorEvaluator.evaluateAt(xiInverse), field.inverse(denominator));
	            if (field.getGeneratorBase() !== 0) {
	                result[i] = field.multiply(result[i], xiInverse);
	            }
	        }
	        return result;
	    };
	    return ReedSolomonDecoder;
	}());
	ReedSolomonDecoder$1.default = ReedSolomonDecoder;

	var BitMatrixParser$1 = {};

	var Version$1 = {};

	var FormatInformation$1 = {};

	var ErrorCorrectionLevel = {};

	var ArgumentException$1 = {};

	var __extends$3 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(ArgumentException$1, "__esModule", { value: true });
	var Exception_1 = Exception$1;
	/**
	 * Custom Error class of type Exception.
	 */
	var ArgumentException = /** @class */ (function (_super) {
	    __extends$3(ArgumentException, _super);
	    function ArgumentException() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    ArgumentException.kind = 'ArgumentException';
	    return ArgumentException;
	}(Exception_1.default));
	ArgumentException$1.default = ArgumentException;

	(function (exports) {
	/*
	 * Copyright 2007 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ErrorCorrectionLevelValues = void 0;
	/*namespace com.google.zxing.qrcode.decoder {*/
	var ArgumentException_1 = ArgumentException$1;
	var IllegalArgumentException_1 = IllegalArgumentException$1;
	var ErrorCorrectionLevelValues;
	(function (ErrorCorrectionLevelValues) {
	    ErrorCorrectionLevelValues[ErrorCorrectionLevelValues["L"] = 0] = "L";
	    ErrorCorrectionLevelValues[ErrorCorrectionLevelValues["M"] = 1] = "M";
	    ErrorCorrectionLevelValues[ErrorCorrectionLevelValues["Q"] = 2] = "Q";
	    ErrorCorrectionLevelValues[ErrorCorrectionLevelValues["H"] = 3] = "H";
	})(ErrorCorrectionLevelValues = exports.ErrorCorrectionLevelValues || (exports.ErrorCorrectionLevelValues = {}));
	/**
	 * <p>See ISO 18004:2006, 6.5.1. This enum encapsulates the four error correction levels
	 * defined by the QR code standard.</p>
	 *
	 * @author Sean Owen
	 */
	var ErrorCorrectionLevel = /** @class */ (function () {
	    function ErrorCorrectionLevel(value, stringValue, bits /*int*/) {
	        this.value = value;
	        this.stringValue = stringValue;
	        this.bits = bits;
	        ErrorCorrectionLevel.FOR_BITS.set(bits, this);
	        ErrorCorrectionLevel.FOR_VALUE.set(value, this);
	    }
	    ErrorCorrectionLevel.prototype.getValue = function () {
	        return this.value;
	    };
	    ErrorCorrectionLevel.prototype.getBits = function () {
	        return this.bits;
	    };
	    ErrorCorrectionLevel.fromString = function (s) {
	        switch (s) {
	            case 'L': return ErrorCorrectionLevel.L;
	            case 'M': return ErrorCorrectionLevel.M;
	            case 'Q': return ErrorCorrectionLevel.Q;
	            case 'H': return ErrorCorrectionLevel.H;
	            default: throw new ArgumentException_1.default(s + 'not available');
	        }
	    };
	    ErrorCorrectionLevel.prototype.toString = function () {
	        return this.stringValue;
	    };
	    ErrorCorrectionLevel.prototype.equals = function (o) {
	        if (!(o instanceof ErrorCorrectionLevel)) {
	            return false;
	        }
	        var other = o;
	        return this.value === other.value;
	    };
	    /**
	     * @param bits int containing the two bits encoding a QR Code's error correction level
	     * @return ErrorCorrectionLevel representing the encoded error correction level
	     */
	    ErrorCorrectionLevel.forBits = function (bits /*int*/) {
	        if (bits < 0 || bits >= ErrorCorrectionLevel.FOR_BITS.size) {
	            throw new IllegalArgumentException_1.default();
	        }
	        return ErrorCorrectionLevel.FOR_BITS.get(bits);
	    };
	    ErrorCorrectionLevel.FOR_BITS = new Map();
	    ErrorCorrectionLevel.FOR_VALUE = new Map();
	    /** L = ~7% correction */
	    ErrorCorrectionLevel.L = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.L, 'L', 0x01);
	    /** M = ~15% correction */
	    ErrorCorrectionLevel.M = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.M, 'M', 0x00);
	    /** Q = ~25% correction */
	    ErrorCorrectionLevel.Q = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.Q, 'Q', 0x03);
	    /** H = ~30% correction */
	    ErrorCorrectionLevel.H = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.H, 'H', 0x02);
	    return ErrorCorrectionLevel;
	}());
	exports.default = ErrorCorrectionLevel;

	}(ErrorCorrectionLevel));

	/*
	 * Copyright 2007 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __values$6 = (commonjsGlobal && commonjsGlobal.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(FormatInformation$1, "__esModule", { value: true });
	/*namespace com.google.zxing.qrcode.decoder {*/
	var ErrorCorrectionLevel_1 = ErrorCorrectionLevel;
	var Integer_1 = Integer$1;
	/**
	 * <p>Encapsulates a QR Code's format information, including the data mask used and
	 * error correction level.</p>
	 *
	 * @author Sean Owen
	 * @see DataMask
	 * @see ErrorCorrectionLevel
	 */
	var FormatInformation = /** @class */ (function () {
	    function FormatInformation(formatInfo /*int*/) {
	        // Bits 3,4
	        this.errorCorrectionLevel = ErrorCorrectionLevel_1.default.forBits((formatInfo >> 3) & 0x03);
	        // Bottom 3 bits
	        this.dataMask = /*(byte) */ (formatInfo & 0x07);
	    }
	    FormatInformation.numBitsDiffering = function (a /*int*/, b /*int*/) {
	        return Integer_1.default.bitCount(a ^ b);
	    };
	    /**
	     * @param maskedFormatInfo1 format info indicator, with mask still applied
	     * @param maskedFormatInfo2 second copy of same info; both are checked at the same time
	     *  to establish best match
	     * @return information about the format it specifies, or {@code null}
	     *  if doesn't seem to match any known pattern
	     */
	    FormatInformation.decodeFormatInformation = function (maskedFormatInfo1 /*int*/, maskedFormatInfo2 /*int*/) {
	        var formatInfo = FormatInformation.doDecodeFormatInformation(maskedFormatInfo1, maskedFormatInfo2);
	        if (formatInfo !== null) {
	            return formatInfo;
	        }
	        // Should return null, but, some QR codes apparently
	        // do not mask this info. Try again by actually masking the pattern
	        // first
	        return FormatInformation.doDecodeFormatInformation(maskedFormatInfo1 ^ FormatInformation.FORMAT_INFO_MASK_QR, maskedFormatInfo2 ^ FormatInformation.FORMAT_INFO_MASK_QR);
	    };
	    FormatInformation.doDecodeFormatInformation = function (maskedFormatInfo1 /*int*/, maskedFormatInfo2 /*int*/) {
	        var e_1, _a;
	        // Find the int in FORMAT_INFO_DECODE_LOOKUP with fewest bits differing
	        var bestDifference = Number.MAX_SAFE_INTEGER;
	        var bestFormatInfo = 0;
	        try {
	            for (var _b = __values$6(FormatInformation.FORMAT_INFO_DECODE_LOOKUP), _c = _b.next(); !_c.done; _c = _b.next()) {
	                var decodeInfo = _c.value;
	                var targetInfo = decodeInfo[0];
	                if (targetInfo === maskedFormatInfo1 || targetInfo === maskedFormatInfo2) {
	                    // Found an exact match
	                    return new FormatInformation(decodeInfo[1]);
	                }
	                var bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo1, targetInfo);
	                if (bitsDifference < bestDifference) {
	                    bestFormatInfo = decodeInfo[1];
	                    bestDifference = bitsDifference;
	                }
	                if (maskedFormatInfo1 !== maskedFormatInfo2) {
	                    // also try the other option
	                    bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo2, targetInfo);
	                    if (bitsDifference < bestDifference) {
	                        bestFormatInfo = decodeInfo[1];
	                        bestDifference = bitsDifference;
	                    }
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        // Hamming distance of the 32 masked codes is 7, by construction, so <= 3 bits
	        // differing means we found a match
	        if (bestDifference <= 3) {
	            return new FormatInformation(bestFormatInfo);
	        }
	        return null;
	    };
	    FormatInformation.prototype.getErrorCorrectionLevel = function () {
	        return this.errorCorrectionLevel;
	    };
	    FormatInformation.prototype.getDataMask = function () {
	        return this.dataMask;
	    };
	    /*@Override*/
	    FormatInformation.prototype.hashCode = function () {
	        return (this.errorCorrectionLevel.getBits() << 3) | this.dataMask;
	    };
	    /*@Override*/
	    FormatInformation.prototype.equals = function (o) {
	        if (!(o instanceof FormatInformation)) {
	            return false;
	        }
	        var other = o;
	        return this.errorCorrectionLevel === other.errorCorrectionLevel &&
	            this.dataMask === other.dataMask;
	    };
	    FormatInformation.FORMAT_INFO_MASK_QR = 0x5412;
	    /**
	     * See ISO 18004:2006, Annex C, Table C.1
	     */
	    FormatInformation.FORMAT_INFO_DECODE_LOOKUP = [
	        Int32Array.from([0x5412, 0x00]),
	        Int32Array.from([0x5125, 0x01]),
	        Int32Array.from([0x5E7C, 0x02]),
	        Int32Array.from([0x5B4B, 0x03]),
	        Int32Array.from([0x45F9, 0x04]),
	        Int32Array.from([0x40CE, 0x05]),
	        Int32Array.from([0x4F97, 0x06]),
	        Int32Array.from([0x4AA0, 0x07]),
	        Int32Array.from([0x77C4, 0x08]),
	        Int32Array.from([0x72F3, 0x09]),
	        Int32Array.from([0x7DAA, 0x0A]),
	        Int32Array.from([0x789D, 0x0B]),
	        Int32Array.from([0x662F, 0x0C]),
	        Int32Array.from([0x6318, 0x0D]),
	        Int32Array.from([0x6C41, 0x0E]),
	        Int32Array.from([0x6976, 0x0F]),
	        Int32Array.from([0x1689, 0x10]),
	        Int32Array.from([0x13BE, 0x11]),
	        Int32Array.from([0x1CE7, 0x12]),
	        Int32Array.from([0x19D0, 0x13]),
	        Int32Array.from([0x0762, 0x14]),
	        Int32Array.from([0x0255, 0x15]),
	        Int32Array.from([0x0D0C, 0x16]),
	        Int32Array.from([0x083B, 0x17]),
	        Int32Array.from([0x355F, 0x18]),
	        Int32Array.from([0x3068, 0x19]),
	        Int32Array.from([0x3F31, 0x1A]),
	        Int32Array.from([0x3A06, 0x1B]),
	        Int32Array.from([0x24B4, 0x1C]),
	        Int32Array.from([0x2183, 0x1D]),
	        Int32Array.from([0x2EDA, 0x1E]),
	        Int32Array.from([0x2BED, 0x1F]),
	    ];
	    return FormatInformation;
	}());
	FormatInformation$1.default = FormatInformation;

	var ECBlocks$1 = {};

	var __values$5 = (commonjsGlobal && commonjsGlobal.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(ECBlocks$1, "__esModule", { value: true });
	/**
	 * <p>Encapsulates a set of error-correction blocks in one symbol version. Most versions will
	 * use blocks of differing sizes within one version, so, this encapsulates the parameters for
	 * each set of blocks. It also holds the number of error-correction codewords per block since it
	 * will be the same across all blocks within one version.</p>
	 */
	var ECBlocks = /** @class */ (function () {
	    function ECBlocks(ecCodewordsPerBlock /*int*/) {
	        var ecBlocks = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            ecBlocks[_i - 1] = arguments[_i];
	        }
	        this.ecCodewordsPerBlock = ecCodewordsPerBlock;
	        this.ecBlocks = ecBlocks;
	    }
	    ECBlocks.prototype.getECCodewordsPerBlock = function () {
	        return this.ecCodewordsPerBlock;
	    };
	    ECBlocks.prototype.getNumBlocks = function () {
	        var e_1, _a;
	        var total = 0;
	        var ecBlocks = this.ecBlocks;
	        try {
	            for (var ecBlocks_1 = __values$5(ecBlocks), ecBlocks_1_1 = ecBlocks_1.next(); !ecBlocks_1_1.done; ecBlocks_1_1 = ecBlocks_1.next()) {
	                var ecBlock = ecBlocks_1_1.value;
	                total += ecBlock.getCount();
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (ecBlocks_1_1 && !ecBlocks_1_1.done && (_a = ecBlocks_1.return)) _a.call(ecBlocks_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        return total;
	    };
	    ECBlocks.prototype.getTotalECCodewords = function () {
	        return this.ecCodewordsPerBlock * this.getNumBlocks();
	    };
	    ECBlocks.prototype.getECBlocks = function () {
	        return this.ecBlocks;
	    };
	    return ECBlocks;
	}());
	ECBlocks$1.default = ECBlocks;

	var ECB$1 = {};

	Object.defineProperty(ECB$1, "__esModule", { value: true });
	/**
	 * <p>Encapsulates the parameters for one error-correction block in one symbol version.
	 * This includes the number of data codewords, and the number of times a block with these
	 * parameters is used consecutively in the QR code version's format.</p>
	 */
	var ECB = /** @class */ (function () {
	    function ECB(count /*int*/, dataCodewords /*int*/) {
	        this.count = count;
	        this.dataCodewords = dataCodewords;
	    }
	    ECB.prototype.getCount = function () {
	        return this.count;
	    };
	    ECB.prototype.getDataCodewords = function () {
	        return this.dataCodewords;
	    };
	    return ECB;
	}());
	ECB$1.default = ECB;

	/*
	 * Copyright 2007 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __values$4 = (commonjsGlobal && commonjsGlobal.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(Version$1, "__esModule", { value: true });
	/*namespace com.google.zxing.qrcode.decoder {*/
	var BitMatrix_1$3 = BitMatrix$1;
	var FormatInformation_1$1 = FormatInformation$1;
	var ECBlocks_1 = ECBlocks$1;
	var ECB_1 = ECB$1;
	var FormatException_1$2 = FormatException$1;
	var IllegalArgumentException_1$2 = IllegalArgumentException$1;
	/**
	 * See ISO 18004:2006 Annex D
	 *
	 * @author Sean Owen
	 */
	var Version = /** @class */ (function () {
	    function Version(versionNumber /*int*/, alignmentPatternCenters) {
	        var e_1, _a;
	        var ecBlocks = [];
	        for (var _i = 2; _i < arguments.length; _i++) {
	            ecBlocks[_i - 2] = arguments[_i];
	        }
	        this.versionNumber = versionNumber;
	        this.alignmentPatternCenters = alignmentPatternCenters;
	        this.ecBlocks = ecBlocks;
	        var total = 0;
	        var ecCodewords = ecBlocks[0].getECCodewordsPerBlock();
	        var ecbArray = ecBlocks[0].getECBlocks();
	        try {
	            for (var ecbArray_1 = __values$4(ecbArray), ecbArray_1_1 = ecbArray_1.next(); !ecbArray_1_1.done; ecbArray_1_1 = ecbArray_1.next()) {
	                var ecBlock = ecbArray_1_1.value;
	                total += ecBlock.getCount() * (ecBlock.getDataCodewords() + ecCodewords);
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (ecbArray_1_1 && !ecbArray_1_1.done && (_a = ecbArray_1.return)) _a.call(ecbArray_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        this.totalCodewords = total;
	    }
	    Version.prototype.getVersionNumber = function () {
	        return this.versionNumber;
	    };
	    Version.prototype.getAlignmentPatternCenters = function () {
	        return this.alignmentPatternCenters;
	    };
	    Version.prototype.getTotalCodewords = function () {
	        return this.totalCodewords;
	    };
	    Version.prototype.getDimensionForVersion = function () {
	        return 17 + 4 * this.versionNumber;
	    };
	    Version.prototype.getECBlocksForLevel = function (ecLevel) {
	        return this.ecBlocks[ecLevel.getValue()];
	        // TYPESCRIPTPORT: original was using ordinal, and using the order of levels as defined in ErrorCorrectionLevel enum (LMQH)
	        // I will use the direct value from ErrorCorrectionLevelValues enum which in typescript goes to a number
	    };
	    /**
	     * <p>Deduces version information purely from QR Code dimensions.</p>
	     *
	     * @param dimension dimension in modules
	     * @return Version for a QR Code of that dimension
	     * @throws FormatException if dimension is not 1 mod 4
	     */
	    Version.getProvisionalVersionForDimension = function (dimension /*int*/) {
	        if (dimension % 4 !== 1) {
	            throw new FormatException_1$2.default();
	        }
	        try {
	            return this.getVersionForNumber((dimension - 17) / 4);
	        }
	        catch (ignored /*: IllegalArgumentException*/) {
	            throw new FormatException_1$2.default();
	        }
	    };
	    Version.getVersionForNumber = function (versionNumber /*int*/) {
	        if (versionNumber < 1 || versionNumber > 40) {
	            throw new IllegalArgumentException_1$2.default();
	        }
	        return Version.VERSIONS[versionNumber - 1];
	    };
	    Version.decodeVersionInformation = function (versionBits /*int*/) {
	        var bestDifference = Number.MAX_SAFE_INTEGER;
	        var bestVersion = 0;
	        for (var i = 0; i < Version.VERSION_DECODE_INFO.length; i++) {
	            var targetVersion = Version.VERSION_DECODE_INFO[i];
	            // Do the version info bits match exactly? done.
	            if (targetVersion === versionBits) {
	                return Version.getVersionForNumber(i + 7);
	            }
	            // Otherwise see if this is the closest to a real version info bit string
	            // we have seen so far
	            var bitsDifference = FormatInformation_1$1.default.numBitsDiffering(versionBits, targetVersion);
	            if (bitsDifference < bestDifference) {
	                bestVersion = i + 7;
	                bestDifference = bitsDifference;
	            }
	        }
	        // We can tolerate up to 3 bits of error since no two version info codewords will
	        // differ in less than 8 bits.
	        if (bestDifference <= 3) {
	            return Version.getVersionForNumber(bestVersion);
	        }
	        // If we didn't find a close enough match, fail
	        return null;
	    };
	    /**
	     * See ISO 18004:2006 Annex E
	     */
	    Version.prototype.buildFunctionPattern = function () {
	        var dimension = this.getDimensionForVersion();
	        var bitMatrix = new BitMatrix_1$3.default(dimension);
	        // Top left finder pattern + separator + format
	        bitMatrix.setRegion(0, 0, 9, 9);
	        // Top right finder pattern + separator + format
	        bitMatrix.setRegion(dimension - 8, 0, 8, 9);
	        // Bottom left finder pattern + separator + format
	        bitMatrix.setRegion(0, dimension - 8, 9, 8);
	        // Alignment patterns
	        var max = this.alignmentPatternCenters.length;
	        for (var x = 0; x < max; x++) {
	            var i = this.alignmentPatternCenters[x] - 2;
	            for (var y = 0; y < max; y++) {
	                if ((x === 0 && (y === 0 || y === max - 1)) || (x === max - 1 && y === 0)) {
	                    // No alignment patterns near the three finder patterns
	                    continue;
	                }
	                bitMatrix.setRegion(this.alignmentPatternCenters[y] - 2, i, 5, 5);
	            }
	        }
	        // Vertical timing pattern
	        bitMatrix.setRegion(6, 9, 1, dimension - 17);
	        // Horizontal timing pattern
	        bitMatrix.setRegion(9, 6, dimension - 17, 1);
	        if (this.versionNumber > 6) {
	            // Version info, top right
	            bitMatrix.setRegion(dimension - 11, 0, 3, 6);
	            // Version info, bottom left
	            bitMatrix.setRegion(0, dimension - 11, 6, 3);
	        }
	        return bitMatrix;
	    };
	    /*@Override*/
	    Version.prototype.toString = function () {
	        return '' + this.versionNumber;
	    };
	    /**
	       * See ISO 18004:2006 Annex D.
	       * Element i represents the raw version bits that specify version i + 7
	       */
	    Version.VERSION_DECODE_INFO = Int32Array.from([
	        0x07C94, 0x085BC, 0x09A99, 0x0A4D3, 0x0BBF6,
	        0x0C762, 0x0D847, 0x0E60D, 0x0F928, 0x10B78,
	        0x1145D, 0x12A17, 0x13532, 0x149A6, 0x15683,
	        0x168C9, 0x177EC, 0x18EC4, 0x191E1, 0x1AFAB,
	        0x1B08E, 0x1CC1A, 0x1D33F, 0x1ED75, 0x1F250,
	        0x209D5, 0x216F0, 0x228BA, 0x2379F, 0x24B0B,
	        0x2542E, 0x26A64, 0x27541, 0x28C69
	    ]);
	    /**
	       * See ISO 18004:2006 6.5.1 Table 9
	       */
	    Version.VERSIONS = [
	        new Version(1, new Int32Array(0), new ECBlocks_1.default(7, new ECB_1.default(1, 19)), new ECBlocks_1.default(10, new ECB_1.default(1, 16)), new ECBlocks_1.default(13, new ECB_1.default(1, 13)), new ECBlocks_1.default(17, new ECB_1.default(1, 9))),
	        new Version(2, Int32Array.from([6, 18]), new ECBlocks_1.default(10, new ECB_1.default(1, 34)), new ECBlocks_1.default(16, new ECB_1.default(1, 28)), new ECBlocks_1.default(22, new ECB_1.default(1, 22)), new ECBlocks_1.default(28, new ECB_1.default(1, 16))),
	        new Version(3, Int32Array.from([6, 22]), new ECBlocks_1.default(15, new ECB_1.default(1, 55)), new ECBlocks_1.default(26, new ECB_1.default(1, 44)), new ECBlocks_1.default(18, new ECB_1.default(2, 17)), new ECBlocks_1.default(22, new ECB_1.default(2, 13))),
	        new Version(4, Int32Array.from([6, 26]), new ECBlocks_1.default(20, new ECB_1.default(1, 80)), new ECBlocks_1.default(18, new ECB_1.default(2, 32)), new ECBlocks_1.default(26, new ECB_1.default(2, 24)), new ECBlocks_1.default(16, new ECB_1.default(4, 9))),
	        new Version(5, Int32Array.from([6, 30]), new ECBlocks_1.default(26, new ECB_1.default(1, 108)), new ECBlocks_1.default(24, new ECB_1.default(2, 43)), new ECBlocks_1.default(18, new ECB_1.default(2, 15), new ECB_1.default(2, 16)), new ECBlocks_1.default(22, new ECB_1.default(2, 11), new ECB_1.default(2, 12))),
	        new Version(6, Int32Array.from([6, 34]), new ECBlocks_1.default(18, new ECB_1.default(2, 68)), new ECBlocks_1.default(16, new ECB_1.default(4, 27)), new ECBlocks_1.default(24, new ECB_1.default(4, 19)), new ECBlocks_1.default(28, new ECB_1.default(4, 15))),
	        new Version(7, Int32Array.from([6, 22, 38]), new ECBlocks_1.default(20, new ECB_1.default(2, 78)), new ECBlocks_1.default(18, new ECB_1.default(4, 31)), new ECBlocks_1.default(18, new ECB_1.default(2, 14), new ECB_1.default(4, 15)), new ECBlocks_1.default(26, new ECB_1.default(4, 13), new ECB_1.default(1, 14))),
	        new Version(8, Int32Array.from([6, 24, 42]), new ECBlocks_1.default(24, new ECB_1.default(2, 97)), new ECBlocks_1.default(22, new ECB_1.default(2, 38), new ECB_1.default(2, 39)), new ECBlocks_1.default(22, new ECB_1.default(4, 18), new ECB_1.default(2, 19)), new ECBlocks_1.default(26, new ECB_1.default(4, 14), new ECB_1.default(2, 15))),
	        new Version(9, Int32Array.from([6, 26, 46]), new ECBlocks_1.default(30, new ECB_1.default(2, 116)), new ECBlocks_1.default(22, new ECB_1.default(3, 36), new ECB_1.default(2, 37)), new ECBlocks_1.default(20, new ECB_1.default(4, 16), new ECB_1.default(4, 17)), new ECBlocks_1.default(24, new ECB_1.default(4, 12), new ECB_1.default(4, 13))),
	        new Version(10, Int32Array.from([6, 28, 50]), new ECBlocks_1.default(18, new ECB_1.default(2, 68), new ECB_1.default(2, 69)), new ECBlocks_1.default(26, new ECB_1.default(4, 43), new ECB_1.default(1, 44)), new ECBlocks_1.default(24, new ECB_1.default(6, 19), new ECB_1.default(2, 20)), new ECBlocks_1.default(28, new ECB_1.default(6, 15), new ECB_1.default(2, 16))),
	        new Version(11, Int32Array.from([6, 30, 54]), new ECBlocks_1.default(20, new ECB_1.default(4, 81)), new ECBlocks_1.default(30, new ECB_1.default(1, 50), new ECB_1.default(4, 51)), new ECBlocks_1.default(28, new ECB_1.default(4, 22), new ECB_1.default(4, 23)), new ECBlocks_1.default(24, new ECB_1.default(3, 12), new ECB_1.default(8, 13))),
	        new Version(12, Int32Array.from([6, 32, 58]), new ECBlocks_1.default(24, new ECB_1.default(2, 92), new ECB_1.default(2, 93)), new ECBlocks_1.default(22, new ECB_1.default(6, 36), new ECB_1.default(2, 37)), new ECBlocks_1.default(26, new ECB_1.default(4, 20), new ECB_1.default(6, 21)), new ECBlocks_1.default(28, new ECB_1.default(7, 14), new ECB_1.default(4, 15))),
	        new Version(13, Int32Array.from([6, 34, 62]), new ECBlocks_1.default(26, new ECB_1.default(4, 107)), new ECBlocks_1.default(22, new ECB_1.default(8, 37), new ECB_1.default(1, 38)), new ECBlocks_1.default(24, new ECB_1.default(8, 20), new ECB_1.default(4, 21)), new ECBlocks_1.default(22, new ECB_1.default(12, 11), new ECB_1.default(4, 12))),
	        new Version(14, Int32Array.from([6, 26, 46, 66]), new ECBlocks_1.default(30, new ECB_1.default(3, 115), new ECB_1.default(1, 116)), new ECBlocks_1.default(24, new ECB_1.default(4, 40), new ECB_1.default(5, 41)), new ECBlocks_1.default(20, new ECB_1.default(11, 16), new ECB_1.default(5, 17)), new ECBlocks_1.default(24, new ECB_1.default(11, 12), new ECB_1.default(5, 13))),
	        new Version(15, Int32Array.from([6, 26, 48, 70]), new ECBlocks_1.default(22, new ECB_1.default(5, 87), new ECB_1.default(1, 88)), new ECBlocks_1.default(24, new ECB_1.default(5, 41), new ECB_1.default(5, 42)), new ECBlocks_1.default(30, new ECB_1.default(5, 24), new ECB_1.default(7, 25)), new ECBlocks_1.default(24, new ECB_1.default(11, 12), new ECB_1.default(7, 13))),
	        new Version(16, Int32Array.from([6, 26, 50, 74]), new ECBlocks_1.default(24, new ECB_1.default(5, 98), new ECB_1.default(1, 99)), new ECBlocks_1.default(28, new ECB_1.default(7, 45), new ECB_1.default(3, 46)), new ECBlocks_1.default(24, new ECB_1.default(15, 19), new ECB_1.default(2, 20)), new ECBlocks_1.default(30, new ECB_1.default(3, 15), new ECB_1.default(13, 16))),
	        new Version(17, Int32Array.from([6, 30, 54, 78]), new ECBlocks_1.default(28, new ECB_1.default(1, 107), new ECB_1.default(5, 108)), new ECBlocks_1.default(28, new ECB_1.default(10, 46), new ECB_1.default(1, 47)), new ECBlocks_1.default(28, new ECB_1.default(1, 22), new ECB_1.default(15, 23)), new ECBlocks_1.default(28, new ECB_1.default(2, 14), new ECB_1.default(17, 15))),
	        new Version(18, Int32Array.from([6, 30, 56, 82]), new ECBlocks_1.default(30, new ECB_1.default(5, 120), new ECB_1.default(1, 121)), new ECBlocks_1.default(26, new ECB_1.default(9, 43), new ECB_1.default(4, 44)), new ECBlocks_1.default(28, new ECB_1.default(17, 22), new ECB_1.default(1, 23)), new ECBlocks_1.default(28, new ECB_1.default(2, 14), new ECB_1.default(19, 15))),
	        new Version(19, Int32Array.from([6, 30, 58, 86]), new ECBlocks_1.default(28, new ECB_1.default(3, 113), new ECB_1.default(4, 114)), new ECBlocks_1.default(26, new ECB_1.default(3, 44), new ECB_1.default(11, 45)), new ECBlocks_1.default(26, new ECB_1.default(17, 21), new ECB_1.default(4, 22)), new ECBlocks_1.default(26, new ECB_1.default(9, 13), new ECB_1.default(16, 14))),
	        new Version(20, Int32Array.from([6, 34, 62, 90]), new ECBlocks_1.default(28, new ECB_1.default(3, 107), new ECB_1.default(5, 108)), new ECBlocks_1.default(26, new ECB_1.default(3, 41), new ECB_1.default(13, 42)), new ECBlocks_1.default(30, new ECB_1.default(15, 24), new ECB_1.default(5, 25)), new ECBlocks_1.default(28, new ECB_1.default(15, 15), new ECB_1.default(10, 16))),
	        new Version(21, Int32Array.from([6, 28, 50, 72, 94]), new ECBlocks_1.default(28, new ECB_1.default(4, 116), new ECB_1.default(4, 117)), new ECBlocks_1.default(26, new ECB_1.default(17, 42)), new ECBlocks_1.default(28, new ECB_1.default(17, 22), new ECB_1.default(6, 23)), new ECBlocks_1.default(30, new ECB_1.default(19, 16), new ECB_1.default(6, 17))),
	        new Version(22, Int32Array.from([6, 26, 50, 74, 98]), new ECBlocks_1.default(28, new ECB_1.default(2, 111), new ECB_1.default(7, 112)), new ECBlocks_1.default(28, new ECB_1.default(17, 46)), new ECBlocks_1.default(30, new ECB_1.default(7, 24), new ECB_1.default(16, 25)), new ECBlocks_1.default(24, new ECB_1.default(34, 13))),
	        new Version(23, Int32Array.from([6, 30, 54, 78, 102]), new ECBlocks_1.default(30, new ECB_1.default(4, 121), new ECB_1.default(5, 122)), new ECBlocks_1.default(28, new ECB_1.default(4, 47), new ECB_1.default(14, 48)), new ECBlocks_1.default(30, new ECB_1.default(11, 24), new ECB_1.default(14, 25)), new ECBlocks_1.default(30, new ECB_1.default(16, 15), new ECB_1.default(14, 16))),
	        new Version(24, Int32Array.from([6, 28, 54, 80, 106]), new ECBlocks_1.default(30, new ECB_1.default(6, 117), new ECB_1.default(4, 118)), new ECBlocks_1.default(28, new ECB_1.default(6, 45), new ECB_1.default(14, 46)), new ECBlocks_1.default(30, new ECB_1.default(11, 24), new ECB_1.default(16, 25)), new ECBlocks_1.default(30, new ECB_1.default(30, 16), new ECB_1.default(2, 17))),
	        new Version(25, Int32Array.from([6, 32, 58, 84, 110]), new ECBlocks_1.default(26, new ECB_1.default(8, 106), new ECB_1.default(4, 107)), new ECBlocks_1.default(28, new ECB_1.default(8, 47), new ECB_1.default(13, 48)), new ECBlocks_1.default(30, new ECB_1.default(7, 24), new ECB_1.default(22, 25)), new ECBlocks_1.default(30, new ECB_1.default(22, 15), new ECB_1.default(13, 16))),
	        new Version(26, Int32Array.from([6, 30, 58, 86, 114]), new ECBlocks_1.default(28, new ECB_1.default(10, 114), new ECB_1.default(2, 115)), new ECBlocks_1.default(28, new ECB_1.default(19, 46), new ECB_1.default(4, 47)), new ECBlocks_1.default(28, new ECB_1.default(28, 22), new ECB_1.default(6, 23)), new ECBlocks_1.default(30, new ECB_1.default(33, 16), new ECB_1.default(4, 17))),
	        new Version(27, Int32Array.from([6, 34, 62, 90, 118]), new ECBlocks_1.default(30, new ECB_1.default(8, 122), new ECB_1.default(4, 123)), new ECBlocks_1.default(28, new ECB_1.default(22, 45), new ECB_1.default(3, 46)), new ECBlocks_1.default(30, new ECB_1.default(8, 23), new ECB_1.default(26, 24)), new ECBlocks_1.default(30, new ECB_1.default(12, 15), new ECB_1.default(28, 16))),
	        new Version(28, Int32Array.from([6, 26, 50, 74, 98, 122]), new ECBlocks_1.default(30, new ECB_1.default(3, 117), new ECB_1.default(10, 118)), new ECBlocks_1.default(28, new ECB_1.default(3, 45), new ECB_1.default(23, 46)), new ECBlocks_1.default(30, new ECB_1.default(4, 24), new ECB_1.default(31, 25)), new ECBlocks_1.default(30, new ECB_1.default(11, 15), new ECB_1.default(31, 16))),
	        new Version(29, Int32Array.from([6, 30, 54, 78, 102, 126]), new ECBlocks_1.default(30, new ECB_1.default(7, 116), new ECB_1.default(7, 117)), new ECBlocks_1.default(28, new ECB_1.default(21, 45), new ECB_1.default(7, 46)), new ECBlocks_1.default(30, new ECB_1.default(1, 23), new ECB_1.default(37, 24)), new ECBlocks_1.default(30, new ECB_1.default(19, 15), new ECB_1.default(26, 16))),
	        new Version(30, Int32Array.from([6, 26, 52, 78, 104, 130]), new ECBlocks_1.default(30, new ECB_1.default(5, 115), new ECB_1.default(10, 116)), new ECBlocks_1.default(28, new ECB_1.default(19, 47), new ECB_1.default(10, 48)), new ECBlocks_1.default(30, new ECB_1.default(15, 24), new ECB_1.default(25, 25)), new ECBlocks_1.default(30, new ECB_1.default(23, 15), new ECB_1.default(25, 16))),
	        new Version(31, Int32Array.from([6, 30, 56, 82, 108, 134]), new ECBlocks_1.default(30, new ECB_1.default(13, 115), new ECB_1.default(3, 116)), new ECBlocks_1.default(28, new ECB_1.default(2, 46), new ECB_1.default(29, 47)), new ECBlocks_1.default(30, new ECB_1.default(42, 24), new ECB_1.default(1, 25)), new ECBlocks_1.default(30, new ECB_1.default(23, 15), new ECB_1.default(28, 16))),
	        new Version(32, Int32Array.from([6, 34, 60, 86, 112, 138]), new ECBlocks_1.default(30, new ECB_1.default(17, 115)), new ECBlocks_1.default(28, new ECB_1.default(10, 46), new ECB_1.default(23, 47)), new ECBlocks_1.default(30, new ECB_1.default(10, 24), new ECB_1.default(35, 25)), new ECBlocks_1.default(30, new ECB_1.default(19, 15), new ECB_1.default(35, 16))),
	        new Version(33, Int32Array.from([6, 30, 58, 86, 114, 142]), new ECBlocks_1.default(30, new ECB_1.default(17, 115), new ECB_1.default(1, 116)), new ECBlocks_1.default(28, new ECB_1.default(14, 46), new ECB_1.default(21, 47)), new ECBlocks_1.default(30, new ECB_1.default(29, 24), new ECB_1.default(19, 25)), new ECBlocks_1.default(30, new ECB_1.default(11, 15), new ECB_1.default(46, 16))),
	        new Version(34, Int32Array.from([6, 34, 62, 90, 118, 146]), new ECBlocks_1.default(30, new ECB_1.default(13, 115), new ECB_1.default(6, 116)), new ECBlocks_1.default(28, new ECB_1.default(14, 46), new ECB_1.default(23, 47)), new ECBlocks_1.default(30, new ECB_1.default(44, 24), new ECB_1.default(7, 25)), new ECBlocks_1.default(30, new ECB_1.default(59, 16), new ECB_1.default(1, 17))),
	        new Version(35, Int32Array.from([6, 30, 54, 78, 102, 126, 150]), new ECBlocks_1.default(30, new ECB_1.default(12, 121), new ECB_1.default(7, 122)), new ECBlocks_1.default(28, new ECB_1.default(12, 47), new ECB_1.default(26, 48)), new ECBlocks_1.default(30, new ECB_1.default(39, 24), new ECB_1.default(14, 25)), new ECBlocks_1.default(30, new ECB_1.default(22, 15), new ECB_1.default(41, 16))),
	        new Version(36, Int32Array.from([6, 24, 50, 76, 102, 128, 154]), new ECBlocks_1.default(30, new ECB_1.default(6, 121), new ECB_1.default(14, 122)), new ECBlocks_1.default(28, new ECB_1.default(6, 47), new ECB_1.default(34, 48)), new ECBlocks_1.default(30, new ECB_1.default(46, 24), new ECB_1.default(10, 25)), new ECBlocks_1.default(30, new ECB_1.default(2, 15), new ECB_1.default(64, 16))),
	        new Version(37, Int32Array.from([6, 28, 54, 80, 106, 132, 158]), new ECBlocks_1.default(30, new ECB_1.default(17, 122), new ECB_1.default(4, 123)), new ECBlocks_1.default(28, new ECB_1.default(29, 46), new ECB_1.default(14, 47)), new ECBlocks_1.default(30, new ECB_1.default(49, 24), new ECB_1.default(10, 25)), new ECBlocks_1.default(30, new ECB_1.default(24, 15), new ECB_1.default(46, 16))),
	        new Version(38, Int32Array.from([6, 32, 58, 84, 110, 136, 162]), new ECBlocks_1.default(30, new ECB_1.default(4, 122), new ECB_1.default(18, 123)), new ECBlocks_1.default(28, new ECB_1.default(13, 46), new ECB_1.default(32, 47)), new ECBlocks_1.default(30, new ECB_1.default(48, 24), new ECB_1.default(14, 25)), new ECBlocks_1.default(30, new ECB_1.default(42, 15), new ECB_1.default(32, 16))),
	        new Version(39, Int32Array.from([6, 26, 54, 82, 110, 138, 166]), new ECBlocks_1.default(30, new ECB_1.default(20, 117), new ECB_1.default(4, 118)), new ECBlocks_1.default(28, new ECB_1.default(40, 47), new ECB_1.default(7, 48)), new ECBlocks_1.default(30, new ECB_1.default(43, 24), new ECB_1.default(22, 25)), new ECBlocks_1.default(30, new ECB_1.default(10, 15), new ECB_1.default(67, 16))),
	        new Version(40, Int32Array.from([6, 30, 58, 86, 114, 142, 170]), new ECBlocks_1.default(30, new ECB_1.default(19, 118), new ECB_1.default(6, 119)), new ECBlocks_1.default(28, new ECB_1.default(18, 47), new ECB_1.default(31, 48)), new ECBlocks_1.default(30, new ECB_1.default(34, 24), new ECB_1.default(34, 25)), new ECBlocks_1.default(30, new ECB_1.default(20, 15), new ECB_1.default(61, 16)))
	    ];
	    return Version;
	}());
	Version$1.default = Version;

	var DataMask = {};

	(function (exports) {
	/*
	 * Copyright 2007 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DataMaskValues = void 0;
	var DataMaskValues;
	(function (DataMaskValues) {
	    DataMaskValues[DataMaskValues["DATA_MASK_000"] = 0] = "DATA_MASK_000";
	    DataMaskValues[DataMaskValues["DATA_MASK_001"] = 1] = "DATA_MASK_001";
	    DataMaskValues[DataMaskValues["DATA_MASK_010"] = 2] = "DATA_MASK_010";
	    DataMaskValues[DataMaskValues["DATA_MASK_011"] = 3] = "DATA_MASK_011";
	    DataMaskValues[DataMaskValues["DATA_MASK_100"] = 4] = "DATA_MASK_100";
	    DataMaskValues[DataMaskValues["DATA_MASK_101"] = 5] = "DATA_MASK_101";
	    DataMaskValues[DataMaskValues["DATA_MASK_110"] = 6] = "DATA_MASK_110";
	    DataMaskValues[DataMaskValues["DATA_MASK_111"] = 7] = "DATA_MASK_111";
	})(DataMaskValues = exports.DataMaskValues || (exports.DataMaskValues = {}));
	/**
	 * <p>Encapsulates data masks for the data bits in a QR code, per ISO 18004:2006 6.8. Implementations
	 * of this class can un-mask a raw BitMatrix. For simplicity, they will unmask the entire BitMatrix,
	 * including areas used for finder patterns, timing patterns, etc. These areas should be unused
	 * after the point they are unmasked anyway.</p>
	 *
	 * <p>Note that the diagram in section 6.8.1 is misleading since it indicates that i is column position
	 * and j is row position. In fact, as the text says, i is row position and j is column position.</p>
	 *
	 * @author Sean Owen
	 */
	var DataMask = /** @class */ (function () {
	    // See ISO 18004:2006 6.8.1
	    function DataMask(value, isMasked) {
	        this.value = value;
	        this.isMasked = isMasked;
	    }
	    // End of enum constants.
	    /**
	     * <p>Implementations of this method reverse the data masking process applied to a QR Code and
	     * make its bits ready to read.</p>
	     *
	     * @param bits representation of QR Code bits
	     * @param dimension dimension of QR Code, represented by bits, being unmasked
	     */
	    DataMask.prototype.unmaskBitMatrix = function (bits, dimension /*int*/) {
	        for (var i = 0; i < dimension; i++) {
	            for (var j = 0; j < dimension; j++) {
	                if (this.isMasked(i, j)) {
	                    bits.flip(j, i);
	                }
	            }
	        }
	    };
	    DataMask.values = new Map([
	        /**
	         * 000: mask bits for which (x + y) mod 2 == 0
	         */
	        [DataMaskValues.DATA_MASK_000, new DataMask(DataMaskValues.DATA_MASK_000, function (i /*int*/, j /*int*/) { return ((i + j) & 0x01) === 0; })],
	        /**
	         * 001: mask bits for which x mod 2 == 0
	         */
	        [DataMaskValues.DATA_MASK_001, new DataMask(DataMaskValues.DATA_MASK_001, function (i /*int*/, j /*int*/) { return (i & 0x01) === 0; })],
	        /**
	         * 010: mask bits for which y mod 3 == 0
	         */
	        [DataMaskValues.DATA_MASK_010, new DataMask(DataMaskValues.DATA_MASK_010, function (i /*int*/, j /*int*/) { return j % 3 === 0; })],
	        /**
	         * 011: mask bits for which (x + y) mod 3 == 0
	         */
	        [DataMaskValues.DATA_MASK_011, new DataMask(DataMaskValues.DATA_MASK_011, function (i /*int*/, j /*int*/) { return (i + j) % 3 === 0; })],
	        /**
	         * 100: mask bits for which (x/2 + y/3) mod 2 == 0
	         */
	        [DataMaskValues.DATA_MASK_100, new DataMask(DataMaskValues.DATA_MASK_100, function (i /*int*/, j /*int*/) { return ((Math.floor(i / 2) + Math.floor(j / 3)) & 0x01) === 0; })],
	        /**
	         * 101: mask bits for which xy mod 2 + xy mod 3 == 0
	         * equivalently, such that xy mod 6 == 0
	         */
	        [DataMaskValues.DATA_MASK_101, new DataMask(DataMaskValues.DATA_MASK_101, function (i /*int*/, j /*int*/) { return (i * j) % 6 === 0; })],
	        /**
	         * 110: mask bits for which (xy mod 2 + xy mod 3) mod 2 == 0
	         * equivalently, such that xy mod 6 < 3
	         */
	        [DataMaskValues.DATA_MASK_110, new DataMask(DataMaskValues.DATA_MASK_110, function (i /*int*/, j /*int*/) { return ((i * j) % 6) < 3; })],
	        /**
	         * 111: mask bits for which ((x+y)mod 2 + xy mod 3) mod 2 == 0
	         * equivalently, such that (x + y + xy mod 3) mod 2 == 0
	         */
	        [DataMaskValues.DATA_MASK_111, new DataMask(DataMaskValues.DATA_MASK_111, function (i /*int*/, j /*int*/) { return ((i + j + ((i * j) % 3)) & 0x01) === 0; })],
	    ]);
	    return DataMask;
	}());
	exports.default = DataMask;

	}(DataMask));

	/*
	 * Copyright 2007 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(BitMatrixParser$1, "__esModule", { value: true });
	var Version_1$1 = Version$1;
	var FormatInformation_1 = FormatInformation$1;
	var DataMask_1 = DataMask;
	var FormatException_1$1 = FormatException$1;
	/**
	 * @author Sean Owen
	 */
	var BitMatrixParser = /** @class */ (function () {
	    /**
	     * @param bitMatrix {@link BitMatrix} to parse
	     * @throws FormatException if dimension is not >= 21 and 1 mod 4
	     */
	    function BitMatrixParser(bitMatrix) {
	        var dimension = bitMatrix.getHeight();
	        if (dimension < 21 || (dimension & 0x03) !== 1) {
	            throw new FormatException_1$1.default();
	        }
	        this.bitMatrix = bitMatrix;
	    }
	    /**
	     * <p>Reads format information from one of its two locations within the QR Code.</p>
	     *
	     * @return {@link FormatInformation} encapsulating the QR Code's format info
	     * @throws FormatException if both format information locations cannot be parsed as
	     * the valid encoding of format information
	     */
	    BitMatrixParser.prototype.readFormatInformation = function () {
	        if (this.parsedFormatInfo !== null && this.parsedFormatInfo !== undefined) {
	            return this.parsedFormatInfo;
	        }
	        // Read top-left format info bits
	        var formatInfoBits1 = 0;
	        for (var i = 0; i < 6; i++) {
	            formatInfoBits1 = this.copyBit(i, 8, formatInfoBits1);
	        }
	        // .. and skip a bit in the timing pattern ...
	        formatInfoBits1 = this.copyBit(7, 8, formatInfoBits1);
	        formatInfoBits1 = this.copyBit(8, 8, formatInfoBits1);
	        formatInfoBits1 = this.copyBit(8, 7, formatInfoBits1);
	        // .. and skip a bit in the timing pattern ...
	        for (var j = 5; j >= 0; j--) {
	            formatInfoBits1 = this.copyBit(8, j, formatInfoBits1);
	        }
	        // Read the top-right/bottom-left pattern too
	        var dimension = this.bitMatrix.getHeight();
	        var formatInfoBits2 = 0;
	        var jMin = dimension - 7;
	        for (var j = dimension - 1; j >= jMin; j--) {
	            formatInfoBits2 = this.copyBit(8, j, formatInfoBits2);
	        }
	        for (var i = dimension - 8; i < dimension; i++) {
	            formatInfoBits2 = this.copyBit(i, 8, formatInfoBits2);
	        }
	        this.parsedFormatInfo = FormatInformation_1.default.decodeFormatInformation(formatInfoBits1, formatInfoBits2);
	        if (this.parsedFormatInfo !== null) {
	            return this.parsedFormatInfo;
	        }
	        throw new FormatException_1$1.default();
	    };
	    /**
	     * <p>Reads version information from one of its two locations within the QR Code.</p>
	     *
	     * @return {@link Version} encapsulating the QR Code's version
	     * @throws FormatException if both version information locations cannot be parsed as
	     * the valid encoding of version information
	     */
	    BitMatrixParser.prototype.readVersion = function () {
	        if (this.parsedVersion !== null && this.parsedVersion !== undefined) {
	            return this.parsedVersion;
	        }
	        var dimension = this.bitMatrix.getHeight();
	        var provisionalVersion = Math.floor((dimension - 17) / 4);
	        if (provisionalVersion <= 6) {
	            return Version_1$1.default.getVersionForNumber(provisionalVersion);
	        }
	        // Read top-right version info: 3 wide by 6 tall
	        var versionBits = 0;
	        var ijMin = dimension - 11;
	        for (var j = 5; j >= 0; j--) {
	            for (var i = dimension - 9; i >= ijMin; i--) {
	                versionBits = this.copyBit(i, j, versionBits);
	            }
	        }
	        var theParsedVersion = Version_1$1.default.decodeVersionInformation(versionBits);
	        if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {
	            this.parsedVersion = theParsedVersion;
	            return theParsedVersion;
	        }
	        // Hmm, failed. Try bottom left: 6 wide by 3 tall
	        versionBits = 0;
	        for (var i = 5; i >= 0; i--) {
	            for (var j = dimension - 9; j >= ijMin; j--) {
	                versionBits = this.copyBit(i, j, versionBits);
	            }
	        }
	        theParsedVersion = Version_1$1.default.decodeVersionInformation(versionBits);
	        if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {
	            this.parsedVersion = theParsedVersion;
	            return theParsedVersion;
	        }
	        throw new FormatException_1$1.default();
	    };
	    BitMatrixParser.prototype.copyBit = function (i /*int*/, j /*int*/, versionBits /*int*/) {
	        var bit = this.isMirror ? this.bitMatrix.get(j, i) : this.bitMatrix.get(i, j);
	        return bit ? (versionBits << 1) | 0x1 : versionBits << 1;
	    };
	    /**
	     * <p>Reads the bits in the {@link BitMatrix} representing the finder pattern in the
	     * correct order in order to reconstruct the codewords bytes contained within the
	     * QR Code.</p>
	     *
	     * @return bytes encoded within the QR Code
	     * @throws FormatException if the exact number of bytes expected is not read
	     */
	    BitMatrixParser.prototype.readCodewords = function () {
	        var formatInfo = this.readFormatInformation();
	        var version = this.readVersion();
	        // Get the data mask for the format used in this QR Code. This will exclude
	        // some bits from reading as we wind through the bit matrix.
	        var dataMask = DataMask_1.default.values.get(formatInfo.getDataMask());
	        var dimension = this.bitMatrix.getHeight();
	        dataMask.unmaskBitMatrix(this.bitMatrix, dimension);
	        var functionPattern = version.buildFunctionPattern();
	        var readingUp = true;
	        var result = new Uint8Array(version.getTotalCodewords());
	        var resultOffset = 0;
	        var currentByte = 0;
	        var bitsRead = 0;
	        // Read columns in pairs, from right to left
	        for (var j = dimension - 1; j > 0; j -= 2) {
	            if (j === 6) {
	                // Skip whole column with vertical alignment pattern
	                // saves time and makes the other code proceed more cleanly
	                j--;
	            }
	            // Read alternatingly from bottom to top then top to bottom
	            for (var count = 0; count < dimension; count++) {
	                var i = readingUp ? dimension - 1 - count : count;
	                for (var col = 0; col < 2; col++) {
	                    // Ignore bits covered by the function pattern
	                    if (!functionPattern.get(j - col, i)) {
	                        // Read a bit
	                        bitsRead++;
	                        currentByte <<= 1;
	                        if (this.bitMatrix.get(j - col, i)) {
	                            currentByte |= 1;
	                        }
	                        // If we've made a whole byte, save it off
	                        if (bitsRead === 8) {
	                            result[resultOffset++] = /*(byte) */ currentByte;
	                            bitsRead = 0;
	                            currentByte = 0;
	                        }
	                    }
	                }
	            }
	            readingUp = !readingUp; // readingUp ^= true; // readingUp = !readingUp; // switch directions
	        }
	        if (resultOffset !== version.getTotalCodewords()) {
	            throw new FormatException_1$1.default();
	        }
	        return result;
	    };
	    /**
	     * Revert the mask removal done while reading the code words. The bit matrix should revert to its original state.
	     */
	    BitMatrixParser.prototype.remask = function () {
	        if (this.parsedFormatInfo === null) {
	            return; // We have no format information, and have no data mask
	        }
	        var dataMask = DataMask_1.default.values[this.parsedFormatInfo.getDataMask()];
	        var dimension = this.bitMatrix.getHeight();
	        dataMask.unmaskBitMatrix(this.bitMatrix, dimension);
	    };
	    /**
	     * Prepare the parser for a mirrored operation.
	     * This flag has effect only on the {@link #readFormatInformation()} and the
	     * {@link #readVersion()}. Before proceeding with {@link #readCodewords()} the
	     * {@link #mirror()} method should be called.
	     *
	     * @param mirror Whether to read version and format information mirrored.
	     */
	    BitMatrixParser.prototype.setMirror = function (isMirror) {
	        this.parsedVersion = null;
	        this.parsedFormatInfo = null;
	        this.isMirror = isMirror;
	    };
	    /** Mirror the bit matrix in order to attempt a second reading. */
	    BitMatrixParser.prototype.mirror = function () {
	        var bitMatrix = this.bitMatrix;
	        for (var x = 0, width = bitMatrix.getWidth(); x < width; x++) {
	            for (var y = x + 1, height = bitMatrix.getHeight(); y < height; y++) {
	                if (bitMatrix.get(x, y) !== bitMatrix.get(y, x)) {
	                    bitMatrix.flip(y, x);
	                    bitMatrix.flip(x, y);
	                }
	            }
	        }
	    };
	    return BitMatrixParser;
	}());
	BitMatrixParser$1.default = BitMatrixParser;

	var DataBlock$1 = {};

	/*
	 * Copyright 2007 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __values$3 = (commonjsGlobal && commonjsGlobal.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(DataBlock$1, "__esModule", { value: true });
	var IllegalArgumentException_1$1 = IllegalArgumentException$1;
	/**
	 * <p>Encapsulates a block of data within a QR Code. QR Codes may split their data into
	 * multiple blocks, each of which is a unit of data and error-correction codewords. Each
	 * is represented by an instance of this class.</p>
	 *
	 * @author Sean Owen
	 */
	var DataBlock = /** @class */ (function () {
	    function DataBlock(numDataCodewords /*int*/, codewords) {
	        this.numDataCodewords = numDataCodewords;
	        this.codewords = codewords;
	    }
	    /**
	     * <p>When QR Codes use multiple data blocks, they are actually interleaved.
	     * That is, the first byte of data block 1 to n is written, then the second bytes, and so on. This
	     * method will separate the data into original blocks.</p>
	     *
	     * @param rawCodewords bytes as read directly from the QR Code
	     * @param version version of the QR Code
	     * @param ecLevel error-correction level of the QR Code
	     * @return DataBlocks containing original bytes, "de-interleaved" from representation in the
	     *         QR Code
	     */
	    DataBlock.getDataBlocks = function (rawCodewords, version, ecLevel) {
	        var e_1, _a, e_2, _b;
	        if (rawCodewords.length !== version.getTotalCodewords()) {
	            throw new IllegalArgumentException_1$1.default();
	        }
	        // Figure out the number and size of data blocks used by this version and
	        // error correction level
	        var ecBlocks = version.getECBlocksForLevel(ecLevel);
	        // First count the total number of data blocks
	        var totalBlocks = 0;
	        var ecBlockArray = ecBlocks.getECBlocks();
	        try {
	            for (var ecBlockArray_1 = __values$3(ecBlockArray), ecBlockArray_1_1 = ecBlockArray_1.next(); !ecBlockArray_1_1.done; ecBlockArray_1_1 = ecBlockArray_1.next()) {
	                var ecBlock = ecBlockArray_1_1.value;
	                totalBlocks += ecBlock.getCount();
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (ecBlockArray_1_1 && !ecBlockArray_1_1.done && (_a = ecBlockArray_1.return)) _a.call(ecBlockArray_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        // Now establish DataBlocks of the appropriate size and number of data codewords
	        var result = new Array(totalBlocks);
	        var numResultBlocks = 0;
	        try {
	            for (var ecBlockArray_2 = __values$3(ecBlockArray), ecBlockArray_2_1 = ecBlockArray_2.next(); !ecBlockArray_2_1.done; ecBlockArray_2_1 = ecBlockArray_2.next()) {
	                var ecBlock = ecBlockArray_2_1.value;
	                for (var i = 0; i < ecBlock.getCount(); i++) {
	                    var numDataCodewords = ecBlock.getDataCodewords();
	                    var numBlockCodewords = ecBlocks.getECCodewordsPerBlock() + numDataCodewords;
	                    result[numResultBlocks++] = new DataBlock(numDataCodewords, new Uint8Array(numBlockCodewords));
	                }
	            }
	        }
	        catch (e_2_1) { e_2 = { error: e_2_1 }; }
	        finally {
	            try {
	                if (ecBlockArray_2_1 && !ecBlockArray_2_1.done && (_b = ecBlockArray_2.return)) _b.call(ecBlockArray_2);
	            }
	            finally { if (e_2) throw e_2.error; }
	        }
	        // All blocks have the same amount of data, except that the last n
	        // (where n may be 0) have 1 more byte. Figure out where these start.
	        var shorterBlocksTotalCodewords = result[0].codewords.length;
	        var longerBlocksStartAt = result.length - 1;
	        // TYPESCRIPTPORT: check length is correct here
	        while (longerBlocksStartAt >= 0) {
	            var numCodewords = result[longerBlocksStartAt].codewords.length;
	            if (numCodewords === shorterBlocksTotalCodewords) {
	                break;
	            }
	            longerBlocksStartAt--;
	        }
	        longerBlocksStartAt++;
	        var shorterBlocksNumDataCodewords = shorterBlocksTotalCodewords - ecBlocks.getECCodewordsPerBlock();
	        // The last elements of result may be 1 element longer
	        // first fill out as many elements as all of them have
	        var rawCodewordsOffset = 0;
	        for (var i = 0; i < shorterBlocksNumDataCodewords; i++) {
	            for (var j = 0; j < numResultBlocks; j++) {
	                result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];
	            }
	        }
	        // Fill out the last data block in the longer ones
	        for (var j = longerBlocksStartAt; j < numResultBlocks; j++) {
	            result[j].codewords[shorterBlocksNumDataCodewords] = rawCodewords[rawCodewordsOffset++];
	        }
	        // Now add in error correction blocks
	        var max = result[0].codewords.length;
	        for (var i = shorterBlocksNumDataCodewords; i < max; i++) {
	            for (var j = 0; j < numResultBlocks; j++) {
	                var iOffset = j < longerBlocksStartAt ? i : i + 1;
	                result[j].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];
	            }
	        }
	        return result;
	    };
	    DataBlock.prototype.getNumDataCodewords = function () {
	        return this.numDataCodewords;
	    };
	    DataBlock.prototype.getCodewords = function () {
	        return this.codewords;
	    };
	    return DataBlock;
	}());
	DataBlock$1.default = DataBlock;

	var DecodedBitStreamParser$1 = {};

	var BitSource$1 = {};

	/*
	 * Copyright 2007 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(BitSource$1, "__esModule", { value: true });
	/*namespace com.google.zxing.common {*/
	var IllegalArgumentException_1 = IllegalArgumentException$1;
	/**
	 * <p>This provides an easy abstraction to read bits at a time from a sequence of bytes, where the
	 * number of bits read is not often a multiple of 8.</p>
	 *
	 * <p>This class is thread-safe but not reentrant -- unless the caller modifies the bytes array
	 * it passed in, in which case all bets are off.</p>
	 *
	 * @author Sean Owen
	 */
	var BitSource = /** @class */ (function () {
	    /**
	     * @param bytes bytes from which this will read bits. Bits will be read from the first byte first.
	     * Bits are read within a byte from most-significant to least-significant bit.
	     */
	    function BitSource(bytes) {
	        this.bytes = bytes;
	        this.byteOffset = 0;
	        this.bitOffset = 0;
	    }
	    /**
	     * @return index of next bit in current byte which would be read by the next call to {@link #readBits(int)}.
	     */
	    BitSource.prototype.getBitOffset = function () {
	        return this.bitOffset;
	    };
	    /**
	     * @return index of next byte in input byte array which would be read by the next call to {@link #readBits(int)}.
	     */
	    BitSource.prototype.getByteOffset = function () {
	        return this.byteOffset;
	    };
	    /**
	     * @param numBits number of bits to read
	     * @return int representing the bits read. The bits will appear as the least-significant
	     *         bits of the int
	     * @throws IllegalArgumentException if numBits isn't in [1,32] or more than is available
	     */
	    BitSource.prototype.readBits = function (numBits /*int*/) {
	        if (numBits < 1 || numBits > 32 || numBits > this.available()) {
	            throw new IllegalArgumentException_1.default('' + numBits);
	        }
	        var result = 0;
	        var bitOffset = this.bitOffset;
	        var byteOffset = this.byteOffset;
	        var bytes = this.bytes;
	        // First, read remainder from current byte
	        if (bitOffset > 0) {
	            var bitsLeft = 8 - bitOffset;
	            var toRead = numBits < bitsLeft ? numBits : bitsLeft;
	            var bitsToNotRead = bitsLeft - toRead;
	            var mask = (0xFF >> (8 - toRead)) << bitsToNotRead;
	            result = (bytes[byteOffset] & mask) >> bitsToNotRead;
	            numBits -= toRead;
	            bitOffset += toRead;
	            if (bitOffset === 8) {
	                bitOffset = 0;
	                byteOffset++;
	            }
	        }
	        // Next read whole bytes
	        if (numBits > 0) {
	            while (numBits >= 8) {
	                result = (result << 8) | (bytes[byteOffset] & 0xFF);
	                byteOffset++;
	                numBits -= 8;
	            }
	            // Finally read a partial byte
	            if (numBits > 0) {
	                var bitsToNotRead = 8 - numBits;
	                var mask = (0xFF >> bitsToNotRead) << bitsToNotRead;
	                result = (result << numBits) | ((bytes[byteOffset] & mask) >> bitsToNotRead);
	                bitOffset += numBits;
	            }
	        }
	        this.bitOffset = bitOffset;
	        this.byteOffset = byteOffset;
	        return result;
	    };
	    /**
	     * @return number of bits that can be read successfully
	     */
	    BitSource.prototype.available = function () {
	        return 8 * (this.bytes.length - this.byteOffset) - this.bitOffset;
	    };
	    return BitSource;
	}());
	BitSource$1.default = BitSource;

	var DecoderResult$1 = {};

	/*
	 * Copyright 2007 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(DecoderResult$1, "__esModule", { value: true });
	/*namespace com.google.zxing.common {*/
	/*import java.util.List;*/
	/**
	 * <p>Encapsulates the result of decoding a matrix of bits. This typically
	 * applies to 2D barcode formats. For now it contains the raw bytes obtained,
	 * as well as a String interpretation of those bytes, if applicable.</p>
	 *
	 * @author Sean Owen
	 */
	var DecoderResult = /** @class */ (function () {
	    // public constructor(rawBytes: Uint8Array,
	    //                      text: string,
	    //                      List<Uint8Array> byteSegments,
	    //                      String ecLevel) {
	    //   this(rawBytes, text, byteSegments, ecLevel, -1, -1)
	    // }
	    function DecoderResult(rawBytes, text, byteSegments, ecLevel, structuredAppendSequenceNumber, structuredAppendParity) {
	        if (structuredAppendSequenceNumber === void 0) { structuredAppendSequenceNumber = -1; }
	        if (structuredAppendParity === void 0) { structuredAppendParity = -1; }
	        this.rawBytes = rawBytes;
	        this.text = text;
	        this.byteSegments = byteSegments;
	        this.ecLevel = ecLevel;
	        this.structuredAppendSequenceNumber = structuredAppendSequenceNumber;
	        this.structuredAppendParity = structuredAppendParity;
	        this.numBits = (rawBytes === undefined || rawBytes === null) ? 0 : 8 * rawBytes.length;
	    }
	    /**
	     * @return raw bytes representing the result, or {@code null} if not applicable
	     */
	    DecoderResult.prototype.getRawBytes = function () {
	        return this.rawBytes;
	    };
	    /**
	     * @return how many bits of {@link #getRawBytes()} are valid; typically 8 times its length
	     * @since 3.3.0
	     */
	    DecoderResult.prototype.getNumBits = function () {
	        return this.numBits;
	    };
	    /**
	     * @param numBits overrides the number of bits that are valid in {@link #getRawBytes()}
	     * @since 3.3.0
	     */
	    DecoderResult.prototype.setNumBits = function (numBits /*int*/) {
	        this.numBits = numBits;
	    };
	    /**
	     * @return text representation of the result
	     */
	    DecoderResult.prototype.getText = function () {
	        return this.text;
	    };
	    /**
	     * @return list of byte segments in the result, or {@code null} if not applicable
	     */
	    DecoderResult.prototype.getByteSegments = function () {
	        return this.byteSegments;
	    };
	    /**
	     * @return name of error correction level used, or {@code null} if not applicable
	     */
	    DecoderResult.prototype.getECLevel = function () {
	        return this.ecLevel;
	    };
	    /**
	     * @return number of errors corrected, or {@code null} if not applicable
	     */
	    DecoderResult.prototype.getErrorsCorrected = function () {
	        return this.errorsCorrected;
	    };
	    DecoderResult.prototype.setErrorsCorrected = function (errorsCorrected /*Integer*/) {
	        this.errorsCorrected = errorsCorrected;
	    };
	    /**
	     * @return number of erasures corrected, or {@code null} if not applicable
	     */
	    DecoderResult.prototype.getErasures = function () {
	        return this.erasures;
	    };
	    DecoderResult.prototype.setErasures = function (erasures /*Integer*/) {
	        this.erasures = erasures;
	    };
	    /**
	     * @return arbitrary additional metadata
	     */
	    DecoderResult.prototype.getOther = function () {
	        return this.other;
	    };
	    DecoderResult.prototype.setOther = function (other) {
	        this.other = other;
	    };
	    DecoderResult.prototype.hasStructuredAppend = function () {
	        return this.structuredAppendParity >= 0 && this.structuredAppendSequenceNumber >= 0;
	    };
	    DecoderResult.prototype.getStructuredAppendParity = function () {
	        return this.structuredAppendParity;
	    };
	    DecoderResult.prototype.getStructuredAppendSequenceNumber = function () {
	        return this.structuredAppendSequenceNumber;
	    };
	    return DecoderResult;
	}());
	DecoderResult$1.default = DecoderResult;

	var Mode = {};

	(function (exports) {
	/*
	 * Copyright 2007 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ModeValues = void 0;
	var IllegalArgumentException_1 = IllegalArgumentException$1;
	var ModeValues;
	(function (ModeValues) {
	    ModeValues[ModeValues["TERMINATOR"] = 0] = "TERMINATOR";
	    ModeValues[ModeValues["NUMERIC"] = 1] = "NUMERIC";
	    ModeValues[ModeValues["ALPHANUMERIC"] = 2] = "ALPHANUMERIC";
	    ModeValues[ModeValues["STRUCTURED_APPEND"] = 3] = "STRUCTURED_APPEND";
	    ModeValues[ModeValues["BYTE"] = 4] = "BYTE";
	    ModeValues[ModeValues["ECI"] = 5] = "ECI";
	    ModeValues[ModeValues["KANJI"] = 6] = "KANJI";
	    ModeValues[ModeValues["FNC1_FIRST_POSITION"] = 7] = "FNC1_FIRST_POSITION";
	    ModeValues[ModeValues["FNC1_SECOND_POSITION"] = 8] = "FNC1_SECOND_POSITION";
	    /** See GBT 18284-2000; "Hanzi" is a transliteration of this mode name. */
	    ModeValues[ModeValues["HANZI"] = 9] = "HANZI";
	})(ModeValues = exports.ModeValues || (exports.ModeValues = {}));
	/**
	 * <p>See ISO 18004:2006, 6.4.1, Tables 2 and 3. This enum encapsulates the various modes in which
	 * data can be encoded to bits in the QR code standard.</p>
	 *
	 * @author Sean Owen
	 */
	var Mode = /** @class */ (function () {
	    function Mode(value, stringValue, characterCountBitsForVersions, bits /*int*/) {
	        this.value = value;
	        this.stringValue = stringValue;
	        this.characterCountBitsForVersions = characterCountBitsForVersions;
	        this.bits = bits;
	        Mode.FOR_BITS.set(bits, this);
	        Mode.FOR_VALUE.set(value, this);
	    }
	    /**
	     * @param bits four bits encoding a QR Code data mode
	     * @return Mode encoded by these bits
	     * @throws IllegalArgumentException if bits do not correspond to a known mode
	     */
	    Mode.forBits = function (bits /*int*/) {
	        var mode = Mode.FOR_BITS.get(bits);
	        if (undefined === mode) {
	            throw new IllegalArgumentException_1.default();
	        }
	        return mode;
	    };
	    /**
	     * @param version version in question
	     * @return number of bits used, in this QR Code symbol {@link Version}, to encode the
	     *         count of characters that will follow encoded in this Mode
	     */
	    Mode.prototype.getCharacterCountBits = function (version) {
	        var versionNumber = version.getVersionNumber();
	        var offset;
	        if (versionNumber <= 9) {
	            offset = 0;
	        }
	        else if (versionNumber <= 26) {
	            offset = 1;
	        }
	        else {
	            offset = 2;
	        }
	        return this.characterCountBitsForVersions[offset];
	    };
	    Mode.prototype.getValue = function () {
	        return this.value;
	    };
	    Mode.prototype.getBits = function () {
	        return this.bits;
	    };
	    Mode.prototype.equals = function (o) {
	        if (!(o instanceof Mode)) {
	            return false;
	        }
	        var other = o;
	        return this.value === other.value;
	    };
	    Mode.prototype.toString = function () {
	        return this.stringValue;
	    };
	    Mode.FOR_BITS = new Map();
	    Mode.FOR_VALUE = new Map();
	    Mode.TERMINATOR = new Mode(ModeValues.TERMINATOR, 'TERMINATOR', Int32Array.from([0, 0, 0]), 0x00); // Not really a mode...
	    Mode.NUMERIC = new Mode(ModeValues.NUMERIC, 'NUMERIC', Int32Array.from([10, 12, 14]), 0x01);
	    Mode.ALPHANUMERIC = new Mode(ModeValues.ALPHANUMERIC, 'ALPHANUMERIC', Int32Array.from([9, 11, 13]), 0x02);
	    Mode.STRUCTURED_APPEND = new Mode(ModeValues.STRUCTURED_APPEND, 'STRUCTURED_APPEND', Int32Array.from([0, 0, 0]), 0x03); // Not supported
	    Mode.BYTE = new Mode(ModeValues.BYTE, 'BYTE', Int32Array.from([8, 16, 16]), 0x04);
	    Mode.ECI = new Mode(ModeValues.ECI, 'ECI', Int32Array.from([0, 0, 0]), 0x07); // character counts don't apply
	    Mode.KANJI = new Mode(ModeValues.KANJI, 'KANJI', Int32Array.from([8, 10, 12]), 0x08);
	    Mode.FNC1_FIRST_POSITION = new Mode(ModeValues.FNC1_FIRST_POSITION, 'FNC1_FIRST_POSITION', Int32Array.from([0, 0, 0]), 0x05);
	    Mode.FNC1_SECOND_POSITION = new Mode(ModeValues.FNC1_SECOND_POSITION, 'FNC1_SECOND_POSITION', Int32Array.from([0, 0, 0]), 0x09);
	    /** See GBT 18284-2000; "Hanzi" is a transliteration of this mode name. */
	    Mode.HANZI = new Mode(ModeValues.HANZI, 'HANZI', Int32Array.from([8, 10, 12]), 0x0D);
	    return Mode;
	}());
	exports.default = Mode;

	}(Mode));

	/*
	 * Copyright 2007 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(DecodedBitStreamParser$1, "__esModule", { value: true });
	/*namespace com.google.zxing.qrcode.decoder {*/
	var BitSource_1 = BitSource$1;
	var CharacterSetECI_1 = CharacterSetECI;
	var DecoderResult_1 = DecoderResult$1;
	var StringUtils_1 = StringUtils$1;
	var FormatException_1 = FormatException$1;
	var StringBuilder_1 = StringBuilder$1;
	var StringEncoding_1 = StringEncoding$1;
	var Mode_1 = Mode;
	/*import java.io.UnsupportedEncodingException;*/
	/*import java.util.ArrayList;*/
	/*import java.util.Collection;*/
	/*import java.util.List;*/
	/*import java.util.Map;*/
	/**
	 * <p>QR Codes can encode text as bits in one of several modes, and can use multiple modes
	 * in one QR Code. This class decodes the bits back into text.</p>
	 *
	 * <p>See ISO 18004:2006, 6.4.3 - 6.4.7</p>
	 *
	 * @author Sean Owen
	 */
	var DecodedBitStreamParser = /** @class */ (function () {
	    function DecodedBitStreamParser() {
	    }
	    DecodedBitStreamParser.decode = function (bytes, version, ecLevel, hints) {
	        var bits = new BitSource_1.default(bytes);
	        var result = new StringBuilder_1.default();
	        var byteSegments = new Array(); // 1
	        // TYPESCRIPTPORT: I do not use constructor with size 1 as in original Java means capacity and the array length is checked below
	        var symbolSequence = -1;
	        var parityData = -1;
	        try {
	            var currentCharacterSetECI = null;
	            var fc1InEffect = false;
	            var mode = void 0;
	            do {
	                // While still another segment to read...
	                if (bits.available() < 4) {
	                    // OK, assume we're done. Really, a TERMINATOR mode should have been recorded here
	                    mode = Mode_1.default.TERMINATOR;
	                }
	                else {
	                    var modeBits = bits.readBits(4);
	                    mode = Mode_1.default.forBits(modeBits); // mode is encoded by 4 bits
	                }
	                switch (mode) {
	                    case Mode_1.default.TERMINATOR:
	                        break;
	                    case Mode_1.default.FNC1_FIRST_POSITION:
	                    case Mode_1.default.FNC1_SECOND_POSITION:
	                        // We do little with FNC1 except alter the parsed result a bit according to the spec
	                        fc1InEffect = true;
	                        break;
	                    case Mode_1.default.STRUCTURED_APPEND:
	                        if (bits.available() < 16) {
	                            throw new FormatException_1.default();
	                        }
	                        // sequence number and parity is added later to the result metadata
	                        // Read next 8 bits (symbol sequence #) and 8 bits (data: parity), then continue
	                        symbolSequence = bits.readBits(8);
	                        parityData = bits.readBits(8);
	                        break;
	                    case Mode_1.default.ECI:
	                        // Count doesn't apply to ECI
	                        var value = DecodedBitStreamParser.parseECIValue(bits);
	                        currentCharacterSetECI = CharacterSetECI_1.default.getCharacterSetECIByValue(value);
	                        if (currentCharacterSetECI === null) {
	                            throw new FormatException_1.default();
	                        }
	                        break;
	                    case Mode_1.default.HANZI:
	                        // First handle Hanzi mode which does not start with character count
	                        // Chinese mode contains a sub set indicator right after mode indicator
	                        var subset = bits.readBits(4);
	                        var countHanzi = bits.readBits(mode.getCharacterCountBits(version));
	                        if (subset === DecodedBitStreamParser.GB2312_SUBSET) {
	                            DecodedBitStreamParser.decodeHanziSegment(bits, result, countHanzi);
	                        }
	                        break;
	                    default:
	                        // "Normal" QR code modes:
	                        // How many characters will follow, encoded in this mode?
	                        var count = bits.readBits(mode.getCharacterCountBits(version));
	                        switch (mode) {
	                            case Mode_1.default.NUMERIC:
	                                DecodedBitStreamParser.decodeNumericSegment(bits, result, count);
	                                break;
	                            case Mode_1.default.ALPHANUMERIC:
	                                DecodedBitStreamParser.decodeAlphanumericSegment(bits, result, count, fc1InEffect);
	                                break;
	                            case Mode_1.default.BYTE:
	                                DecodedBitStreamParser.decodeByteSegment(bits, result, count, currentCharacterSetECI, byteSegments, hints);
	                                break;
	                            case Mode_1.default.KANJI:
	                                DecodedBitStreamParser.decodeKanjiSegment(bits, result, count);
	                                break;
	                            default:
	                                throw new FormatException_1.default();
	                        }
	                        break;
	                }
	            } while (mode !== Mode_1.default.TERMINATOR);
	        }
	        catch (iae /*: IllegalArgumentException*/) {
	            // from readBits() calls
	            throw new FormatException_1.default();
	        }
	        return new DecoderResult_1.default(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, ecLevel === null ? null : ecLevel.toString(), symbolSequence, parityData);
	    };
	    /**
	     * See specification GBT 18284-2000
	     */
	    DecodedBitStreamParser.decodeHanziSegment = function (bits, result, count /*int*/) {
	        // Don't crash trying to read more bits than we have available.
	        if (count * 13 > bits.available()) {
	            throw new FormatException_1.default();
	        }
	        // Each character will require 2 bytes. Read the characters as 2-byte pairs
	        // and decode as GB2312 afterwards
	        var buffer = new Uint8Array(2 * count);
	        var offset = 0;
	        while (count > 0) {
	            // Each 13 bits encodes a 2-byte character
	            var twoBytes = bits.readBits(13);
	            var assembledTwoBytes = (((twoBytes / 0x060) << 8) & 0xFFFFFFFF) | (twoBytes % 0x060);
	            if (assembledTwoBytes < 0x003BF) {
	                // In the 0xA1A1 to 0xAAFE range
	                assembledTwoBytes += 0x0A1A1;
	            }
	            else {
	                // In the 0xB0A1 to 0xFAFE range
	                assembledTwoBytes += 0x0A6A1;
	            }
	            buffer[offset] = /*(byte) */ ((assembledTwoBytes >> 8) & 0xFF);
	            buffer[offset + 1] = /*(byte) */ (assembledTwoBytes & 0xFF);
	            offset += 2;
	            count--;
	        }
	        try {
	            result.append(StringEncoding_1.default.decode(buffer, StringUtils_1.default.GB2312));
	            // TYPESCRIPTPORT: TODO: implement GB2312 decode. StringView from MDN could be a starting point
	        }
	        catch (ignored /*: UnsupportedEncodingException*/) {
	            throw new FormatException_1.default(ignored);
	        }
	    };
	    DecodedBitStreamParser.decodeKanjiSegment = function (bits, result, count /*int*/) {
	        // Don't crash trying to read more bits than we have available.
	        if (count * 13 > bits.available()) {
	            throw new FormatException_1.default();
	        }
	        // Each character will require 2 bytes. Read the characters as 2-byte pairs
	        // and decode as Shift_JIS afterwards
	        var buffer = new Uint8Array(2 * count);
	        var offset = 0;
	        while (count > 0) {
	            // Each 13 bits encodes a 2-byte character
	            var twoBytes = bits.readBits(13);
	            var assembledTwoBytes = (((twoBytes / 0x0C0) << 8) & 0xFFFFFFFF) | (twoBytes % 0x0C0);
	            if (assembledTwoBytes < 0x01F00) {
	                // In the 0x8140 to 0x9FFC range
	                assembledTwoBytes += 0x08140;
	            }
	            else {
	                // In the 0xE040 to 0xEBBF range
	                assembledTwoBytes += 0x0C140;
	            }
	            buffer[offset] = /*(byte) */ (assembledTwoBytes >> 8);
	            buffer[offset + 1] = /*(byte) */ assembledTwoBytes;
	            offset += 2;
	            count--;
	        }
	        // Shift_JIS may not be supported in some environments:
	        try {
	            result.append(StringEncoding_1.default.decode(buffer, StringUtils_1.default.SHIFT_JIS));
	            // TYPESCRIPTPORT: TODO: implement SHIFT_JIS decode. StringView from MDN could be a starting point
	        }
	        catch (ignored /*: UnsupportedEncodingException*/) {
	            throw new FormatException_1.default(ignored);
	        }
	    };
	    DecodedBitStreamParser.decodeByteSegment = function (bits, result, count /*int*/, currentCharacterSetECI, byteSegments, hints) {
	        // Don't crash trying to read more bits than we have available.
	        if (8 * count > bits.available()) {
	            throw new FormatException_1.default();
	        }
	        var readBytes = new Uint8Array(count);
	        for (var i = 0; i < count; i++) {
	            readBytes[i] = /*(byte) */ bits.readBits(8);
	        }
	        var encoding;
	        if (currentCharacterSetECI === null) {
	            // The spec isn't clear on this mode; see
	            // section 6.4.5: t does not say which encoding to assuming
	            // upon decoding. I have seen ISO-8859-1 used as well as
	            // Shift_JIS -- without anything like an ECI designator to
	            // give a hint.
	            encoding = StringUtils_1.default.guessEncoding(readBytes, hints);
	        }
	        else {
	            encoding = currentCharacterSetECI.getName();
	        }
	        try {
	            result.append(StringEncoding_1.default.decode(readBytes, encoding));
	        }
	        catch (ignored /*: UnsupportedEncodingException*/) {
	            throw new FormatException_1.default(ignored);
	        }
	        byteSegments.push(readBytes);
	    };
	    DecodedBitStreamParser.toAlphaNumericChar = function (value /*int*/) {
	        if (value >= DecodedBitStreamParser.ALPHANUMERIC_CHARS.length) {
	            throw new FormatException_1.default();
	        }
	        return DecodedBitStreamParser.ALPHANUMERIC_CHARS[value];
	    };
	    DecodedBitStreamParser.decodeAlphanumericSegment = function (bits, result, count /*int*/, fc1InEffect) {
	        // Read two characters at a time
	        var start = result.length();
	        while (count > 1) {
	            if (bits.available() < 11) {
	                throw new FormatException_1.default();
	            }
	            var nextTwoCharsBits = bits.readBits(11);
	            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(nextTwoCharsBits / 45)));
	            result.append(DecodedBitStreamParser.toAlphaNumericChar(nextTwoCharsBits % 45));
	            count -= 2;
	        }
	        if (count === 1) {
	            // special case: one character left
	            if (bits.available() < 6) {
	                throw new FormatException_1.default();
	            }
	            result.append(DecodedBitStreamParser.toAlphaNumericChar(bits.readBits(6)));
	        }
	        // See section 6.4.8.1, 6.4.8.2
	        if (fc1InEffect) {
	            // We need to massage the result a bit if in an FNC1 mode:
	            for (var i = start; i < result.length(); i++) {
	                if (result.charAt(i) === '%') {
	                    if (i < result.length() - 1 && result.charAt(i + 1) === '%') {
	                        // %% is rendered as %
	                        result.deleteCharAt(i + 1);
	                    }
	                    else {
	                        // In alpha mode, % should be converted to FNC1 separator 0x1D
	                        result.setCharAt(i, String.fromCharCode(0x1D));
	                    }
	                }
	            }
	        }
	    };
	    DecodedBitStreamParser.decodeNumericSegment = function (bits, result, count /*int*/) {
	        // Read three digits at a time
	        while (count >= 3) {
	            // Each 10 bits encodes three digits
	            if (bits.available() < 10) {
	                throw new FormatException_1.default();
	            }
	            var threeDigitsBits = bits.readBits(10);
	            if (threeDigitsBits >= 1000) {
	                throw new FormatException_1.default();
	            }
	            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(threeDigitsBits / 100)));
	            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(threeDigitsBits / 10) % 10));
	            result.append(DecodedBitStreamParser.toAlphaNumericChar(threeDigitsBits % 10));
	            count -= 3;
	        }
	        if (count === 2) {
	            // Two digits left over to read, encoded in 7 bits
	            if (bits.available() < 7) {
	                throw new FormatException_1.default();
	            }
	            var twoDigitsBits = bits.readBits(7);
	            if (twoDigitsBits >= 100) {
	                throw new FormatException_1.default();
	            }
	            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(twoDigitsBits / 10)));
	            result.append(DecodedBitStreamParser.toAlphaNumericChar(twoDigitsBits % 10));
	        }
	        else if (count === 1) {
	            // One digit left over to read
	            if (bits.available() < 4) {
	                throw new FormatException_1.default();
	            }
	            var digitBits = bits.readBits(4);
	            if (digitBits >= 10) {
	                throw new FormatException_1.default();
	            }
	            result.append(DecodedBitStreamParser.toAlphaNumericChar(digitBits));
	        }
	    };
	    DecodedBitStreamParser.parseECIValue = function (bits) {
	        var firstByte = bits.readBits(8);
	        if ((firstByte & 0x80) === 0) {
	            // just one byte
	            return firstByte & 0x7F;
	        }
	        if ((firstByte & 0xC0) === 0x80) {
	            // two bytes
	            var secondByte = bits.readBits(8);
	            return (((firstByte & 0x3F) << 8) & 0xFFFFFFFF) | secondByte;
	        }
	        if ((firstByte & 0xE0) === 0xC0) {
	            // three bytes
	            var secondThirdBytes = bits.readBits(16);
	            return (((firstByte & 0x1F) << 16) & 0xFFFFFFFF) | secondThirdBytes;
	        }
	        throw new FormatException_1.default();
	    };
	    /**
	     * See ISO 18004:2006, 6.4.4 Table 5
	     */
	    DecodedBitStreamParser.ALPHANUMERIC_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:';
	    DecodedBitStreamParser.GB2312_SUBSET = 1;
	    return DecodedBitStreamParser;
	}());
	DecodedBitStreamParser$1.default = DecodedBitStreamParser;

	var QRCodeDecoderMetaData$1 = {};

	/*
	 * Copyright 2013 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(QRCodeDecoderMetaData$1, "__esModule", { value: true });
	/**
	 * Meta-data container for QR Code decoding. Instances of this class may be used to convey information back to the
	 * decoding caller. Callers are expected to process this.
	 *
	 * @see com.google.zxing.common.DecoderResult#getOther()
	 */
	var QRCodeDecoderMetaData = /** @class */ (function () {
	    function QRCodeDecoderMetaData(mirrored) {
	        this.mirrored = mirrored;
	    }
	    /**
	     * @return true if the QR Code was mirrored.
	     */
	    QRCodeDecoderMetaData.prototype.isMirrored = function () {
	        return this.mirrored;
	    };
	    /**
	     * Apply the result points' order correction due to mirroring.
	     *
	     * @param points Array of points to apply mirror correction to.
	     */
	    QRCodeDecoderMetaData.prototype.applyMirroredCorrection = function (points) {
	        if (!this.mirrored || points === null || points.length < 3) {
	            return;
	        }
	        var bottomLeft = points[0];
	        points[0] = points[2];
	        points[2] = bottomLeft;
	        // No need to 'fix' top-left and alignment pattern.
	    };
	    return QRCodeDecoderMetaData;
	}());
	QRCodeDecoderMetaData$1.default = QRCodeDecoderMetaData;

	/*
	 * Copyright 2007 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __values$2 = (commonjsGlobal && commonjsGlobal.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(Decoder$1, "__esModule", { value: true });
	/*namespace com.google.zxing.qrcode.decoder {*/
	var ChecksumException_1 = ChecksumException$1;
	var BitMatrix_1$2 = BitMatrix$1;
	var GenericGF_1 = GenericGF$1;
	var ReedSolomonDecoder_1 = ReedSolomonDecoder$1;
	var BitMatrixParser_1 = BitMatrixParser$1;
	var DataBlock_1 = DataBlock$1;
	var DecodedBitStreamParser_1 = DecodedBitStreamParser$1;
	var QRCodeDecoderMetaData_1$1 = QRCodeDecoderMetaData$1;
	/*import java.util.Map;*/
	/**
	 * <p>The main class which implements QR Code decoding -- as opposed to locating and extracting
	 * the QR Code from an image.</p>
	 *
	 * @author Sean Owen
	 */
	var Decoder = /** @class */ (function () {
	    function Decoder() {
	        this.rsDecoder = new ReedSolomonDecoder_1.default(GenericGF_1.default.QR_CODE_FIELD_256);
	    }
	    // public decode(image: boolean[][]): DecoderResult /*throws ChecksumException, FormatException*/ {
	    //   return decode(image, null)
	    // }
	    /**
	     * <p>Convenience method that can decode a QR Code represented as a 2D array of booleans.
	     * "true" is taken to mean a black module.</p>
	     *
	     * @param image booleans representing white/black QR Code modules
	     * @param hints decoding hints that should be used to influence decoding
	     * @return text and bytes encoded within the QR Code
	     * @throws FormatException if the QR Code cannot be decoded
	     * @throws ChecksumException if error correction fails
	     */
	    Decoder.prototype.decodeBooleanArray = function (image, hints) {
	        return this.decodeBitMatrix(BitMatrix_1$2.default.parseFromBooleanArray(image), hints);
	    };
	    // public decodeBitMatrix(bits: BitMatrix): DecoderResult /*throws ChecksumException, FormatException*/ {
	    //   return decode(bits, null)
	    // }
	    /**
	     * <p>Decodes a QR Code represented as a {@link BitMatrix}. A 1 or "true" is taken to mean a black module.</p>
	     *
	     * @param bits booleans representing white/black QR Code modules
	     * @param hints decoding hints that should be used to influence decoding
	     * @return text and bytes encoded within the QR Code
	     * @throws FormatException if the QR Code cannot be decoded
	     * @throws ChecksumException if error correction fails
	     */
	    Decoder.prototype.decodeBitMatrix = function (bits, hints) {
	        // Construct a parser and read version, error-correction level
	        var parser = new BitMatrixParser_1.default(bits);
	        var ex = null;
	        try {
	            return this.decodeBitMatrixParser(parser, hints);
	        }
	        catch (e /*: FormatException, ChecksumException*/) {
	            ex = e;
	        }
	        try {
	            // Revert the bit matrix
	            parser.remask();
	            // Will be attempting a mirrored reading of the version and format info.
	            parser.setMirror(true);
	            // Preemptively read the version.
	            parser.readVersion();
	            // Preemptively read the format information.
	            parser.readFormatInformation();
	            /*
	             * Since we're here, this means we have successfully detected some kind
	             * of version and format information when mirrored. This is a good sign,
	             * that the QR code may be mirrored, and we should try once more with a
	             * mirrored content.
	             */
	            // Prepare for a mirrored reading.
	            parser.mirror();
	            var result = this.decodeBitMatrixParser(parser, hints);
	            // Success! Notify the caller that the code was mirrored.
	            result.setOther(new QRCodeDecoderMetaData_1$1.default(true));
	            return result;
	        }
	        catch (e /*FormatException | ChecksumException*/) {
	            // Throw the exception from the original reading
	            if (ex !== null) {
	                throw ex;
	            }
	            throw e;
	        }
	    };
	    Decoder.prototype.decodeBitMatrixParser = function (parser, hints) {
	        var e_1, _a, e_2, _b;
	        var version = parser.readVersion();
	        var ecLevel = parser.readFormatInformation().getErrorCorrectionLevel();
	        // Read codewords
	        var codewords = parser.readCodewords();
	        // Separate into data blocks
	        var dataBlocks = DataBlock_1.default.getDataBlocks(codewords, version, ecLevel);
	        // Count total number of data bytes
	        var totalBytes = 0;
	        try {
	            for (var dataBlocks_1 = __values$2(dataBlocks), dataBlocks_1_1 = dataBlocks_1.next(); !dataBlocks_1_1.done; dataBlocks_1_1 = dataBlocks_1.next()) {
	                var dataBlock = dataBlocks_1_1.value;
	                totalBytes += dataBlock.getNumDataCodewords();
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (dataBlocks_1_1 && !dataBlocks_1_1.done && (_a = dataBlocks_1.return)) _a.call(dataBlocks_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        var resultBytes = new Uint8Array(totalBytes);
	        var resultOffset = 0;
	        try {
	            // Error-correct and copy data blocks together into a stream of bytes
	            for (var dataBlocks_2 = __values$2(dataBlocks), dataBlocks_2_1 = dataBlocks_2.next(); !dataBlocks_2_1.done; dataBlocks_2_1 = dataBlocks_2.next()) {
	                var dataBlock = dataBlocks_2_1.value;
	                var codewordBytes = dataBlock.getCodewords();
	                var numDataCodewords = dataBlock.getNumDataCodewords();
	                this.correctErrors(codewordBytes, numDataCodewords);
	                for (var i = 0; i < numDataCodewords; i++) {
	                    resultBytes[resultOffset++] = codewordBytes[i];
	                }
	            }
	        }
	        catch (e_2_1) { e_2 = { error: e_2_1 }; }
	        finally {
	            try {
	                if (dataBlocks_2_1 && !dataBlocks_2_1.done && (_b = dataBlocks_2.return)) _b.call(dataBlocks_2);
	            }
	            finally { if (e_2) throw e_2.error; }
	        }
	        // Decode the contents of that stream of bytes
	        return DecodedBitStreamParser_1.default.decode(resultBytes, version, ecLevel, hints);
	    };
	    /**
	     * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to
	     * correct the errors in-place using Reed-Solomon error correction.</p>
	     *
	     * @param codewordBytes data and error correction codewords
	     * @param numDataCodewords number of codewords that are data bytes
	     * @throws ChecksumException if error correction fails
	     */
	    Decoder.prototype.correctErrors = function (codewordBytes, numDataCodewords /*int*/) {
	        // const numCodewords = codewordBytes.length;
	        // First read into an array of ints
	        var codewordsInts = new Int32Array(codewordBytes);
	        // TYPESCRIPTPORT: not realy necessary to transform to ints? could redesign everything to work with unsigned bytes?
	        // const codewordsInts = new Int32Array(numCodewords)
	        // for (let i = 0; i < numCodewords; i++) {
	        //   codewordsInts[i] = codewordBytes[i] & 0xFF
	        // }
	        try {
	            this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);
	        }
	        catch (ignored /*: ReedSolomonException*/) {
	            throw new ChecksumException_1.default();
	        }
	        // Copy back into array of bytes -- only need to worry about the bytes that were data
	        // We don't care about errors in the error-correction codewords
	        for (var i = 0; i < numDataCodewords; i++) {
	            codewordBytes[i] = /*(byte) */ codewordsInts[i];
	        }
	    };
	    return Decoder;
	}());
	Decoder$1.default = Decoder;

	var Detector$1 = {};

	var MathUtils$1 = {};

	/*
	 * Copyright 2012 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(MathUtils$1, "__esModule", { value: true });
	/*namespace com.google.zxing.common.detector {*/
	/**
	 * General math-related and numeric utility functions.
	 */
	var MathUtils = /** @class */ (function () {
	    function MathUtils() {
	    }
	    /**
	     * Ends up being a bit faster than {@link Math#round(float)}. This merely rounds its
	     * argument to the nearest int, where x.5 rounds up to x+1. Semantics of this shortcut
	     * differ slightly from {@link Math#round(float)} in that half rounds down for negative
	     * values. -2.5 rounds to -3, not -2. For purposes here it makes no difference.
	     *
	     * @param d real value to round
	     * @return nearest {@code int}
	     */
	    MathUtils.round = function (d /*float*/) {
	        if (NaN === d)
	            return 0;
	        if (d <= Number.MIN_SAFE_INTEGER)
	            return Number.MIN_SAFE_INTEGER;
	        if (d >= Number.MAX_SAFE_INTEGER)
	            return Number.MAX_SAFE_INTEGER;
	        return /*(int) */ (d + (d < 0.0 ? -0.5 : 0.5)) | 0;
	    };
	    // TYPESCRIPTPORT: maybe remove round method and call directly Math.round, it looks like it doesn't make sense for js
	    /**
	     * @param aX point A x coordinate
	     * @param aY point A y coordinate
	     * @param bX point B x coordinate
	     * @param bY point B y coordinate
	     * @return Euclidean distance between points A and B
	     */
	    MathUtils.distance = function (aX /*float|int*/, aY /*float|int*/, bX /*float|int*/, bY /*float|int*/) {
	        var xDiff = aX - bX;
	        var yDiff = aY - bY;
	        return /*(float) */ Math.sqrt(xDiff * xDiff + yDiff * yDiff);
	    };
	    /**
	     * @param aX point A x coordinate
	     * @param aY point A y coordinate
	     * @param bX point B x coordinate
	     * @param bY point B y coordinate
	     * @return Euclidean distance between points A and B
	     */
	    // public static distance(aX: number /*int*/, aY: number /*int*/, bX: number /*int*/, bY: number /*int*/): float {
	    //   const xDiff = aX - bX
	    //   const yDiff = aY - bY
	    //   return (float) Math.sqrt(xDiff * xDiff + yDiff * yDiff);
	    // }
	    /**
	     * @param array values to sum
	     * @return sum of values in array
	     */
	    MathUtils.sum = function (array) {
	        var count = 0;
	        for (var i = 0, length_1 = array.length; i !== length_1; i++) {
	            var a = array[i];
	            count += a;
	        }
	        return count;
	    };
	    return MathUtils;
	}());
	MathUtils$1.default = MathUtils;

	var DetectorResult$1 = {};

	/*
	 * Copyright 2007 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(DetectorResult$1, "__esModule", { value: true });
	/**
	 * <p>Encapsulates the result of detecting a barcode in an image. This includes the raw
	 * matrix of black/white pixels corresponding to the barcode, and possibly points of interest
	 * in the image, like the location of finder patterns or corners of the barcode in the image.</p>
	 *
	 * @author Sean Owen
	 */
	var DetectorResult = /** @class */ (function () {
	    function DetectorResult(bits, points) {
	        this.bits = bits;
	        this.points = points;
	    }
	    DetectorResult.prototype.getBits = function () {
	        return this.bits;
	    };
	    DetectorResult.prototype.getPoints = function () {
	        return this.points;
	    };
	    return DetectorResult;
	}());
	DetectorResult$1.default = DetectorResult;

	var GridSamplerInstance$1 = {};

	var DefaultGridSampler$1 = {};

	var GridSampler$1 = {};

	/*
	 * Copyright 2007 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(GridSampler$1, "__esModule", { value: true });
	var NotFoundException_1$5 = NotFoundException$1;
	/**
	 * Implementations of this class can, given locations of finder patterns for a QR code in an
	 * image, sample the right points in the image to reconstruct the QR code, accounting for
	 * perspective distortion. It is abstracted since it is relatively expensive and should be allowed
	 * to take advantage of platform-specific optimized implementations, like Sun's Java Advanced
	 * Imaging library, but which may not be available in other environments such as J2ME, and vice
	 * versa.
	 *
	 * The implementation used can be controlled by calling {@link #setGridSampler(GridSampler)}
	 * with an instance of a class which implements this interface.
	 *
	 * @author Sean Owen
	 */
	var GridSampler = /** @class */ (function () {
	    function GridSampler() {
	    }
	    /**
	     * <p>Checks a set of points that have been transformed to sample points on an image against
	     * the image's dimensions to see if the point are even within the image.</p>
	     *
	     * <p>This method will actually "nudge" the endpoints back onto the image if they are found to be
	     * barely (less than 1 pixel) off the image. This accounts for imperfect detection of finder
	     * patterns in an image where the QR Code runs all the way to the image border.</p>
	     *
	     * <p>For efficiency, the method will check points from either end of the line until one is found
	     * to be within the image. Because the set of points are assumed to be linear, this is valid.</p>
	     *
	     * @param image image into which the points should map
	     * @param points actual points in x1,y1,...,xn,yn form
	     * @throws NotFoundException if an endpoint is lies outside the image boundaries
	     */
	    GridSampler.checkAndNudgePoints = function (image, points) {
	        var width = image.getWidth();
	        var height = image.getHeight();
	        // Check and nudge points from start until we see some that are OK:
	        var nudged = true;
	        for (var offset = 0; offset < points.length && nudged; offset += 2) {
	            var x = Math.floor(points[offset]);
	            var y = Math.floor(points[offset + 1]);
	            if (x < -1 || x > width || y < -1 || y > height) {
	                throw new NotFoundException_1$5.default();
	            }
	            nudged = false;
	            if (x === -1) {
	                points[offset] = 0.0;
	                nudged = true;
	            }
	            else if (x === width) {
	                points[offset] = width - 1;
	                nudged = true;
	            }
	            if (y === -1) {
	                points[offset + 1] = 0.0;
	                nudged = true;
	            }
	            else if (y === height) {
	                points[offset + 1] = height - 1;
	                nudged = true;
	            }
	        }
	        // Check and nudge points from end:
	        nudged = true;
	        for (var offset = points.length - 2; offset >= 0 && nudged; offset -= 2) {
	            var x = Math.floor(points[offset]);
	            var y = Math.floor(points[offset + 1]);
	            if (x < -1 || x > width || y < -1 || y > height) {
	                throw new NotFoundException_1$5.default();
	            }
	            nudged = false;
	            if (x === -1) {
	                points[offset] = 0.0;
	                nudged = true;
	            }
	            else if (x === width) {
	                points[offset] = width - 1;
	                nudged = true;
	            }
	            if (y === -1) {
	                points[offset + 1] = 0.0;
	                nudged = true;
	            }
	            else if (y === height) {
	                points[offset + 1] = height - 1;
	                nudged = true;
	            }
	        }
	    };
	    return GridSampler;
	}());
	GridSampler$1.default = GridSampler;

	var PerspectiveTransform$1 = {};

	/*
	 * Copyright 2007 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(PerspectiveTransform$1, "__esModule", { value: true });
	/*namespace com.google.zxing.common {*/
	/**
	 * <p>This class implements a perspective transform in two dimensions. Given four source and four
	 * destination points, it will compute the transformation implied between them. The code is based
	 * directly upon section 3.4.2 of George Wolberg's "Digital Image Warping"; see pages 54-56.</p>
	 *
	 * @author Sean Owen
	 */
	var PerspectiveTransform = /** @class */ (function () {
	    function PerspectiveTransform(a11 /*float*/, a21 /*float*/, a31 /*float*/, a12 /*float*/, a22 /*float*/, a32 /*float*/, a13 /*float*/, a23 /*float*/, a33 /*float*/) {
	        this.a11 = a11;
	        this.a21 = a21;
	        this.a31 = a31;
	        this.a12 = a12;
	        this.a22 = a22;
	        this.a32 = a32;
	        this.a13 = a13;
	        this.a23 = a23;
	        this.a33 = a33;
	    }
	    PerspectiveTransform.quadrilateralToQuadrilateral = function (x0 /*float*/, y0 /*float*/, x1 /*float*/, y1 /*float*/, x2 /*float*/, y2 /*float*/, x3 /*float*/, y3 /*float*/, x0p /*float*/, y0p /*float*/, x1p /*float*/, y1p /*float*/, x2p /*float*/, y2p /*float*/, x3p /*float*/, y3p /*float*/) {
	        var qToS = PerspectiveTransform.quadrilateralToSquare(x0, y0, x1, y1, x2, y2, x3, y3);
	        var sToQ = PerspectiveTransform.squareToQuadrilateral(x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p);
	        return sToQ.times(qToS);
	    };
	    PerspectiveTransform.prototype.transformPoints = function (points) {
	        var max = points.length;
	        var a11 = this.a11;
	        var a12 = this.a12;
	        var a13 = this.a13;
	        var a21 = this.a21;
	        var a22 = this.a22;
	        var a23 = this.a23;
	        var a31 = this.a31;
	        var a32 = this.a32;
	        var a33 = this.a33;
	        for (var i = 0; i < max; i += 2) {
	            var x = points[i];
	            var y = points[i + 1];
	            var denominator = a13 * x + a23 * y + a33;
	            points[i] = (a11 * x + a21 * y + a31) / denominator;
	            points[i + 1] = (a12 * x + a22 * y + a32) / denominator;
	        }
	    };
	    PerspectiveTransform.prototype.transformPointsWithValues = function (xValues, yValues) {
	        var a11 = this.a11;
	        var a12 = this.a12;
	        var a13 = this.a13;
	        var a21 = this.a21;
	        var a22 = this.a22;
	        var a23 = this.a23;
	        var a31 = this.a31;
	        var a32 = this.a32;
	        var a33 = this.a33;
	        var n = xValues.length;
	        for (var i = 0; i < n; i++) {
	            var x = xValues[i];
	            var y = yValues[i];
	            var denominator = a13 * x + a23 * y + a33;
	            xValues[i] = (a11 * x + a21 * y + a31) / denominator;
	            yValues[i] = (a12 * x + a22 * y + a32) / denominator;
	        }
	    };
	    PerspectiveTransform.squareToQuadrilateral = function (x0 /*float*/, y0 /*float*/, x1 /*float*/, y1 /*float*/, x2 /*float*/, y2 /*float*/, x3 /*float*/, y3 /*float*/) {
	        var dx3 = x0 - x1 + x2 - x3;
	        var dy3 = y0 - y1 + y2 - y3;
	        if (dx3 === 0.0 && dy3 === 0.0) {
	            // Affine
	            return new PerspectiveTransform(x1 - x0, x2 - x1, x0, y1 - y0, y2 - y1, y0, 0.0, 0.0, 1.0);
	        }
	        else {
	            var dx1 = x1 - x2;
	            var dx2 = x3 - x2;
	            var dy1 = y1 - y2;
	            var dy2 = y3 - y2;
	            var denominator = dx1 * dy2 - dx2 * dy1;
	            var a13 = (dx3 * dy2 - dx2 * dy3) / denominator;
	            var a23 = (dx1 * dy3 - dx3 * dy1) / denominator;
	            return new PerspectiveTransform(x1 - x0 + a13 * x1, x3 - x0 + a23 * x3, x0, y1 - y0 + a13 * y1, y3 - y0 + a23 * y3, y0, a13, a23, 1.0);
	        }
	    };
	    PerspectiveTransform.quadrilateralToSquare = function (x0 /*float*/, y0 /*float*/, x1 /*float*/, y1 /*float*/, x2 /*float*/, y2 /*float*/, x3 /*float*/, y3 /*float*/) {
	        // Here, the adjoint serves as the inverse:
	        return PerspectiveTransform.squareToQuadrilateral(x0, y0, x1, y1, x2, y2, x3, y3).buildAdjoint();
	    };
	    PerspectiveTransform.prototype.buildAdjoint = function () {
	        // Adjoint is the transpose of the cofactor matrix:
	        return new PerspectiveTransform(this.a22 * this.a33 - this.a23 * this.a32, this.a23 * this.a31 - this.a21 * this.a33, this.a21 * this.a32 - this.a22 * this.a31, this.a13 * this.a32 - this.a12 * this.a33, this.a11 * this.a33 - this.a13 * this.a31, this.a12 * this.a31 - this.a11 * this.a32, this.a12 * this.a23 - this.a13 * this.a22, this.a13 * this.a21 - this.a11 * this.a23, this.a11 * this.a22 - this.a12 * this.a21);
	    };
	    PerspectiveTransform.prototype.times = function (other) {
	        return new PerspectiveTransform(this.a11 * other.a11 + this.a21 * other.a12 + this.a31 * other.a13, this.a11 * other.a21 + this.a21 * other.a22 + this.a31 * other.a23, this.a11 * other.a31 + this.a21 * other.a32 + this.a31 * other.a33, this.a12 * other.a11 + this.a22 * other.a12 + this.a32 * other.a13, this.a12 * other.a21 + this.a22 * other.a22 + this.a32 * other.a23, this.a12 * other.a31 + this.a22 * other.a32 + this.a32 * other.a33, this.a13 * other.a11 + this.a23 * other.a12 + this.a33 * other.a13, this.a13 * other.a21 + this.a23 * other.a22 + this.a33 * other.a23, this.a13 * other.a31 + this.a23 * other.a32 + this.a33 * other.a33);
	    };
	    return PerspectiveTransform;
	}());
	PerspectiveTransform$1.default = PerspectiveTransform;

	/*
	 * Copyright 2007 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __extends$2 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(DefaultGridSampler$1, "__esModule", { value: true });
	/*namespace com.google.zxing.common {*/
	var GridSampler_1 = GridSampler$1;
	var BitMatrix_1$1 = BitMatrix$1;
	var PerspectiveTransform_1$1 = PerspectiveTransform$1;
	var NotFoundException_1$4 = NotFoundException$1;
	/**
	 * @author Sean Owen
	 */
	var DefaultGridSampler = /** @class */ (function (_super) {
	    __extends$2(DefaultGridSampler, _super);
	    function DefaultGridSampler() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    /*@Override*/
	    DefaultGridSampler.prototype.sampleGrid = function (image, dimensionX /*int*/, dimensionY /*int*/, p1ToX /*float*/, p1ToY /*float*/, p2ToX /*float*/, p2ToY /*float*/, p3ToX /*float*/, p3ToY /*float*/, p4ToX /*float*/, p4ToY /*float*/, p1FromX /*float*/, p1FromY /*float*/, p2FromX /*float*/, p2FromY /*float*/, p3FromX /*float*/, p3FromY /*float*/, p4FromX /*float*/, p4FromY /*float*/) {
	        var transform = PerspectiveTransform_1$1.default.quadrilateralToQuadrilateral(p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY, p3FromX, p3FromY, p4FromX, p4FromY);
	        return this.sampleGridWithTransform(image, dimensionX, dimensionY, transform);
	    };
	    /*@Override*/
	    DefaultGridSampler.prototype.sampleGridWithTransform = function (image, dimensionX /*int*/, dimensionY /*int*/, transform) {
	        if (dimensionX <= 0 || dimensionY <= 0) {
	            throw new NotFoundException_1$4.default();
	        }
	        var bits = new BitMatrix_1$1.default(dimensionX, dimensionY);
	        var points = new Float32Array(2 * dimensionX);
	        for (var y = 0; y < dimensionY; y++) {
	            var max = points.length;
	            var iValue = y + 0.5;
	            for (var x = 0; x < max; x += 2) {
	                points[x] = (x / 2) + 0.5;
	                points[x + 1] = iValue;
	            }
	            transform.transformPoints(points);
	            // Quick check to see if points transformed to something inside the image
	            // sufficient to check the endpoints
	            GridSampler_1.default.checkAndNudgePoints(image, points);
	            try {
	                for (var x = 0; x < max; x += 2) {
	                    if (image.get(Math.floor(points[x]), Math.floor(points[x + 1]))) {
	                        // Black(-ish) pixel
	                        bits.set(x / 2, y);
	                    }
	                }
	            }
	            catch (aioobe /*: ArrayIndexOutOfBoundsException*/) {
	                // This feels wrong, but, sometimes if the finder patterns are misidentified, the resulting
	                // transform gets "twisted" such that it maps a straight line of points to a set of points
	                // whose endpoints are in bounds, but others are not. There is probably some mathematical
	                // way to detect this about the transformation that I don't know yet.
	                // This results in an ugly runtime exception despite our clever checks above -- can't have
	                // that. We could check each point's coordinates but that feels duplicative. We settle for
	                // catching and wrapping ArrayIndexOutOfBoundsException.
	                throw new NotFoundException_1$4.default();
	            }
	        }
	        return bits;
	    };
	    return DefaultGridSampler;
	}(GridSampler_1.default));
	DefaultGridSampler$1.default = DefaultGridSampler;

	Object.defineProperty(GridSamplerInstance$1, "__esModule", { value: true });
	var DefaultGridSampler_1 = DefaultGridSampler$1;
	var GridSamplerInstance = /** @class */ (function () {
	    function GridSamplerInstance() {
	    }
	    /**
	     * Sets the implementation of GridSampler used by the library. One global
	     * instance is stored, which may sound problematic. But, the implementation provided
	     * ought to be appropriate for the entire platform, and all uses of this library
	     * in the whole lifetime of the JVM. For instance, an Android activity can swap in
	     * an implementation that takes advantage of native platform libraries.
	     *
	     * @param newGridSampler The platform-specific object to install.
	     */
	    GridSamplerInstance.setGridSampler = function (newGridSampler) {
	        GridSamplerInstance.gridSampler = newGridSampler;
	    };
	    /**
	     * @return the current implementation of GridSampler
	     */
	    GridSamplerInstance.getInstance = function () {
	        return GridSamplerInstance.gridSampler;
	    };
	    GridSamplerInstance.gridSampler = new DefaultGridSampler_1.default();
	    return GridSamplerInstance;
	}());
	GridSamplerInstance$1.default = GridSamplerInstance;

	var ResultPoint$1 = {};

	var Float$1 = {};

	Object.defineProperty(Float$1, "__esModule", { value: true });
	/**
	 * Ponyfill for Java's Float class.
	 */
	var Float = /** @class */ (function () {
	    function Float() {
	    }
	    /**
	     * SincTS has no difference between int and float, there's all numbers,
	     * this is used only to polyfill Java code.
	     */
	    Float.floatToIntBits = function (f) {
	        return f;
	    };
	    /**
	     * The float max value in JS is the number max value.
	     */
	    Float.MAX_VALUE = Number.MAX_SAFE_INTEGER;
	    return Float;
	}());
	Float$1.default = Float;

	/*
	 * Copyright 2007 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(ResultPoint$1, "__esModule", { value: true });
	/*namespace com.google.zxing {*/
	var MathUtils_1$1 = MathUtils$1;
	var Float_1 = Float$1;
	/**
	 * <p>Encapsulates a point of interest in an image containing a barcode. Typically, this
	 * would be the location of a finder pattern or the corner of the barcode, for example.</p>
	 *
	 * @author Sean Owen
	 */
	var ResultPoint = /** @class */ (function () {
	    function ResultPoint(x, y) {
	        this.x = x;
	        this.y = y;
	    }
	    ResultPoint.prototype.getX = function () {
	        return this.x;
	    };
	    ResultPoint.prototype.getY = function () {
	        return this.y;
	    };
	    /*@Override*/
	    ResultPoint.prototype.equals = function (other) {
	        if (other instanceof ResultPoint) {
	            var otherPoint = other;
	            return this.x === otherPoint.x && this.y === otherPoint.y;
	        }
	        return false;
	    };
	    /*@Override*/
	    ResultPoint.prototype.hashCode = function () {
	        return 31 * Float_1.default.floatToIntBits(this.x) + Float_1.default.floatToIntBits(this.y);
	    };
	    /*@Override*/
	    ResultPoint.prototype.toString = function () {
	        return '(' + this.x + ',' + this.y + ')';
	    };
	    /**
	     * Orders an array of three ResultPoints in an order [A,B,C] such that AB is less than AC
	     * and BC is less than AC, and the angle between BC and BA is less than 180 degrees.
	     *
	     * @param patterns array of three {@code ResultPoint} to order
	     */
	    ResultPoint.orderBestPatterns = function (patterns) {
	        // Find distances between pattern centers
	        var zeroOneDistance = this.distance(patterns[0], patterns[1]);
	        var oneTwoDistance = this.distance(patterns[1], patterns[2]);
	        var zeroTwoDistance = this.distance(patterns[0], patterns[2]);
	        var pointA;
	        var pointB;
	        var pointC;
	        // Assume one closest to other two is B; A and C will just be guesses at first
	        if (oneTwoDistance >= zeroOneDistance && oneTwoDistance >= zeroTwoDistance) {
	            pointB = patterns[0];
	            pointA = patterns[1];
	            pointC = patterns[2];
	        }
	        else if (zeroTwoDistance >= oneTwoDistance && zeroTwoDistance >= zeroOneDistance) {
	            pointB = patterns[1];
	            pointA = patterns[0];
	            pointC = patterns[2];
	        }
	        else {
	            pointB = patterns[2];
	            pointA = patterns[0];
	            pointC = patterns[1];
	        }
	        // Use cross product to figure out whether A and C are correct or flipped.
	        // This asks whether BC x BA has a positive z component, which is the arrangement
	        // we want for A, B, C. If it's negative, then we've got it flipped around and
	        // should swap A and C.
	        if (this.crossProductZ(pointA, pointB, pointC) < 0.0) {
	            var temp = pointA;
	            pointA = pointC;
	            pointC = temp;
	        }
	        patterns[0] = pointA;
	        patterns[1] = pointB;
	        patterns[2] = pointC;
	    };
	    /**
	     * @param pattern1 first pattern
	     * @param pattern2 second pattern
	     * @return distance between two points
	     */
	    ResultPoint.distance = function (pattern1, pattern2) {
	        return MathUtils_1$1.default.distance(pattern1.x, pattern1.y, pattern2.x, pattern2.y);
	    };
	    /**
	     * Returns the z component of the cross product between vectors BC and BA.
	     */
	    ResultPoint.crossProductZ = function (pointA, pointB, pointC) {
	        var bX = pointB.x;
	        var bY = pointB.y;
	        return ((pointC.x - bX) * (pointA.y - bY)) - ((pointC.y - bY) * (pointA.x - bX));
	    };
	    return ResultPoint;
	}());
	ResultPoint$1.default = ResultPoint;

	var AlignmentPatternFinder$1 = {};

	var AlignmentPattern$1 = {};

	/*
	 * Copyright 2007 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __extends$1 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(AlignmentPattern$1, "__esModule", { value: true });
	/*namespace com.google.zxing.qrcode.detector {*/
	var ResultPoint_1$3 = ResultPoint$1;
	/**
	 * <p>Encapsulates an alignment pattern, which are the smaller square patterns found in
	 * all but the simplest QR Codes.</p>
	 *
	 * @author Sean Owen
	 */
	var AlignmentPattern = /** @class */ (function (_super) {
	    __extends$1(AlignmentPattern, _super);
	    function AlignmentPattern(posX /*float*/, posY /*float*/, estimatedModuleSize /*float*/) {
	        var _this = _super.call(this, posX, posY) || this;
	        _this.estimatedModuleSize = estimatedModuleSize;
	        return _this;
	    }
	    /**
	     * <p>Determines if this alignment pattern "about equals" an alignment pattern at the stated
	     * position and size -- meaning, it is at nearly the same center with nearly the same size.</p>
	     */
	    AlignmentPattern.prototype.aboutEquals = function (moduleSize /*float*/, i /*float*/, j /*float*/) {
	        if (Math.abs(i - this.getY()) <= moduleSize && Math.abs(j - this.getX()) <= moduleSize) {
	            var moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);
	            return moduleSizeDiff <= 1.0 || moduleSizeDiff <= this.estimatedModuleSize;
	        }
	        return false;
	    };
	    /**
	     * Combines this object's current estimate of a finder pattern position and module size
	     * with a new estimate. It returns a new {@code FinderPattern} containing an average of the two.
	     */
	    AlignmentPattern.prototype.combineEstimate = function (i /*float*/, j /*float*/, newModuleSize /*float*/) {
	        var combinedX = (this.getX() + j) / 2.0;
	        var combinedY = (this.getY() + i) / 2.0;
	        var combinedModuleSize = (this.estimatedModuleSize + newModuleSize) / 2.0;
	        return new AlignmentPattern(combinedX, combinedY, combinedModuleSize);
	    };
	    return AlignmentPattern;
	}(ResultPoint_1$3.default));
	AlignmentPattern$1.default = AlignmentPattern;

	/*
	 * Copyright 2007 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __values$1 = (commonjsGlobal && commonjsGlobal.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(AlignmentPatternFinder$1, "__esModule", { value: true });
	var AlignmentPattern_1 = AlignmentPattern$1;
	var NotFoundException_1$3 = NotFoundException$1;
	/*import java.util.ArrayList;*/
	/*import java.util.List;*/
	/**
	 * <p>This class attempts to find alignment patterns in a QR Code. Alignment patterns look like finder
	 * patterns but are smaller and appear at regular intervals throughout the image.</p>
	 *
	 * <p>At the moment this only looks for the bottom-right alignment pattern.</p>
	 *
	 * <p>This is mostly a simplified copy of {@link FinderPatternFinder}. It is copied,
	 * pasted and stripped down here for maximum performance but does unfortunately duplicate
	 * some code.</p>
	 *
	 * <p>This class is thread-safe but not reentrant. Each thread must allocate its own object.</p>
	 *
	 * @author Sean Owen
	 */
	var AlignmentPatternFinder = /** @class */ (function () {
	    /**
	     * <p>Creates a finder that will look in a portion of the whole image.</p>
	     *
	     * @param image image to search
	     * @param startX left column from which to start searching
	     * @param startY top row from which to start searching
	     * @param width width of region to search
	     * @param height height of region to search
	     * @param moduleSize estimated module size so far
	     */
	    function AlignmentPatternFinder(image, startX /*int*/, startY /*int*/, width /*int*/, height /*int*/, moduleSize /*float*/, resultPointCallback) {
	        this.image = image;
	        this.startX = startX;
	        this.startY = startY;
	        this.width = width;
	        this.height = height;
	        this.moduleSize = moduleSize;
	        this.resultPointCallback = resultPointCallback;
	        this.possibleCenters = []; // new Array<any>(5))
	        // TYPESCRIPTPORT: array initialization without size as the length is checked below
	        this.crossCheckStateCount = new Int32Array(3);
	    }
	    /**
	     * <p>This method attempts to find the bottom-right alignment pattern in the image. It is a bit messy since
	     * it's pretty performance-critical and so is written to be fast foremost.</p>
	     *
	     * @return {@link AlignmentPattern} if found
	     * @throws NotFoundException if not found
	     */
	    AlignmentPatternFinder.prototype.find = function () {
	        var startX = this.startX;
	        var height = this.height;
	        var width = this.width;
	        var maxJ = startX + width;
	        var middleI = this.startY + (height / 2);
	        // We are looking for black/white/black modules in 1:1:1 ratio
	        // this tracks the number of black/white/black modules seen so far
	        var stateCount = new Int32Array(3);
	        var image = this.image;
	        for (var iGen = 0; iGen < height; iGen++) {
	            // Search from middle outwards
	            var i = middleI + ((iGen & 0x01) === 0 ? Math.floor((iGen + 1) / 2) : -Math.floor((iGen + 1) / 2));
	            stateCount[0] = 0;
	            stateCount[1] = 0;
	            stateCount[2] = 0;
	            var j = startX;
	            // Burn off leading white pixels before anything else; if we start in the middle of
	            // a white run, it doesn't make sense to count its length, since we don't know if the
	            // white run continued to the left of the start point
	            while (j < maxJ && !image.get(j, i)) {
	                j++;
	            }
	            var currentState = 0;
	            while (j < maxJ) {
	                if (image.get(j, i)) {
	                    // Black pixel
	                    if (currentState === 1) { // Counting black pixels
	                        stateCount[1]++;
	                    }
	                    else { // Counting white pixels
	                        if (currentState === 2) { // A winner?
	                            if (this.foundPatternCross(stateCount)) { // Yes
	                                var confirmed = this.handlePossibleCenter(stateCount, i, j);
	                                if (confirmed !== null) {
	                                    return confirmed;
	                                }
	                            }
	                            stateCount[0] = stateCount[2];
	                            stateCount[1] = 1;
	                            stateCount[2] = 0;
	                            currentState = 1;
	                        }
	                        else {
	                            stateCount[++currentState]++;
	                        }
	                    }
	                }
	                else { // White pixel
	                    if (currentState === 1) { // Counting black pixels
	                        currentState++;
	                    }
	                    stateCount[currentState]++;
	                }
	                j++;
	            }
	            if (this.foundPatternCross(stateCount)) {
	                var confirmed = this.handlePossibleCenter(stateCount, i, maxJ);
	                if (confirmed !== null) {
	                    return confirmed;
	                }
	            }
	        }
	        // Hmm, nothing we saw was observed and confirmed twice. If we had
	        // any guess at all, return it.
	        if (this.possibleCenters.length !== 0) {
	            return this.possibleCenters[0];
	        }
	        throw new NotFoundException_1$3.default();
	    };
	    /**
	     * Given a count of black/white/black pixels just seen and an end position,
	     * figures the location of the center of this black/white/black run.
	     */
	    AlignmentPatternFinder.centerFromEnd = function (stateCount, end /*int*/) {
	        return (end - stateCount[2]) - stateCount[1] / 2.0;
	    };
	    /**
	     * @param stateCount count of black/white/black pixels just read
	     * @return true iff the proportions of the counts is close enough to the 1/1/1 ratios
	     *         used by alignment patterns to be considered a match
	     */
	    AlignmentPatternFinder.prototype.foundPatternCross = function (stateCount) {
	        var moduleSize = this.moduleSize;
	        var maxVariance = moduleSize / 2.0;
	        for (var i = 0; i < 3; i++) {
	            if (Math.abs(moduleSize - stateCount[i]) >= maxVariance) {
	                return false;
	            }
	        }
	        return true;
	    };
	    /**
	     * <p>After a horizontal scan finds a potential alignment pattern, this method
	     * "cross-checks" by scanning down vertically through the center of the possible
	     * alignment pattern to see if the same proportion is detected.</p>
	     *
	     * @param startI row where an alignment pattern was detected
	     * @param centerJ center of the section that appears to cross an alignment pattern
	     * @param maxCount maximum reasonable number of modules that should be
	     * observed in any reading state, based on the results of the horizontal scan
	     * @return vertical center of alignment pattern, or {@link Float#NaN} if not found
	     */
	    AlignmentPatternFinder.prototype.crossCheckVertical = function (startI /*int*/, centerJ /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {
	        var image = this.image;
	        var maxI = image.getHeight();
	        var stateCount = this.crossCheckStateCount;
	        stateCount[0] = 0;
	        stateCount[1] = 0;
	        stateCount[2] = 0;
	        // Start counting up from center
	        var i = startI;
	        while (i >= 0 && image.get(centerJ, i) && stateCount[1] <= maxCount) {
	            stateCount[1]++;
	            i--;
	        }
	        // If already too many modules in this state or ran off the edge:
	        if (i < 0 || stateCount[1] > maxCount) {
	            return NaN;
	        }
	        while (i >= 0 && !image.get(centerJ, i) && stateCount[0] <= maxCount) {
	            stateCount[0]++;
	            i--;
	        }
	        if (stateCount[0] > maxCount) {
	            return NaN;
	        }
	        // Now also count down from center
	        i = startI + 1;
	        while (i < maxI && image.get(centerJ, i) && stateCount[1] <= maxCount) {
	            stateCount[1]++;
	            i++;
	        }
	        if (i === maxI || stateCount[1] > maxCount) {
	            return NaN;
	        }
	        while (i < maxI && !image.get(centerJ, i) && stateCount[2] <= maxCount) {
	            stateCount[2]++;
	            i++;
	        }
	        if (stateCount[2] > maxCount) {
	            return NaN;
	        }
	        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];
	        if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {
	            return NaN;
	        }
	        return this.foundPatternCross(stateCount) ? AlignmentPatternFinder.centerFromEnd(stateCount, i) : NaN;
	    };
	    /**
	     * <p>This is called when a horizontal scan finds a possible alignment pattern. It will
	     * cross check with a vertical scan, and if successful, will see if this pattern had been
	     * found on a previous horizontal scan. If so, we consider it confirmed and conclude we have
	     * found the alignment pattern.</p>
	     *
	     * @param stateCount reading state module counts from horizontal scan
	     * @param i row where alignment pattern may be found
	     * @param j end of possible alignment pattern in row
	     * @return {@link AlignmentPattern} if we have found the same pattern twice, or null if not
	     */
	    AlignmentPatternFinder.prototype.handlePossibleCenter = function (stateCount, i /*int*/, j /*int*/) {
	        var e_1, _a;
	        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];
	        var centerJ = AlignmentPatternFinder.centerFromEnd(stateCount, j);
	        var centerI = this.crossCheckVertical(i, /*(int) */ centerJ, 2 * stateCount[1], stateCountTotal);
	        if (!isNaN(centerI)) {
	            var estimatedModuleSize = (stateCount[0] + stateCount[1] + stateCount[2]) / 3.0;
	            try {
	                for (var _b = __values$1(this.possibleCenters), _c = _b.next(); !_c.done; _c = _b.next()) {
	                    var center = _c.value;
	                    // Look for about the same center and module size:
	                    if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {
	                        return center.combineEstimate(centerI, centerJ, estimatedModuleSize);
	                    }
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	            // Hadn't found this before; save it
	            var point = new AlignmentPattern_1.default(centerJ, centerI, estimatedModuleSize);
	            this.possibleCenters.push(point);
	            if (this.resultPointCallback !== null && this.resultPointCallback !== undefined) {
	                this.resultPointCallback.foundPossibleResultPoint(point);
	            }
	        }
	        return null;
	    };
	    return AlignmentPatternFinder;
	}());
	AlignmentPatternFinder$1.default = AlignmentPatternFinder;

	var FinderPatternFinder$1 = {};

	var FinderPattern$1 = {};

	/*
	 * Copyright 2007 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(FinderPattern$1, "__esModule", { value: true });
	/*namespace com.google.zxing.qrcode.detector {*/
	var ResultPoint_1$2 = ResultPoint$1;
	/**
	 * <p>Encapsulates a finder pattern, which are the three square patterns found in
	 * the corners of QR Codes. It also encapsulates a count of similar finder patterns,
	 * as a convenience to the finder's bookkeeping.</p>
	 *
	 * @author Sean Owen
	 */
	var FinderPattern = /** @class */ (function (_super) {
	    __extends(FinderPattern, _super);
	    // FinderPattern(posX: number/*float*/, posY: number/*float*/, estimatedModuleSize: number/*float*/) {
	    //   this(posX, posY, estimatedModuleSize, 1)
	    // }
	    function FinderPattern(posX /*float*/, posY /*float*/, estimatedModuleSize /*float*/, count /*int*/) {
	        var _this = _super.call(this, posX, posY) || this;
	        _this.estimatedModuleSize = estimatedModuleSize;
	        _this.count = count;
	        if (undefined === count) {
	            _this.count = 1;
	        }
	        return _this;
	    }
	    FinderPattern.prototype.getEstimatedModuleSize = function () {
	        return this.estimatedModuleSize;
	    };
	    FinderPattern.prototype.getCount = function () {
	        return this.count;
	    };
	    /*
	    void incrementCount() {
	      this.count++
	    }
	     */
	    /**
	     * <p>Determines if this finder pattern "about equals" a finder pattern at the stated
	     * position and size -- meaning, it is at nearly the same center with nearly the same size.</p>
	     */
	    FinderPattern.prototype.aboutEquals = function (moduleSize /*float*/, i /*float*/, j /*float*/) {
	        if (Math.abs(i - this.getY()) <= moduleSize && Math.abs(j - this.getX()) <= moduleSize) {
	            var moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);
	            return moduleSizeDiff <= 1.0 || moduleSizeDiff <= this.estimatedModuleSize;
	        }
	        return false;
	    };
	    /**
	     * Combines this object's current estimate of a finder pattern position and module size
	     * with a new estimate. It returns a new {@code FinderPattern} containing a weighted average
	     * based on count.
	     */
	    FinderPattern.prototype.combineEstimate = function (i /*float*/, j /*float*/, newModuleSize /*float*/) {
	        var combinedCount = this.count + 1;
	        var combinedX = (this.count * this.getX() + j) / combinedCount;
	        var combinedY = (this.count * this.getY() + i) / combinedCount;
	        var combinedModuleSize = (this.count * this.estimatedModuleSize + newModuleSize) / combinedCount;
	        return new FinderPattern(combinedX, combinedY, combinedModuleSize, combinedCount);
	    };
	    return FinderPattern;
	}(ResultPoint_1$2.default));
	FinderPattern$1.default = FinderPattern;

	var FinderPatternInfo$1 = {};

	/*
	 * Copyright 2007 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(FinderPatternInfo$1, "__esModule", { value: true });
	/**
	 * <p>Encapsulates information about finder patterns in an image, including the location of
	 * the three finder patterns, and their estimated module size.</p>
	 *
	 * @author Sean Owen
	 */
	var FinderPatternInfo = /** @class */ (function () {
	    function FinderPatternInfo(patternCenters) {
	        this.bottomLeft = patternCenters[0];
	        this.topLeft = patternCenters[1];
	        this.topRight = patternCenters[2];
	    }
	    FinderPatternInfo.prototype.getBottomLeft = function () {
	        return this.bottomLeft;
	    };
	    FinderPatternInfo.prototype.getTopLeft = function () {
	        return this.topLeft;
	    };
	    FinderPatternInfo.prototype.getTopRight = function () {
	        return this.topRight;
	    };
	    return FinderPatternInfo;
	}());
	FinderPatternInfo$1.default = FinderPatternInfo;

	/*
	 * Copyright 2007 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __values = (commonjsGlobal && commonjsGlobal.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(FinderPatternFinder$1, "__esModule", { value: true });
	/*namespace com.google.zxing.qrcode.detector {*/
	var DecodeHintType_1$2 = DecodeHintType$1;
	var ResultPoint_1$1 = ResultPoint$1;
	var FinderPattern_1 = FinderPattern$1;
	var FinderPatternInfo_1 = FinderPatternInfo$1;
	var NotFoundException_1$2 = NotFoundException$1;
	/*import java.io.Serializable;*/
	/*import java.util.ArrayList;*/
	/*import java.util.Collections;*/
	/*import java.util.Comparator;*/
	/*import java.util.List;*/
	/*import java.util.Map;*/
	/**
	 * <p>This class attempts to find finder patterns in a QR Code. Finder patterns are the square
	 * markers at three corners of a QR Code.</p>
	 *
	 * <p>This class is thread-safe but not reentrant. Each thread must allocate its own object.
	 *
	 * @author Sean Owen
	 */
	var FinderPatternFinder = /** @class */ (function () {
	    /**
	     * <p>Creates a finder that will search the image for three finder patterns.</p>
	     *
	     * @param image image to search
	     */
	    // public constructor(image: BitMatrix) {
	    //   this(image, null)
	    // }
	    function FinderPatternFinder(image, resultPointCallback) {
	        this.image = image;
	        this.resultPointCallback = resultPointCallback;
	        this.possibleCenters = [];
	        this.crossCheckStateCount = new Int32Array(5);
	        this.resultPointCallback = resultPointCallback;
	    }
	    FinderPatternFinder.prototype.getImage = function () {
	        return this.image;
	    };
	    FinderPatternFinder.prototype.getPossibleCenters = function () {
	        return this.possibleCenters;
	    };
	    FinderPatternFinder.prototype.find = function (hints) {
	        var tryHarder = (hints !== null && hints !== undefined) && undefined !== hints.get(DecodeHintType_1$2.default.TRY_HARDER);
	        var pureBarcode = (hints !== null && hints !== undefined) && undefined !== hints.get(DecodeHintType_1$2.default.PURE_BARCODE);
	        var image = this.image;
	        var maxI = image.getHeight();
	        var maxJ = image.getWidth();
	        // We are looking for black/white/black/white/black modules in
	        // 1:1:3:1:1 ratio; this tracks the number of such modules seen so far
	        // Let's assume that the maximum version QR Code we support takes up 1/4 the height of the
	        // image, and then account for the center being 3 modules in size. This gives the smallest
	        // number of pixels the center could be, so skip this often. When trying harder, look for all
	        // QR versions regardless of how dense they are.
	        var iSkip = Math.floor((3 * maxI) / (4 * FinderPatternFinder.MAX_MODULES));
	        if (iSkip < FinderPatternFinder.MIN_SKIP || tryHarder) {
	            iSkip = FinderPatternFinder.MIN_SKIP;
	        }
	        var done = false;
	        var stateCount = new Int32Array(5);
	        for (var i = iSkip - 1; i < maxI && !done; i += iSkip) {
	            // Get a row of black/white values
	            stateCount[0] = 0;
	            stateCount[1] = 0;
	            stateCount[2] = 0;
	            stateCount[3] = 0;
	            stateCount[4] = 0;
	            var currentState = 0;
	            for (var j = 0; j < maxJ; j++) {
	                if (image.get(j, i)) {
	                    // Black pixel
	                    if ((currentState & 1) === 1) { // Counting white pixels
	                        currentState++;
	                    }
	                    stateCount[currentState]++;
	                }
	                else { // White pixel
	                    if ((currentState & 1) === 0) { // Counting black pixels
	                        if (currentState === 4) { // A winner?
	                            if (FinderPatternFinder.foundPatternCross(stateCount)) { // Yes
	                                var confirmed = this.handlePossibleCenter(stateCount, i, j, pureBarcode);
	                                if (confirmed === true) {
	                                    // Start examining every other line. Checking each line turned out to be too
	                                    // expensive and didn't improve performance.
	                                    iSkip = 2;
	                                    if (this.hasSkipped === true) {
	                                        done = this.haveMultiplyConfirmedCenters();
	                                    }
	                                    else {
	                                        var rowSkip = this.findRowSkip();
	                                        if (rowSkip > stateCount[2]) {
	                                            // Skip rows between row of lower confirmed center
	                                            // and top of presumed third confirmed center
	                                            // but back up a bit to get a full chance of detecting
	                                            // it, entire width of center of finder pattern
	                                            // Skip by rowSkip, but back off by stateCount[2] (size of last center
	                                            // of pattern we saw) to be conservative, and also back off by iSkip which
	                                            // is about to be re-added
	                                            i += rowSkip - stateCount[2] - iSkip;
	                                            j = maxJ - 1;
	                                        }
	                                    }
	                                }
	                                else {
	                                    stateCount[0] = stateCount[2];
	                                    stateCount[1] = stateCount[3];
	                                    stateCount[2] = stateCount[4];
	                                    stateCount[3] = 1;
	                                    stateCount[4] = 0;
	                                    currentState = 3;
	                                    continue;
	                                }
	                                // Clear state to start looking again
	                                currentState = 0;
	                                stateCount[0] = 0;
	                                stateCount[1] = 0;
	                                stateCount[2] = 0;
	                                stateCount[3] = 0;
	                                stateCount[4] = 0;
	                            }
	                            else { // No, shift counts back by two
	                                stateCount[0] = stateCount[2];
	                                stateCount[1] = stateCount[3];
	                                stateCount[2] = stateCount[4];
	                                stateCount[3] = 1;
	                                stateCount[4] = 0;
	                                currentState = 3;
	                            }
	                        }
	                        else {
	                            stateCount[++currentState]++;
	                        }
	                    }
	                    else { // Counting white pixels
	                        stateCount[currentState]++;
	                    }
	                }
	            }
	            if (FinderPatternFinder.foundPatternCross(stateCount)) {
	                var confirmed = this.handlePossibleCenter(stateCount, i, maxJ, pureBarcode);
	                if (confirmed === true) {
	                    iSkip = stateCount[0];
	                    if (this.hasSkipped) {
	                        // Found a third one
	                        done = this.haveMultiplyConfirmedCenters();
	                    }
	                }
	            }
	        }
	        var patternInfo = this.selectBestPatterns();
	        ResultPoint_1$1.default.orderBestPatterns(patternInfo);
	        return new FinderPatternInfo_1.default(patternInfo);
	    };
	    /**
	     * Given a count of black/white/black/white/black pixels just seen and an end position,
	     * figures the location of the center of this run.
	     */
	    FinderPatternFinder.centerFromEnd = function (stateCount, end /*int*/) {
	        return (end - stateCount[4] - stateCount[3]) - stateCount[2] / 2.0;
	    };
	    /**
	     * @param stateCount count of black/white/black/white/black pixels just read
	     * @return true iff the proportions of the counts is close enough to the 1/1/3/1/1 ratios
	     *         used by finder patterns to be considered a match
	     */
	    FinderPatternFinder.foundPatternCross = function (stateCount) {
	        var totalModuleSize = 0;
	        for (var i = 0; i < 5; i++) {
	            var count = stateCount[i];
	            if (count === 0) {
	                return false;
	            }
	            totalModuleSize += count;
	        }
	        if (totalModuleSize < 7) {
	            return false;
	        }
	        var moduleSize = totalModuleSize / 7.0;
	        var maxVariance = moduleSize / 2.0;
	        // Allow less than 50% variance from 1-1-3-1-1 proportions
	        return Math.abs(moduleSize - stateCount[0]) < maxVariance &&
	            Math.abs(moduleSize - stateCount[1]) < maxVariance &&
	            Math.abs(3.0 * moduleSize - stateCount[2]) < 3 * maxVariance &&
	            Math.abs(moduleSize - stateCount[3]) < maxVariance &&
	            Math.abs(moduleSize - stateCount[4]) < maxVariance;
	    };
	    FinderPatternFinder.prototype.getCrossCheckStateCount = function () {
	        var crossCheckStateCount = this.crossCheckStateCount;
	        crossCheckStateCount[0] = 0;
	        crossCheckStateCount[1] = 0;
	        crossCheckStateCount[2] = 0;
	        crossCheckStateCount[3] = 0;
	        crossCheckStateCount[4] = 0;
	        return crossCheckStateCount;
	    };
	    /**
	     * After a vertical and horizontal scan finds a potential finder pattern, this method
	     * "cross-cross-cross-checks" by scanning down diagonally through the center of the possible
	     * finder pattern to see if the same proportion is detected.
	     *
	     * @param startI row where a finder pattern was detected
	     * @param centerJ center of the section that appears to cross a finder pattern
	     * @param maxCount maximum reasonable number of modules that should be
	     *  observed in any reading state, based on the results of the horizontal scan
	     * @param originalStateCountTotal The original state count total.
	     * @return true if proportions are withing expected limits
	     */
	    FinderPatternFinder.prototype.crossCheckDiagonal = function (startI /*int*/, centerJ /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {
	        var stateCount = this.getCrossCheckStateCount();
	        // Start counting up, left from center finding black center mass
	        var i = 0;
	        var image = this.image;
	        while (startI >= i && centerJ >= i && image.get(centerJ - i, startI - i)) {
	            stateCount[2]++;
	            i++;
	        }
	        if (startI < i || centerJ < i) {
	            return false;
	        }
	        // Continue up, left finding white space
	        while (startI >= i && centerJ >= i && !image.get(centerJ - i, startI - i) &&
	            stateCount[1] <= maxCount) {
	            stateCount[1]++;
	            i++;
	        }
	        // If already too many modules in this state or ran off the edge:
	        if (startI < i || centerJ < i || stateCount[1] > maxCount) {
	            return false;
	        }
	        // Continue up, left finding black border
	        while (startI >= i && centerJ >= i && image.get(centerJ - i, startI - i) &&
	            stateCount[0] <= maxCount) {
	            stateCount[0]++;
	            i++;
	        }
	        if (stateCount[0] > maxCount) {
	            return false;
	        }
	        var maxI = image.getHeight();
	        var maxJ = image.getWidth();
	        // Now also count down, right from center
	        i = 1;
	        while (startI + i < maxI && centerJ + i < maxJ && image.get(centerJ + i, startI + i)) {
	            stateCount[2]++;
	            i++;
	        }
	        // Ran off the edge?
	        if (startI + i >= maxI || centerJ + i >= maxJ) {
	            return false;
	        }
	        while (startI + i < maxI && centerJ + i < maxJ && !image.get(centerJ + i, startI + i) &&
	            stateCount[3] < maxCount) {
	            stateCount[3]++;
	            i++;
	        }
	        if (startI + i >= maxI || centerJ + i >= maxJ || stateCount[3] >= maxCount) {
	            return false;
	        }
	        while (startI + i < maxI && centerJ + i < maxJ && image.get(centerJ + i, startI + i) &&
	            stateCount[4] < maxCount) {
	            stateCount[4]++;
	            i++;
	        }
	        if (stateCount[4] >= maxCount) {
	            return false;
	        }
	        // If we found a finder-pattern-like section, but its size is more than 100% different than
	        // the original, assume it's a false positive
	        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
	        return Math.abs(stateCountTotal - originalStateCountTotal) < 2 * originalStateCountTotal &&
	            FinderPatternFinder.foundPatternCross(stateCount);
	    };
	    /**
	     * <p>After a horizontal scan finds a potential finder pattern, this method
	     * "cross-checks" by scanning down vertically through the center of the possible
	     * finder pattern to see if the same proportion is detected.</p>
	     *
	     * @param startI row where a finder pattern was detected
	     * @param centerJ center of the section that appears to cross a finder pattern
	     * @param maxCount maximum reasonable number of modules that should be
	     * observed in any reading state, based on the results of the horizontal scan
	     * @return vertical center of finder pattern, or {@link Float#NaN} if not found
	     */
	    FinderPatternFinder.prototype.crossCheckVertical = function (startI /*int*/, centerJ /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {
	        var image = this.image;
	        var maxI = image.getHeight();
	        var stateCount = this.getCrossCheckStateCount();
	        // Start counting up from center
	        var i = startI;
	        while (i >= 0 && image.get(centerJ, i)) {
	            stateCount[2]++;
	            i--;
	        }
	        if (i < 0) {
	            return NaN;
	        }
	        while (i >= 0 && !image.get(centerJ, i) && stateCount[1] <= maxCount) {
	            stateCount[1]++;
	            i--;
	        }
	        // If already too many modules in this state or ran off the edge:
	        if (i < 0 || stateCount[1] > maxCount) {
	            return NaN;
	        }
	        while (i >= 0 && image.get(centerJ, i) && stateCount[0] <= maxCount) {
	            stateCount[0]++;
	            i--;
	        }
	        if (stateCount[0] > maxCount) {
	            return NaN;
	        }
	        // Now also count down from center
	        i = startI + 1;
	        while (i < maxI && image.get(centerJ, i)) {
	            stateCount[2]++;
	            i++;
	        }
	        if (i === maxI) {
	            return NaN;
	        }
	        while (i < maxI && !image.get(centerJ, i) && stateCount[3] < maxCount) {
	            stateCount[3]++;
	            i++;
	        }
	        if (i === maxI || stateCount[3] >= maxCount) {
	            return NaN;
	        }
	        while (i < maxI && image.get(centerJ, i) && stateCount[4] < maxCount) {
	            stateCount[4]++;
	            i++;
	        }
	        if (stateCount[4] >= maxCount) {
	            return NaN;
	        }
	        // If we found a finder-pattern-like section, but its size is more than 40% different than
	        // the original, assume it's a false positive
	        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] +
	            stateCount[4];
	        if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {
	            return NaN;
	        }
	        return FinderPatternFinder.foundPatternCross(stateCount) ? FinderPatternFinder.centerFromEnd(stateCount, i) : NaN;
	    };
	    /**
	     * <p>Like {@link #crossCheckVertical(int, int, int, int)}, and in fact is basically identical,
	     * except it reads horizontally instead of vertically. This is used to cross-cross
	     * check a vertical cross check and locate the real center of the alignment pattern.</p>
	     */
	    FinderPatternFinder.prototype.crossCheckHorizontal = function (startJ /*int*/, centerI /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {
	        var image = this.image;
	        var maxJ = image.getWidth();
	        var stateCount = this.getCrossCheckStateCount();
	        var j = startJ;
	        while (j >= 0 && image.get(j, centerI)) {
	            stateCount[2]++;
	            j--;
	        }
	        if (j < 0) {
	            return NaN;
	        }
	        while (j >= 0 && !image.get(j, centerI) && stateCount[1] <= maxCount) {
	            stateCount[1]++;
	            j--;
	        }
	        if (j < 0 || stateCount[1] > maxCount) {
	            return NaN;
	        }
	        while (j >= 0 && image.get(j, centerI) && stateCount[0] <= maxCount) {
	            stateCount[0]++;
	            j--;
	        }
	        if (stateCount[0] > maxCount) {
	            return NaN;
	        }
	        j = startJ + 1;
	        while (j < maxJ && image.get(j, centerI)) {
	            stateCount[2]++;
	            j++;
	        }
	        if (j === maxJ) {
	            return NaN;
	        }
	        while (j < maxJ && !image.get(j, centerI) && stateCount[3] < maxCount) {
	            stateCount[3]++;
	            j++;
	        }
	        if (j === maxJ || stateCount[3] >= maxCount) {
	            return NaN;
	        }
	        while (j < maxJ && image.get(j, centerI) && stateCount[4] < maxCount) {
	            stateCount[4]++;
	            j++;
	        }
	        if (stateCount[4] >= maxCount) {
	            return NaN;
	        }
	        // If we found a finder-pattern-like section, but its size is significantly different than
	        // the original, assume it's a false positive
	        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] +
	            stateCount[4];
	        if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= originalStateCountTotal) {
	            return NaN;
	        }
	        return FinderPatternFinder.foundPatternCross(stateCount) ? FinderPatternFinder.centerFromEnd(stateCount, j) : NaN;
	    };
	    /**
	     * <p>This is called when a horizontal scan finds a possible alignment pattern. It will
	     * cross check with a vertical scan, and if successful, will, ah, cross-cross-check
	     * with another horizontal scan. This is needed primarily to locate the real horizontal
	     * center of the pattern in cases of extreme skew.
	     * And then we cross-cross-cross check with another diagonal scan.</p>
	     *
	     * <p>If that succeeds the finder pattern location is added to a list that tracks
	     * the number of times each location has been nearly-matched as a finder pattern.
	     * Each additional find is more evidence that the location is in fact a finder
	     * pattern center
	     *
	     * @param stateCount reading state module counts from horizontal scan
	     * @param i row where finder pattern may be found
	     * @param j end of possible finder pattern in row
	     * @param pureBarcode true if in "pure barcode" mode
	     * @return true if a finder pattern candidate was found this time
	     */
	    FinderPatternFinder.prototype.handlePossibleCenter = function (stateCount, i /*int*/, j /*int*/, pureBarcode) {
	        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] +
	            stateCount[4];
	        var centerJ = FinderPatternFinder.centerFromEnd(stateCount, j);
	        var centerI = this.crossCheckVertical(i, /*(int) */ Math.floor(centerJ), stateCount[2], stateCountTotal);
	        if (!isNaN(centerI)) {
	            // Re-cross check
	            centerJ = this.crossCheckHorizontal(/*(int) */ Math.floor(centerJ), /*(int) */ Math.floor(centerI), stateCount[2], stateCountTotal);
	            if (!isNaN(centerJ) &&
	                (!pureBarcode || this.crossCheckDiagonal(/*(int) */ Math.floor(centerI), /*(int) */ Math.floor(centerJ), stateCount[2], stateCountTotal))) {
	                var estimatedModuleSize = stateCountTotal / 7.0;
	                var found = false;
	                var possibleCenters = this.possibleCenters;
	                for (var index = 0, length_1 = possibleCenters.length; index < length_1; index++) {
	                    var center = possibleCenters[index];
	                    // Look for about the same center and module size:
	                    if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {
	                        possibleCenters[index] = center.combineEstimate(centerI, centerJ, estimatedModuleSize);
	                        found = true;
	                        break;
	                    }
	                }
	                if (!found) {
	                    var point = new FinderPattern_1.default(centerJ, centerI, estimatedModuleSize);
	                    possibleCenters.push(point);
	                    if (this.resultPointCallback !== null && this.resultPointCallback !== undefined) {
	                        this.resultPointCallback.foundPossibleResultPoint(point);
	                    }
	                }
	                return true;
	            }
	        }
	        return false;
	    };
	    /**
	     * @return number of rows we could safely skip during scanning, based on the first
	     *         two finder patterns that have been located. In some cases their position will
	     *         allow us to infer that the third pattern must lie below a certain point farther
	     *         down in the image.
	     */
	    FinderPatternFinder.prototype.findRowSkip = function () {
	        var e_1, _a;
	        var max = this.possibleCenters.length;
	        if (max <= 1) {
	            return 0;
	        }
	        var firstConfirmedCenter = null;
	        try {
	            for (var _b = __values(this.possibleCenters), _c = _b.next(); !_c.done; _c = _b.next()) {
	                var center = _c.value;
	                if (center.getCount() >= FinderPatternFinder.CENTER_QUORUM) {
	                    if (firstConfirmedCenter == null) {
	                        firstConfirmedCenter = center;
	                    }
	                    else {
	                        // We have two confirmed centers
	                        // How far down can we skip before resuming looking for the next
	                        // pattern? In the worst case, only the difference between the
	                        // difference in the x / y coordinates of the two centers.
	                        // This is the case where you find top left last.
	                        this.hasSkipped = true;
	                        return /*(int) */ Math.floor((Math.abs(firstConfirmedCenter.getX() - center.getX()) -
	                            Math.abs(firstConfirmedCenter.getY() - center.getY())) / 2);
	                    }
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        return 0;
	    };
	    /**
	     * @return true iff we have found at least 3 finder patterns that have been detected
	     *         at least {@link #CENTER_QUORUM} times each, and, the estimated module size of the
	     *         candidates is "pretty similar"
	     */
	    FinderPatternFinder.prototype.haveMultiplyConfirmedCenters = function () {
	        var e_2, _a, e_3, _b;
	        var confirmedCount = 0;
	        var totalModuleSize = 0.0;
	        var max = this.possibleCenters.length;
	        try {
	            for (var _c = __values(this.possibleCenters), _d = _c.next(); !_d.done; _d = _c.next()) {
	                var pattern = _d.value;
	                if (pattern.getCount() >= FinderPatternFinder.CENTER_QUORUM) {
	                    confirmedCount++;
	                    totalModuleSize += pattern.getEstimatedModuleSize();
	                }
	            }
	        }
	        catch (e_2_1) { e_2 = { error: e_2_1 }; }
	        finally {
	            try {
	                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
	            }
	            finally { if (e_2) throw e_2.error; }
	        }
	        if (confirmedCount < 3) {
	            return false;
	        }
	        // OK, we have at least 3 confirmed centers, but, it's possible that one is a "false positive"
	        // and that we need to keep looking. We detect this by asking if the estimated module sizes
	        // vary too much. We arbitrarily say that when the total deviation from average exceeds
	        // 5% of the total module size estimates, it's too much.
	        var average = totalModuleSize / max;
	        var totalDeviation = 0.0;
	        try {
	            for (var _e = __values(this.possibleCenters), _f = _e.next(); !_f.done; _f = _e.next()) {
	                var pattern = _f.value;
	                totalDeviation += Math.abs(pattern.getEstimatedModuleSize() - average);
	            }
	        }
	        catch (e_3_1) { e_3 = { error: e_3_1 }; }
	        finally {
	            try {
	                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
	            }
	            finally { if (e_3) throw e_3.error; }
	        }
	        return totalDeviation <= 0.05 * totalModuleSize;
	    };
	    /**
	     * @return the 3 best {@link FinderPattern}s from our list of candidates. The "best" are
	     *         those that have been detected at least {@link #CENTER_QUORUM} times, and whose module
	     *         size differs from the average among those patterns the least
	     * @throws NotFoundException if 3 such finder patterns do not exist
	     */
	    FinderPatternFinder.prototype.selectBestPatterns = function () {
	        var e_4, _a, e_5, _b;
	        var startSize = this.possibleCenters.length;
	        if (startSize < 3) {
	            // Couldn't find enough finder patterns
	            throw new NotFoundException_1$2.default();
	        }
	        var possibleCenters = this.possibleCenters;
	        var average;
	        // Filter outlier possibilities whose module size is too different
	        if (startSize > 3) {
	            // But we can only afford to do so if we have at least 4 possibilities to choose from
	            var totalModuleSize = 0.0;
	            var square = 0.0;
	            try {
	                for (var _c = __values(this.possibleCenters), _d = _c.next(); !_d.done; _d = _c.next()) {
	                    var center = _d.value;
	                    var size = center.getEstimatedModuleSize();
	                    totalModuleSize += size;
	                    square += size * size;
	                }
	            }
	            catch (e_4_1) { e_4 = { error: e_4_1 }; }
	            finally {
	                try {
	                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
	                }
	                finally { if (e_4) throw e_4.error; }
	            }
	            average = totalModuleSize / startSize;
	            var stdDev = Math.sqrt(square / startSize - average * average);
	            possibleCenters.sort(
	            /**
	             * <p>Orders by furthest from average</p>
	             */
	            // FurthestFromAverageComparator implements Comparator<FinderPattern>
	            function (center1, center2) {
	                var dA = Math.abs(center2.getEstimatedModuleSize() - average);
	                var dB = Math.abs(center1.getEstimatedModuleSize() - average);
	                return dA < dB ? -1 : dA > dB ? 1 : 0;
	            });
	            var limit = Math.max(0.2 * average, stdDev);
	            for (var i = 0; i < possibleCenters.length && possibleCenters.length > 3; i++) {
	                var pattern = possibleCenters[i];
	                if (Math.abs(pattern.getEstimatedModuleSize() - average) > limit) {
	                    possibleCenters.splice(i, 1);
	                    i--;
	                }
	            }
	        }
	        if (possibleCenters.length > 3) {
	            // Throw away all but those first size candidate points we found.
	            var totalModuleSize = 0.0;
	            try {
	                for (var possibleCenters_1 = __values(possibleCenters), possibleCenters_1_1 = possibleCenters_1.next(); !possibleCenters_1_1.done; possibleCenters_1_1 = possibleCenters_1.next()) {
	                    var possibleCenter = possibleCenters_1_1.value;
	                    totalModuleSize += possibleCenter.getEstimatedModuleSize();
	                }
	            }
	            catch (e_5_1) { e_5 = { error: e_5_1 }; }
	            finally {
	                try {
	                    if (possibleCenters_1_1 && !possibleCenters_1_1.done && (_b = possibleCenters_1.return)) _b.call(possibleCenters_1);
	                }
	                finally { if (e_5) throw e_5.error; }
	            }
	            average = totalModuleSize / possibleCenters.length;
	            possibleCenters.sort(
	            /**
	             * <p>Orders by {@link FinderPattern#getCount()}, descending.</p>
	             */
	            // CenterComparator implements Comparator<FinderPattern>
	            function (center1, center2) {
	                if (center2.getCount() === center1.getCount()) {
	                    var dA = Math.abs(center2.getEstimatedModuleSize() - average);
	                    var dB = Math.abs(center1.getEstimatedModuleSize() - average);
	                    return dA < dB ? 1 : dA > dB ? -1 : 0;
	                }
	                else {
	                    return center2.getCount() - center1.getCount();
	                }
	            });
	            possibleCenters.splice(3); // this is not realy necessary as we only return first 3 anyway
	        }
	        return [
	            possibleCenters[0],
	            possibleCenters[1],
	            possibleCenters[2]
	        ];
	    };
	    FinderPatternFinder.CENTER_QUORUM = 2;
	    FinderPatternFinder.MIN_SKIP = 3; // 1 pixel/module times 3 modules/center
	    FinderPatternFinder.MAX_MODULES = 57; // support up to version 10 for mobile clients
	    return FinderPatternFinder;
	}());
	FinderPatternFinder$1.default = FinderPatternFinder;

	/*
	 * Copyright 2007 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(Detector$1, "__esModule", { value: true });
	var MathUtils_1 = MathUtils$1;
	var DetectorResult_1 = DetectorResult$1;
	// import GridSampler from '../../common/GridSampler';
	var GridSamplerInstance_1 = GridSamplerInstance$1;
	var PerspectiveTransform_1 = PerspectiveTransform$1;
	var DecodeHintType_1$1 = DecodeHintType$1;
	var NotFoundException_1$1 = NotFoundException$1;
	var ResultPoint_1 = ResultPoint$1;
	var Version_1 = Version$1;
	var AlignmentPatternFinder_1 = AlignmentPatternFinder$1;
	var FinderPatternFinder_1 = FinderPatternFinder$1;
	/*import java.util.Map;*/
	/**
	 * <p>Encapsulates logic that can detect a QR Code in an image, even if the QR Code
	 * is rotated or skewed, or partially obscured.</p>
	 *
	 * @author Sean Owen
	 */
	var Detector = /** @class */ (function () {
	    function Detector(image) {
	        this.image = image;
	    }
	    Detector.prototype.getImage = function () {
	        return this.image;
	    };
	    Detector.prototype.getResultPointCallback = function () {
	        return this.resultPointCallback;
	    };
	    /**
	     * <p>Detects a QR Code in an image.</p>
	     *
	     * @return {@link DetectorResult} encapsulating results of detecting a QR Code
	     * @throws NotFoundException if QR Code cannot be found
	     * @throws FormatException if a QR Code cannot be decoded
	     */
	    // public detect(): DetectorResult /*throws NotFoundException, FormatException*/ {
	    //   return detect(null)
	    // }
	    /**
	     * <p>Detects a QR Code in an image.</p>
	     *
	     * @param hints optional hints to detector
	     * @return {@link DetectorResult} encapsulating results of detecting a QR Code
	     * @throws NotFoundException if QR Code cannot be found
	     * @throws FormatException if a QR Code cannot be decoded
	     */
	    Detector.prototype.detect = function (hints) {
	        this.resultPointCallback = (hints === null || hints === undefined) ? null :
	            /*(ResultPointCallback) */ hints.get(DecodeHintType_1$1.default.NEED_RESULT_POINT_CALLBACK);
	        var finder = new FinderPatternFinder_1.default(this.image, this.resultPointCallback);
	        var info = finder.find(hints);
	        return this.processFinderPatternInfo(info);
	    };
	    Detector.prototype.processFinderPatternInfo = function (info) {
	        var topLeft = info.getTopLeft();
	        var topRight = info.getTopRight();
	        var bottomLeft = info.getBottomLeft();
	        var moduleSize = this.calculateModuleSize(topLeft, topRight, bottomLeft);
	        if (moduleSize < 1.0) {
	            throw new NotFoundException_1$1.default('No pattern found in proccess finder.');
	        }
	        var dimension = Detector.computeDimension(topLeft, topRight, bottomLeft, moduleSize);
	        var provisionalVersion = Version_1.default.getProvisionalVersionForDimension(dimension);
	        var modulesBetweenFPCenters = provisionalVersion.getDimensionForVersion() - 7;
	        var alignmentPattern = null;
	        // Anything above version 1 has an alignment pattern
	        if (provisionalVersion.getAlignmentPatternCenters().length > 0) {
	            // Guess where a "bottom right" finder pattern would have been
	            var bottomRightX = topRight.getX() - topLeft.getX() + bottomLeft.getX();
	            var bottomRightY = topRight.getY() - topLeft.getY() + bottomLeft.getY();
	            // Estimate that alignment pattern is closer by 3 modules
	            // from "bottom right" to known top left location
	            var correctionToTopLeft = 1.0 - 3.0 / modulesBetweenFPCenters;
	            var estAlignmentX = /*(int) */ Math.floor(topLeft.getX() + correctionToTopLeft * (bottomRightX - topLeft.getX()));
	            var estAlignmentY = /*(int) */ Math.floor(topLeft.getY() + correctionToTopLeft * (bottomRightY - topLeft.getY()));
	            // Kind of arbitrary -- expand search radius before giving up
	            for (var i = 4; i <= 16; i <<= 1) {
	                try {
	                    alignmentPattern = this.findAlignmentInRegion(moduleSize, estAlignmentX, estAlignmentY, i);
	                    break;
	                }
	                catch (re /*NotFoundException*/) {
	                    if (!(re instanceof NotFoundException_1$1.default)) {
	                        throw re;
	                    }
	                    // try next round
	                }
	            }
	            // If we didn't find alignment pattern... well try anyway without it
	        }
	        var transform = Detector.createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension);
	        var bits = Detector.sampleGrid(this.image, transform, dimension);
	        var points;
	        if (alignmentPattern === null) {
	            points = [bottomLeft, topLeft, topRight];
	        }
	        else {
	            points = [bottomLeft, topLeft, topRight, alignmentPattern];
	        }
	        return new DetectorResult_1.default(bits, points);
	    };
	    Detector.createTransform = function (topLeft, topRight, bottomLeft, alignmentPattern, dimension /*int*/) {
	        var dimMinusThree = dimension - 3.5;
	        var bottomRightX; /*float*/
	        var bottomRightY; /*float*/
	        var sourceBottomRightX; /*float*/
	        var sourceBottomRightY; /*float*/
	        if (alignmentPattern !== null) {
	            bottomRightX = alignmentPattern.getX();
	            bottomRightY = alignmentPattern.getY();
	            sourceBottomRightX = dimMinusThree - 3.0;
	            sourceBottomRightY = sourceBottomRightX;
	        }
	        else {
	            // Don't have an alignment pattern, just make up the bottom-right point
	            bottomRightX = (topRight.getX() - topLeft.getX()) + bottomLeft.getX();
	            bottomRightY = (topRight.getY() - topLeft.getY()) + bottomLeft.getY();
	            sourceBottomRightX = dimMinusThree;
	            sourceBottomRightY = dimMinusThree;
	        }
	        return PerspectiveTransform_1.default.quadrilateralToQuadrilateral(3.5, 3.5, dimMinusThree, 3.5, sourceBottomRightX, sourceBottomRightY, 3.5, dimMinusThree, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRightX, bottomRightY, bottomLeft.getX(), bottomLeft.getY());
	    };
	    Detector.sampleGrid = function (image, transform, dimension /*int*/) {
	        var sampler = GridSamplerInstance_1.default.getInstance();
	        return sampler.sampleGridWithTransform(image, dimension, dimension, transform);
	    };
	    /**
	     * <p>Computes the dimension (number of modules on a size) of the QR Code based on the position
	     * of the finder patterns and estimated module size.</p>
	     */
	    Detector.computeDimension = function (topLeft, topRight, bottomLeft, moduleSize /*float*/) {
	        var tltrCentersDimension = MathUtils_1.default.round(ResultPoint_1.default.distance(topLeft, topRight) / moduleSize);
	        var tlblCentersDimension = MathUtils_1.default.round(ResultPoint_1.default.distance(topLeft, bottomLeft) / moduleSize);
	        var dimension = Math.floor((tltrCentersDimension + tlblCentersDimension) / 2) + 7;
	        switch (dimension & 0x03) { // mod 4
	            case 0:
	                dimension++;
	                break;
	            // 1? do nothing
	            case 2:
	                dimension--;
	                break;
	            case 3:
	                throw new NotFoundException_1$1.default('Dimensions could be not found.');
	        }
	        return dimension;
	    };
	    /**
	     * <p>Computes an average estimated module size based on estimated derived from the positions
	     * of the three finder patterns.</p>
	     *
	     * @param topLeft detected top-left finder pattern center
	     * @param topRight detected top-right finder pattern center
	     * @param bottomLeft detected bottom-left finder pattern center
	     * @return estimated module size
	     */
	    Detector.prototype.calculateModuleSize = function (topLeft, topRight, bottomLeft) {
	        // Take the average
	        return (this.calculateModuleSizeOneWay(topLeft, topRight) +
	            this.calculateModuleSizeOneWay(topLeft, bottomLeft)) / 2.0;
	    };
	    /**
	     * <p>Estimates module size based on two finder patterns -- it uses
	     * {@link #sizeOfBlackWhiteBlackRunBothWays(int, int, int, int)} to figure the
	     * width of each, measuring along the axis between their centers.</p>
	     */
	    Detector.prototype.calculateModuleSizeOneWay = function (pattern, otherPattern) {
	        var moduleSizeEst1 = this.sizeOfBlackWhiteBlackRunBothWays(/*(int) */ Math.floor(pattern.getX()), 
	        /*(int) */ Math.floor(pattern.getY()), 
	        /*(int) */ Math.floor(otherPattern.getX()), 
	        /*(int) */ Math.floor(otherPattern.getY()));
	        var moduleSizeEst2 = this.sizeOfBlackWhiteBlackRunBothWays(/*(int) */ Math.floor(otherPattern.getX()), 
	        /*(int) */ Math.floor(otherPattern.getY()), 
	        /*(int) */ Math.floor(pattern.getX()), 
	        /*(int) */ Math.floor(pattern.getY()));
	        if (isNaN(moduleSizeEst1)) {
	            return moduleSizeEst2 / 7.0;
	        }
	        if (isNaN(moduleSizeEst2)) {
	            return moduleSizeEst1 / 7.0;
	        }
	        // Average them, and divide by 7 since we've counted the width of 3 black modules,
	        // and 1 white and 1 black module on either side. Ergo, divide sum by 14.
	        return (moduleSizeEst1 + moduleSizeEst2) / 14.0;
	    };
	    /**
	     * See {@link #sizeOfBlackWhiteBlackRun(int, int, int, int)}; computes the total width of
	     * a finder pattern by looking for a black-white-black run from the center in the direction
	     * of another point (another finder pattern center), and in the opposite direction too.
	     */
	    Detector.prototype.sizeOfBlackWhiteBlackRunBothWays = function (fromX /*int*/, fromY /*int*/, toX /*int*/, toY /*int*/) {
	        var result = this.sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY);
	        // Now count other way -- don't run off image though of course
	        var scale = 1.0;
	        var otherToX = fromX - (toX - fromX);
	        if (otherToX < 0) {
	            scale = fromX / /*(float) */ (fromX - otherToX);
	            otherToX = 0;
	        }
	        else if (otherToX >= this.image.getWidth()) {
	            scale = (this.image.getWidth() - 1 - fromX) / /*(float) */ (otherToX - fromX);
	            otherToX = this.image.getWidth() - 1;
	        }
	        var otherToY = /*(int) */ Math.floor(fromY - (toY - fromY) * scale);
	        scale = 1.0;
	        if (otherToY < 0) {
	            scale = fromY / /*(float) */ (fromY - otherToY);
	            otherToY = 0;
	        }
	        else if (otherToY >= this.image.getHeight()) {
	            scale = (this.image.getHeight() - 1 - fromY) / /*(float) */ (otherToY - fromY);
	            otherToY = this.image.getHeight() - 1;
	        }
	        otherToX = /*(int) */ Math.floor(fromX + (otherToX - fromX) * scale);
	        result += this.sizeOfBlackWhiteBlackRun(fromX, fromY, otherToX, otherToY);
	        // Middle pixel is double-counted this way; subtract 1
	        return result - 1.0;
	    };
	    /**
	     * <p>This method traces a line from a point in the image, in the direction towards another point.
	     * It begins in a black region, and keeps going until it finds white, then black, then white again.
	     * It reports the distance from the start to this point.</p>
	     *
	     * <p>This is used when figuring out how wide a finder pattern is, when the finder pattern
	     * may be skewed or rotated.</p>
	     */
	    Detector.prototype.sizeOfBlackWhiteBlackRun = function (fromX /*int*/, fromY /*int*/, toX /*int*/, toY /*int*/) {
	        // Mild variant of Bresenham's algorithm
	        // see http://en.wikipedia.org/wiki/Bresenham's_line_algorithm
	        var steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);
	        if (steep) {
	            var temp = fromX;
	            fromX = fromY;
	            fromY = temp;
	            temp = toX;
	            toX = toY;
	            toY = temp;
	        }
	        var dx = Math.abs(toX - fromX);
	        var dy = Math.abs(toY - fromY);
	        var error = -dx / 2;
	        var xstep = fromX < toX ? 1 : -1;
	        var ystep = fromY < toY ? 1 : -1;
	        // In black pixels, looking for white, first or second time.
	        var state = 0;
	        // Loop up until x == toX, but not beyond
	        var xLimit = toX + xstep;
	        for (var x = fromX, y = fromY; x !== xLimit; x += xstep) {
	            var realX = steep ? y : x;
	            var realY = steep ? x : y;
	            // Does current pixel mean we have moved white to black or vice versa?
	            // Scanning black in state 0,2 and white in state 1, so if we find the wrong
	            // color, advance to next state or end if we are in state 2 already
	            if ((state === 1) === this.image.get(realX, realY)) {
	                if (state === 2) {
	                    return MathUtils_1.default.distance(x, y, fromX, fromY);
	                }
	                state++;
	            }
	            error += dy;
	            if (error > 0) {
	                if (y === toY) {
	                    break;
	                }
	                y += ystep;
	                error -= dx;
	            }
	        }
	        // Found black-white-black; give the benefit of the doubt that the next pixel outside the image
	        // is "white" so this last point at (toX+xStep,toY) is the right ending. This is really a
	        // small approximation; (toX+xStep,toY+yStep) might be really correct. Ignore this.
	        if (state === 2) {
	            return MathUtils_1.default.distance(toX + xstep, toY, fromX, fromY);
	        }
	        // else we didn't find even black-white-black; no estimate is really possible
	        return NaN;
	    };
	    /**
	     * <p>Attempts to locate an alignment pattern in a limited region of the image, which is
	     * guessed to contain it. This method uses {@link AlignmentPattern}.</p>
	     *
	     * @param overallEstModuleSize estimated module size so far
	     * @param estAlignmentX x coordinate of center of area probably containing alignment pattern
	     * @param estAlignmentY y coordinate of above
	     * @param allowanceFactor number of pixels in all directions to search from the center
	     * @return {@link AlignmentPattern} if found, or null otherwise
	     * @throws NotFoundException if an unexpected error occurs during detection
	     */
	    Detector.prototype.findAlignmentInRegion = function (overallEstModuleSize /*float*/, estAlignmentX /*int*/, estAlignmentY /*int*/, allowanceFactor /*float*/) {
	        // Look for an alignment pattern (3 modules in size) around where it
	        // should be
	        var allowance = /*(int) */ Math.floor(allowanceFactor * overallEstModuleSize);
	        var alignmentAreaLeftX = Math.max(0, estAlignmentX - allowance);
	        var alignmentAreaRightX = Math.min(this.image.getWidth() - 1, estAlignmentX + allowance);
	        if (alignmentAreaRightX - alignmentAreaLeftX < overallEstModuleSize * 3) {
	            throw new NotFoundException_1$1.default('Alignment top exceeds estimated module size.');
	        }
	        var alignmentAreaTopY = Math.max(0, estAlignmentY - allowance);
	        var alignmentAreaBottomY = Math.min(this.image.getHeight() - 1, estAlignmentY + allowance);
	        if (alignmentAreaBottomY - alignmentAreaTopY < overallEstModuleSize * 3) {
	            throw new NotFoundException_1$1.default('Alignment bottom exceeds estimated module size.');
	        }
	        var alignmentFinder = new AlignmentPatternFinder_1.default(this.image, alignmentAreaLeftX, alignmentAreaTopY, alignmentAreaRightX - alignmentAreaLeftX, alignmentAreaBottomY - alignmentAreaTopY, overallEstModuleSize, this.resultPointCallback);
	        return alignmentFinder.find();
	    };
	    return Detector;
	}());
	Detector$1.default = Detector;

	/*
	 * Copyright 2007 ZXing authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(QRCodeReader$1, "__esModule", { value: true });
	/*namespace com.google.zxing.qrcode {*/
	var BarcodeFormat_1 = BarcodeFormat$1;
	var BitMatrix_1 = BitMatrix$1;
	var DecodeHintType_1 = DecodeHintType$1;
	var NotFoundException_1 = NotFoundException$1;
	var Result_1 = Result$1;
	var ResultMetadataType_1 = ResultMetadataType$1;
	// import DetectorResult from '../common/DetectorResult';
	var Decoder_1 = Decoder$1;
	var QRCodeDecoderMetaData_1 = QRCodeDecoderMetaData$1;
	var Detector_1 = Detector$1;
	/*import java.util.List;*/
	/*import java.util.Map;*/
	/**
	 * This implementation can detect and decode QR Codes in an image.
	 *
	 * @author Sean Owen
	 */
	var QRCodeReader = /** @class */ (function () {
	    function QRCodeReader() {
	        this.decoder = new Decoder_1.default();
	    }
	    QRCodeReader.prototype.getDecoder = function () {
	        return this.decoder;
	    };
	    /**
	     * Locates and decodes a QR code in an image.
	     *
	     * @return a representing: string the content encoded by the QR code
	     * @throws NotFoundException if a QR code cannot be found
	     * @throws FormatException if a QR code cannot be decoded
	     * @throws ChecksumException if error correction fails
	     */
	    /*@Override*/
	    // public decode(image: BinaryBitmap): Result /*throws NotFoundException, ChecksumException, FormatException */ {
	    //   return this.decode(image, null)
	    // }
	    /*@Override*/
	    QRCodeReader.prototype.decode = function (image, hints) {
	        var decoderResult;
	        var points;
	        if (hints !== undefined && hints !== null && undefined !== hints.get(DecodeHintType_1.default.PURE_BARCODE)) {
	            var bits = QRCodeReader.extractPureBits(image.getBlackMatrix());
	            decoderResult = this.decoder.decodeBitMatrix(bits, hints);
	            points = QRCodeReader.NO_POINTS;
	        }
	        else {
	            var detectorResult = new Detector_1.default(image.getBlackMatrix()).detect(hints);
	            decoderResult = this.decoder.decodeBitMatrix(detectorResult.getBits(), hints);
	            points = detectorResult.getPoints();
	        }
	        // If the code was mirrored: swap the bottom-left and the top-right points.
	        if (decoderResult.getOther() instanceof QRCodeDecoderMetaData_1.default) {
	            decoderResult.getOther().applyMirroredCorrection(points);
	        }
	        var result = new Result_1.default(decoderResult.getText(), decoderResult.getRawBytes(), undefined, points, BarcodeFormat_1.default.QR_CODE, undefined);
	        var byteSegments = decoderResult.getByteSegments();
	        if (byteSegments !== null) {
	            result.putMetadata(ResultMetadataType_1.default.BYTE_SEGMENTS, byteSegments);
	        }
	        var ecLevel = decoderResult.getECLevel();
	        if (ecLevel !== null) {
	            result.putMetadata(ResultMetadataType_1.default.ERROR_CORRECTION_LEVEL, ecLevel);
	        }
	        if (decoderResult.hasStructuredAppend()) {
	            result.putMetadata(ResultMetadataType_1.default.STRUCTURED_APPEND_SEQUENCE, decoderResult.getStructuredAppendSequenceNumber());
	            result.putMetadata(ResultMetadataType_1.default.STRUCTURED_APPEND_PARITY, decoderResult.getStructuredAppendParity());
	        }
	        return result;
	    };
	    /*@Override*/
	    QRCodeReader.prototype.reset = function () {
	        // do nothing
	    };
	    /**
	     * This method detects a code in a "pure" image -- that is, pure monochrome image
	     * which contains only an unrotated, unskewed, image of a code, with some white border
	     * around it. This is a specialized method that works exceptionally fast in this special
	     * case.
	     *
	     * @see com.google.zxing.datamatrix.DataMatrixReader#extractPureBits(BitMatrix)
	     */
	    QRCodeReader.extractPureBits = function (image) {
	        var leftTopBlack = image.getTopLeftOnBit();
	        var rightBottomBlack = image.getBottomRightOnBit();
	        if (leftTopBlack === null || rightBottomBlack === null) {
	            throw new NotFoundException_1.default();
	        }
	        var moduleSize = this.moduleSize(leftTopBlack, image);
	        var top = leftTopBlack[1];
	        var bottom = rightBottomBlack[1];
	        var left = leftTopBlack[0];
	        var right = rightBottomBlack[0];
	        // Sanity check!
	        if (left >= right || top >= bottom) {
	            throw new NotFoundException_1.default();
	        }
	        if (bottom - top !== right - left) {
	            // Special case, where bottom-right module wasn't black so we found something else in the last row
	            // Assume it's a square, so use height as the width
	            right = left + (bottom - top);
	            if (right >= image.getWidth()) {
	                // Abort if that would not make sense -- off image
	                throw new NotFoundException_1.default();
	            }
	        }
	        var matrixWidth = Math.round((right - left + 1) / moduleSize);
	        var matrixHeight = Math.round((bottom - top + 1) / moduleSize);
	        if (matrixWidth <= 0 || matrixHeight <= 0) {
	            throw new NotFoundException_1.default();
	        }
	        if (matrixHeight !== matrixWidth) {
	            // Only possibly decode square regions
	            throw new NotFoundException_1.default();
	        }
	        // Push in the "border" by half the module width so that we start
	        // sampling in the middle of the module. Just in case the image is a
	        // little off, this will help recover.
	        var nudge = /*(int) */ Math.floor(moduleSize / 2.0);
	        top += nudge;
	        left += nudge;
	        // But careful that this does not sample off the edge
	        // "right" is the farthest-right valid pixel location -- right+1 is not necessarily
	        // This is positive by how much the inner x loop below would be too large
	        var nudgedTooFarRight = left + /*(int) */ Math.floor((matrixWidth - 1) * moduleSize) - right;
	        if (nudgedTooFarRight > 0) {
	            if (nudgedTooFarRight > nudge) {
	                // Neither way fits; abort
	                throw new NotFoundException_1.default();
	            }
	            left -= nudgedTooFarRight;
	        }
	        // See logic above
	        var nudgedTooFarDown = top + /*(int) */ Math.floor((matrixHeight - 1) * moduleSize) - bottom;
	        if (nudgedTooFarDown > 0) {
	            if (nudgedTooFarDown > nudge) {
	                // Neither way fits; abort
	                throw new NotFoundException_1.default();
	            }
	            top -= nudgedTooFarDown;
	        }
	        // Now just read off the bits
	        var bits = new BitMatrix_1.default(matrixWidth, matrixHeight);
	        for (var y = 0; y < matrixHeight; y++) {
	            var iOffset = top + /*(int) */ Math.floor(y * moduleSize);
	            for (var x = 0; x < matrixWidth; x++) {
	                if (image.get(left + /*(int) */ Math.floor(x * moduleSize), iOffset)) {
	                    bits.set(x, y);
	                }
	            }
	        }
	        return bits;
	    };
	    QRCodeReader.moduleSize = function (leftTopBlack, image) {
	        var height = image.getHeight();
	        var width = image.getWidth();
	        var x = leftTopBlack[0];
	        var y = leftTopBlack[1];
	        var inBlack = true;
	        var transitions = 0;
	        while (x < width && y < height) {
	            if (inBlack !== image.get(x, y)) {
	                if (++transitions === 5) {
	                    break;
	                }
	                inBlack = !inBlack;
	            }
	            x++;
	            y++;
	        }
	        if (x === width || y === height) {
	            throw new NotFoundException_1.default();
	        }
	        return (x - leftTopBlack[0]) / 7.0;
	    };
	    QRCodeReader.NO_POINTS = new Array();
	    return QRCodeReader;
	}());
	var _default = QRCodeReader$1.default = QRCodeReader;

	var toGrayscaleBuffer = function toGrayscaleBuffer(imageBuffer, width, height) {
	  var grayscaleBuffer = new Uint8ClampedArray(width * height);

	  for (var i = 0, j = 0, length_1 = imageBuffer.length; i < length_1; i += 4, j++) {
	    var gray = void 0;
	    var alpha = imageBuffer[i + 3]; // The color of fully-transparent pixels is irrelevant. They are often, technically, fully-transparent
	    // black (0 alpha, and then 0 RGB). They are often used, of course as the "white" area in a
	    // barcode image. Force any such pixel to be white:

	    if (alpha === 0) {
	      gray = 0xFF;
	    } else {
	      var pixelR = imageBuffer[i];
	      var pixelG = imageBuffer[i + 1];
	      var pixelB = imageBuffer[i + 2]; // .299R + 0.587G + 0.114B (YUV/YIQ for PAL and NTSC),
	      // (306*R) >> 10 is approximately equal to R*0.299, and so on.
	      // 0x200 >> 10 is 0.5, it implements rounding.

	      gray = 306 * pixelR + 601 * pixelG + 117 * pixelB + 0x200 >> 10;
	    }

	    grayscaleBuffer[j] = gray;
	  }

	  return grayscaleBuffer;
	};

	var reader = new _default();
	self.addEventListener('message', function (e) {
	  // eslint-disable-line no-restricted-globals
	  try {
	    var luminances = toGrayscaleBuffer(e.data.data, e.data.width, e.data.height);
	    var luminanceSource = new _default$1(luminances, e.data.width, e.data.height);
	    var hybridBinarizer = new _default$2(luminanceSource);
	    var binaryBitmap = new _default$3(hybridBinarizer);
	    var decoded = reader.decode(binaryBitmap);
	    postMessage(decoded);
	  } catch (err) {
	    postMessage(null);
	  }
	});

})();
